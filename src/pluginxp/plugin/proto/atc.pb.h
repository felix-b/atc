// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: atc.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_atc_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_atc_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_atc_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_atc_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[42]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_atc_2eproto;
namespace atc_proto {
class AircraftMessage;
class AircraftMessageDefaultTypeInternal;
extern AircraftMessageDefaultTypeInternal _AircraftMessage_default_instance_;
class AircraftMessage_Situation;
class AircraftMessage_SituationDefaultTypeInternal;
extern AircraftMessage_SituationDefaultTypeInternal _AircraftMessage_Situation_default_instance_;
class AirportMessage;
class AirportMessageDefaultTypeInternal;
extern AirportMessageDefaultTypeInternal _AirportMessage_default_instance_;
class AirspaceGeometryMessage;
class AirspaceGeometryMessageDefaultTypeInternal;
extern AirspaceGeometryMessageDefaultTypeInternal _AirspaceGeometryMessage_default_instance_;
class AttitudeMessage;
class AttitudeMessageDefaultTypeInternal;
extern AttitudeMessageDefaultTypeInternal _AttitudeMessage_default_instance_;
class ClientToServer;
class ClientToServerDefaultTypeInternal;
extern ClientToServerDefaultTypeInternal _ClientToServer_default_instance_;
class ClientToServer_CancelTrafficQuery;
class ClientToServer_CancelTrafficQueryDefaultTypeInternal;
extern ClientToServer_CancelTrafficQueryDefaultTypeInternal _ClientToServer_CancelTrafficQuery_default_instance_;
class ClientToServer_Connect;
class ClientToServer_ConnectDefaultTypeInternal;
extern ClientToServer_ConnectDefaultTypeInternal _ClientToServer_Connect_default_instance_;
class ClientToServer_CreateAircraft;
class ClientToServer_CreateAircraftDefaultTypeInternal;
extern ClientToServer_CreateAircraftDefaultTypeInternal _ClientToServer_CreateAircraft_default_instance_;
class ClientToServer_QueryAirport;
class ClientToServer_QueryAirportDefaultTypeInternal;
extern ClientToServer_QueryAirportDefaultTypeInternal _ClientToServer_QueryAirport_default_instance_;
class ClientToServer_QueryTaxiPath;
class ClientToServer_QueryTaxiPathDefaultTypeInternal;
extern ClientToServer_QueryTaxiPathDefaultTypeInternal _ClientToServer_QueryTaxiPath_default_instance_;
class ClientToServer_QueryTraffic;
class ClientToServer_QueryTrafficDefaultTypeInternal;
extern ClientToServer_QueryTrafficDefaultTypeInternal _ClientToServer_QueryTraffic_default_instance_;
class ClientToServer_RemoveAircraft;
class ClientToServer_RemoveAircraftDefaultTypeInternal;
extern ClientToServer_RemoveAircraftDefaultTypeInternal _ClientToServer_RemoveAircraft_default_instance_;
class ClientToServer_UpdateAircraftSituation;
class ClientToServer_UpdateAircraftSituationDefaultTypeInternal;
extern ClientToServer_UpdateAircraftSituationDefaultTypeInternal _ClientToServer_UpdateAircraftSituation_default_instance_;
class ClientToServer_UserAcquireAircraft;
class ClientToServer_UserAcquireAircraftDefaultTypeInternal;
extern ClientToServer_UserAcquireAircraftDefaultTypeInternal _ClientToServer_UserAcquireAircraft_default_instance_;
class ClientToServer_UserPttPressed;
class ClientToServer_UserPttPressedDefaultTypeInternal;
extern ClientToServer_UserPttPressedDefaultTypeInternal _ClientToServer_UserPttPressed_default_instance_;
class ClientToServer_UserPttReleased;
class ClientToServer_UserPttReleasedDefaultTypeInternal;
extern ClientToServer_UserPttReleasedDefaultTypeInternal _ClientToServer_UserPttReleased_default_instance_;
class ClientToServer_UserReleaseAircraft;
class ClientToServer_UserReleaseAircraftDefaultTypeInternal;
extern ClientToServer_UserReleaseAircraftDefaultTypeInternal _ClientToServer_UserReleaseAircraft_default_instance_;
class ClientToServer_UserUpdateAircraftSituation;
class ClientToServer_UserUpdateAircraftSituationDefaultTypeInternal;
extern ClientToServer_UserUpdateAircraftSituationDefaultTypeInternal _ClientToServer_UserUpdateAircraftSituation_default_instance_;
class GeoPoint;
class GeoPointDefaultTypeInternal;
extern GeoPointDefaultTypeInternal _GeoPoint_default_instance_;
class GeoPolygon;
class GeoPolygonDefaultTypeInternal;
extern GeoPolygonDefaultTypeInternal _GeoPolygon_default_instance_;
class GeoPolygon_GeoEdge;
class GeoPolygon_GeoEdgeDefaultTypeInternal;
extern GeoPolygon_GeoEdgeDefaultTypeInternal _GeoPolygon_GeoEdge_default_instance_;
class ParkingStandMessage;
class ParkingStandMessageDefaultTypeInternal;
extern ParkingStandMessageDefaultTypeInternal _ParkingStandMessage_default_instance_;
class RunwayMessage;
class RunwayMessageDefaultTypeInternal;
extern RunwayMessageDefaultTypeInternal _RunwayMessage_default_instance_;
class RunwayMessage_End;
class RunwayMessage_EndDefaultTypeInternal;
extern RunwayMessage_EndDefaultTypeInternal _RunwayMessage_End_default_instance_;
class ServerToClient;
class ServerToClientDefaultTypeInternal;
extern ServerToClientDefaultTypeInternal _ServerToClient_default_instance_;
class ServerToClient_FaultDeclined;
class ServerToClient_FaultDeclinedDefaultTypeInternal;
extern ServerToClient_FaultDeclinedDefaultTypeInternal _ServerToClient_FaultDeclined_default_instance_;
class ServerToClient_FaultNotFound;
class ServerToClient_FaultNotFoundDefaultTypeInternal;
extern ServerToClient_FaultNotFoundDefaultTypeInternal _ServerToClient_FaultNotFound_default_instance_;
class ServerToClient_NotifyAircraftCreated;
class ServerToClient_NotifyAircraftCreatedDefaultTypeInternal;
extern ServerToClient_NotifyAircraftCreatedDefaultTypeInternal _ServerToClient_NotifyAircraftCreated_default_instance_;
class ServerToClient_NotifyAircraftRemoved;
class ServerToClient_NotifyAircraftRemovedDefaultTypeInternal;
extern ServerToClient_NotifyAircraftRemovedDefaultTypeInternal _ServerToClient_NotifyAircraftRemoved_default_instance_;
class ServerToClient_NotifyAircraftSituationUpdated;
class ServerToClient_NotifyAircraftSituationUpdatedDefaultTypeInternal;
extern ServerToClient_NotifyAircraftSituationUpdatedDefaultTypeInternal _ServerToClient_NotifyAircraftSituationUpdated_default_instance_;
class ServerToClient_ReplyConnect;
class ServerToClient_ReplyConnectDefaultTypeInternal;
extern ServerToClient_ReplyConnectDefaultTypeInternal _ServerToClient_ReplyConnect_default_instance_;
class ServerToClient_ReplyCreateAircraft;
class ServerToClient_ReplyCreateAircraftDefaultTypeInternal;
extern ServerToClient_ReplyCreateAircraftDefaultTypeInternal _ServerToClient_ReplyCreateAircraft_default_instance_;
class ServerToClient_ReplyQueryAirport;
class ServerToClient_ReplyQueryAirportDefaultTypeInternal;
extern ServerToClient_ReplyQueryAirportDefaultTypeInternal _ServerToClient_ReplyQueryAirport_default_instance_;
class ServerToClient_ReplyQueryTaxiPath;
class ServerToClient_ReplyQueryTaxiPathDefaultTypeInternal;
extern ServerToClient_ReplyQueryTaxiPathDefaultTypeInternal _ServerToClient_ReplyQueryTaxiPath_default_instance_;
class ServerToClient_ReplyQueryTraffic;
class ServerToClient_ReplyQueryTrafficDefaultTypeInternal;
extern ServerToClient_ReplyQueryTrafficDefaultTypeInternal _ServerToClient_ReplyQueryTraffic_default_instance_;
class ServerToClient_ReplyUserAcquireAircraft;
class ServerToClient_ReplyUserAcquireAircraftDefaultTypeInternal;
extern ServerToClient_ReplyUserAcquireAircraftDefaultTypeInternal _ServerToClient_ReplyUserAcquireAircraft_default_instance_;
class TaxiEdgeMessage;
class TaxiEdgeMessageDefaultTypeInternal;
extern TaxiEdgeMessageDefaultTypeInternal _TaxiEdgeMessage_default_instance_;
class TaxiEdgeMessage_ActiveZoneMatrix;
class TaxiEdgeMessage_ActiveZoneMatrixDefaultTypeInternal;
extern TaxiEdgeMessage_ActiveZoneMatrixDefaultTypeInternal _TaxiEdgeMessage_ActiveZoneMatrix_default_instance_;
class TaxiNodeMessage;
class TaxiNodeMessageDefaultTypeInternal;
extern TaxiNodeMessageDefaultTypeInternal _TaxiNodeMessage_default_instance_;
class TaxiPathMessage;
class TaxiPathMessageDefaultTypeInternal;
extern TaxiPathMessageDefaultTypeInternal _TaxiPathMessage_default_instance_;
class Vector3dMessage;
class Vector3dMessageDefaultTypeInternal;
extern Vector3dMessageDefaultTypeInternal _Vector3dMessage_default_instance_;
}  // namespace atc_proto
PROTOBUF_NAMESPACE_OPEN
template<> ::atc_proto::AircraftMessage* Arena::CreateMaybeMessage<::atc_proto::AircraftMessage>(Arena*);
template<> ::atc_proto::AircraftMessage_Situation* Arena::CreateMaybeMessage<::atc_proto::AircraftMessage_Situation>(Arena*);
template<> ::atc_proto::AirportMessage* Arena::CreateMaybeMessage<::atc_proto::AirportMessage>(Arena*);
template<> ::atc_proto::AirspaceGeometryMessage* Arena::CreateMaybeMessage<::atc_proto::AirspaceGeometryMessage>(Arena*);
template<> ::atc_proto::AttitudeMessage* Arena::CreateMaybeMessage<::atc_proto::AttitudeMessage>(Arena*);
template<> ::atc_proto::ClientToServer* Arena::CreateMaybeMessage<::atc_proto::ClientToServer>(Arena*);
template<> ::atc_proto::ClientToServer_CancelTrafficQuery* Arena::CreateMaybeMessage<::atc_proto::ClientToServer_CancelTrafficQuery>(Arena*);
template<> ::atc_proto::ClientToServer_Connect* Arena::CreateMaybeMessage<::atc_proto::ClientToServer_Connect>(Arena*);
template<> ::atc_proto::ClientToServer_CreateAircraft* Arena::CreateMaybeMessage<::atc_proto::ClientToServer_CreateAircraft>(Arena*);
template<> ::atc_proto::ClientToServer_QueryAirport* Arena::CreateMaybeMessage<::atc_proto::ClientToServer_QueryAirport>(Arena*);
template<> ::atc_proto::ClientToServer_QueryTaxiPath* Arena::CreateMaybeMessage<::atc_proto::ClientToServer_QueryTaxiPath>(Arena*);
template<> ::atc_proto::ClientToServer_QueryTraffic* Arena::CreateMaybeMessage<::atc_proto::ClientToServer_QueryTraffic>(Arena*);
template<> ::atc_proto::ClientToServer_RemoveAircraft* Arena::CreateMaybeMessage<::atc_proto::ClientToServer_RemoveAircraft>(Arena*);
template<> ::atc_proto::ClientToServer_UpdateAircraftSituation* Arena::CreateMaybeMessage<::atc_proto::ClientToServer_UpdateAircraftSituation>(Arena*);
template<> ::atc_proto::ClientToServer_UserAcquireAircraft* Arena::CreateMaybeMessage<::atc_proto::ClientToServer_UserAcquireAircraft>(Arena*);
template<> ::atc_proto::ClientToServer_UserPttPressed* Arena::CreateMaybeMessage<::atc_proto::ClientToServer_UserPttPressed>(Arena*);
template<> ::atc_proto::ClientToServer_UserPttReleased* Arena::CreateMaybeMessage<::atc_proto::ClientToServer_UserPttReleased>(Arena*);
template<> ::atc_proto::ClientToServer_UserReleaseAircraft* Arena::CreateMaybeMessage<::atc_proto::ClientToServer_UserReleaseAircraft>(Arena*);
template<> ::atc_proto::ClientToServer_UserUpdateAircraftSituation* Arena::CreateMaybeMessage<::atc_proto::ClientToServer_UserUpdateAircraftSituation>(Arena*);
template<> ::atc_proto::GeoPoint* Arena::CreateMaybeMessage<::atc_proto::GeoPoint>(Arena*);
template<> ::atc_proto::GeoPolygon* Arena::CreateMaybeMessage<::atc_proto::GeoPolygon>(Arena*);
template<> ::atc_proto::GeoPolygon_GeoEdge* Arena::CreateMaybeMessage<::atc_proto::GeoPolygon_GeoEdge>(Arena*);
template<> ::atc_proto::ParkingStandMessage* Arena::CreateMaybeMessage<::atc_proto::ParkingStandMessage>(Arena*);
template<> ::atc_proto::RunwayMessage* Arena::CreateMaybeMessage<::atc_proto::RunwayMessage>(Arena*);
template<> ::atc_proto::RunwayMessage_End* Arena::CreateMaybeMessage<::atc_proto::RunwayMessage_End>(Arena*);
template<> ::atc_proto::ServerToClient* Arena::CreateMaybeMessage<::atc_proto::ServerToClient>(Arena*);
template<> ::atc_proto::ServerToClient_FaultDeclined* Arena::CreateMaybeMessage<::atc_proto::ServerToClient_FaultDeclined>(Arena*);
template<> ::atc_proto::ServerToClient_FaultNotFound* Arena::CreateMaybeMessage<::atc_proto::ServerToClient_FaultNotFound>(Arena*);
template<> ::atc_proto::ServerToClient_NotifyAircraftCreated* Arena::CreateMaybeMessage<::atc_proto::ServerToClient_NotifyAircraftCreated>(Arena*);
template<> ::atc_proto::ServerToClient_NotifyAircraftRemoved* Arena::CreateMaybeMessage<::atc_proto::ServerToClient_NotifyAircraftRemoved>(Arena*);
template<> ::atc_proto::ServerToClient_NotifyAircraftSituationUpdated* Arena::CreateMaybeMessage<::atc_proto::ServerToClient_NotifyAircraftSituationUpdated>(Arena*);
template<> ::atc_proto::ServerToClient_ReplyConnect* Arena::CreateMaybeMessage<::atc_proto::ServerToClient_ReplyConnect>(Arena*);
template<> ::atc_proto::ServerToClient_ReplyCreateAircraft* Arena::CreateMaybeMessage<::atc_proto::ServerToClient_ReplyCreateAircraft>(Arena*);
template<> ::atc_proto::ServerToClient_ReplyQueryAirport* Arena::CreateMaybeMessage<::atc_proto::ServerToClient_ReplyQueryAirport>(Arena*);
template<> ::atc_proto::ServerToClient_ReplyQueryTaxiPath* Arena::CreateMaybeMessage<::atc_proto::ServerToClient_ReplyQueryTaxiPath>(Arena*);
template<> ::atc_proto::ServerToClient_ReplyQueryTraffic* Arena::CreateMaybeMessage<::atc_proto::ServerToClient_ReplyQueryTraffic>(Arena*);
template<> ::atc_proto::ServerToClient_ReplyUserAcquireAircraft* Arena::CreateMaybeMessage<::atc_proto::ServerToClient_ReplyUserAcquireAircraft>(Arena*);
template<> ::atc_proto::TaxiEdgeMessage* Arena::CreateMaybeMessage<::atc_proto::TaxiEdgeMessage>(Arena*);
template<> ::atc_proto::TaxiEdgeMessage_ActiveZoneMatrix* Arena::CreateMaybeMessage<::atc_proto::TaxiEdgeMessage_ActiveZoneMatrix>(Arena*);
template<> ::atc_proto::TaxiNodeMessage* Arena::CreateMaybeMessage<::atc_proto::TaxiNodeMessage>(Arena*);
template<> ::atc_proto::TaxiPathMessage* Arena::CreateMaybeMessage<::atc_proto::TaxiPathMessage>(Arena*);
template<> ::atc_proto::Vector3dMessage* Arena::CreateMaybeMessage<::atc_proto::Vector3dMessage>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace atc_proto {

enum GeoEdgeType : int {
  GEO_EDGE_UNKNOWN = 0,
  GEO_EDGE_ARC_BY_EDGE = 1,
  GEO_EDGE_CIRCLE = 2,
  GEO_EDGE_GREAT_CIRCLE = 3,
  GEO_EDGE_RHUMB_LINE = 4,
  GEO_EDGE_CLOCKWISE_ARC = 5,
  GEO_EDGE_COUNTER_CLOCKWISE_ARC = 6,
  GeoEdgeType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  GeoEdgeType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool GeoEdgeType_IsValid(int value);
constexpr GeoEdgeType GeoEdgeType_MIN = GEO_EDGE_UNKNOWN;
constexpr GeoEdgeType GeoEdgeType_MAX = GEO_EDGE_COUNTER_CLOCKWISE_ARC;
constexpr int GeoEdgeType_ARRAYSIZE = GeoEdgeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GeoEdgeType_descriptor();
template<typename T>
inline const std::string& GeoEdgeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GeoEdgeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GeoEdgeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GeoEdgeType_descriptor(), enum_t_value);
}
inline bool GeoEdgeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GeoEdgeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GeoEdgeType>(
    GeoEdgeType_descriptor(), name, value);
}
enum AircraftCategory : int {
  AIRCRAFT_CATEGORY_NONE = 0,
  AIRCRAFT_CATEGORY_HEAVY = 1,
  AIRCRAFT_CATEGORY_JET = 2,
  AIRCRAFT_CATEGORY_TURBOPROP = 4,
  AIRCRAFT_CATEGORY_PROP = 8,
  AIRCRAFT_CATEGORY_LIGHT_PROP = 16,
  AIRCRAFT_CATEGORY_HELICPOTER = 32,
  AircraftCategory_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AircraftCategory_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AircraftCategory_IsValid(int value);
constexpr AircraftCategory AircraftCategory_MIN = AIRCRAFT_CATEGORY_NONE;
constexpr AircraftCategory AircraftCategory_MAX = AIRCRAFT_CATEGORY_HELICPOTER;
constexpr int AircraftCategory_ARRAYSIZE = AircraftCategory_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AircraftCategory_descriptor();
template<typename T>
inline const std::string& AircraftCategory_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AircraftCategory>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AircraftCategory_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AircraftCategory_descriptor(), enum_t_value);
}
inline bool AircraftCategory_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AircraftCategory* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AircraftCategory>(
    AircraftCategory_descriptor(), name, value);
}
enum OperationType : int {
  AIRCRAFT_OPERATION_NONE = 0,
  AIRCRAFT_OPERATION_GA = 1,
  AIRCRAFT_OPERATION_AIRLINE = 2,
  AIRCRAFT_OPERATION_CARGO = 4,
  AIRCRAFT_OPERATION_MILITARY = 8,
  OperationType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  OperationType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool OperationType_IsValid(int value);
constexpr OperationType OperationType_MIN = AIRCRAFT_OPERATION_NONE;
constexpr OperationType OperationType_MAX = AIRCRAFT_OPERATION_MILITARY;
constexpr int OperationType_ARRAYSIZE = OperationType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OperationType_descriptor();
template<typename T>
inline const std::string& OperationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OperationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OperationType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OperationType_descriptor(), enum_t_value);
}
inline bool OperationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OperationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OperationType>(
    OperationType_descriptor(), name, value);
}
enum ParkingStandType : int {
  PARKING_UNKNOWN = 0,
  PARKING_GATE = 1,
  PARKING_REMOTE = 2,
  PARKING_HANGAR = 3,
  ParkingStandType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ParkingStandType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ParkingStandType_IsValid(int value);
constexpr ParkingStandType ParkingStandType_MIN = PARKING_UNKNOWN;
constexpr ParkingStandType ParkingStandType_MAX = PARKING_HANGAR;
constexpr int ParkingStandType_ARRAYSIZE = ParkingStandType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ParkingStandType_descriptor();
template<typename T>
inline const std::string& ParkingStandType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ParkingStandType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ParkingStandType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ParkingStandType_descriptor(), enum_t_value);
}
inline bool ParkingStandType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ParkingStandType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ParkingStandType>(
    ParkingStandType_descriptor(), name, value);
}
enum TaxiEdgeType : int {
  TAXI_EDGE_GROUNDWAY = 0,
  TAXI_EDGE_TAXIWAY = 1,
  TAXI_EDGE_RUNWAY = 2,
  TaxiEdgeType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TaxiEdgeType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TaxiEdgeType_IsValid(int value);
constexpr TaxiEdgeType TaxiEdgeType_MIN = TAXI_EDGE_GROUNDWAY;
constexpr TaxiEdgeType TaxiEdgeType_MAX = TAXI_EDGE_RUNWAY;
constexpr int TaxiEdgeType_ARRAYSIZE = TaxiEdgeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TaxiEdgeType_descriptor();
template<typename T>
inline const std::string& TaxiEdgeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TaxiEdgeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TaxiEdgeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TaxiEdgeType_descriptor(), enum_t_value);
}
inline bool TaxiEdgeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TaxiEdgeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TaxiEdgeType>(
    TaxiEdgeType_descriptor(), name, value);
}
// ===================================================================

class ClientToServer_Connect PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:atc_proto.ClientToServer.Connect) */ {
 public:
  inline ClientToServer_Connect() : ClientToServer_Connect(nullptr) {}
  virtual ~ClientToServer_Connect();

  ClientToServer_Connect(const ClientToServer_Connect& from);
  ClientToServer_Connect(ClientToServer_Connect&& from) noexcept
    : ClientToServer_Connect() {
    *this = ::std::move(from);
  }

  inline ClientToServer_Connect& operator=(const ClientToServer_Connect& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToServer_Connect& operator=(ClientToServer_Connect&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClientToServer_Connect& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServer_Connect* internal_default_instance() {
    return reinterpret_cast<const ClientToServer_Connect*>(
               &_ClientToServer_Connect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ClientToServer_Connect& a, ClientToServer_Connect& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientToServer_Connect* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientToServer_Connect* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientToServer_Connect* New() const final {
    return CreateMaybeMessage<ClientToServer_Connect>(nullptr);
  }

  ClientToServer_Connect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServer_Connect>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientToServer_Connect& from);
  void MergeFrom(const ClientToServer_Connect& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToServer_Connect* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "atc_proto.ClientToServer.Connect";
  }
  protected:
  explicit ClientToServer_Connect(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_atc_2eproto);
    return ::descriptor_table_atc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
  };
  // string token = 1;
  void clear_token();
  const std::string& token() const;
  void set_token(const std::string& value);
  void set_token(std::string&& value);
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  std::string* mutable_token();
  std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // @@protoc_insertion_point(class_scope:atc_proto.ClientToServer.Connect)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_atc_2eproto;
};
// -------------------------------------------------------------------

class ClientToServer_QueryAirport PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:atc_proto.ClientToServer.QueryAirport) */ {
 public:
  inline ClientToServer_QueryAirport() : ClientToServer_QueryAirport(nullptr) {}
  virtual ~ClientToServer_QueryAirport();

  ClientToServer_QueryAirport(const ClientToServer_QueryAirport& from);
  ClientToServer_QueryAirport(ClientToServer_QueryAirport&& from) noexcept
    : ClientToServer_QueryAirport() {
    *this = ::std::move(from);
  }

  inline ClientToServer_QueryAirport& operator=(const ClientToServer_QueryAirport& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToServer_QueryAirport& operator=(ClientToServer_QueryAirport&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClientToServer_QueryAirport& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServer_QueryAirport* internal_default_instance() {
    return reinterpret_cast<const ClientToServer_QueryAirport*>(
               &_ClientToServer_QueryAirport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ClientToServer_QueryAirport& a, ClientToServer_QueryAirport& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientToServer_QueryAirport* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientToServer_QueryAirport* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientToServer_QueryAirport* New() const final {
    return CreateMaybeMessage<ClientToServer_QueryAirport>(nullptr);
  }

  ClientToServer_QueryAirport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServer_QueryAirport>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientToServer_QueryAirport& from);
  void MergeFrom(const ClientToServer_QueryAirport& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToServer_QueryAirport* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "atc_proto.ClientToServer.QueryAirport";
  }
  protected:
  explicit ClientToServer_QueryAirport(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_atc_2eproto);
    return ::descriptor_table_atc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIcaoCodeFieldNumber = 1,
  };
  // string icao_code = 1;
  void clear_icao_code();
  const std::string& icao_code() const;
  void set_icao_code(const std::string& value);
  void set_icao_code(std::string&& value);
  void set_icao_code(const char* value);
  void set_icao_code(const char* value, size_t size);
  std::string* mutable_icao_code();
  std::string* release_icao_code();
  void set_allocated_icao_code(std::string* icao_code);
  private:
  const std::string& _internal_icao_code() const;
  void _internal_set_icao_code(const std::string& value);
  std::string* _internal_mutable_icao_code();
  public:

  // @@protoc_insertion_point(class_scope:atc_proto.ClientToServer.QueryAirport)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr icao_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_atc_2eproto;
};
// -------------------------------------------------------------------

class ClientToServer_QueryTaxiPath PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:atc_proto.ClientToServer.QueryTaxiPath) */ {
 public:
  inline ClientToServer_QueryTaxiPath() : ClientToServer_QueryTaxiPath(nullptr) {}
  virtual ~ClientToServer_QueryTaxiPath();

  ClientToServer_QueryTaxiPath(const ClientToServer_QueryTaxiPath& from);
  ClientToServer_QueryTaxiPath(ClientToServer_QueryTaxiPath&& from) noexcept
    : ClientToServer_QueryTaxiPath() {
    *this = ::std::move(from);
  }

  inline ClientToServer_QueryTaxiPath& operator=(const ClientToServer_QueryTaxiPath& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToServer_QueryTaxiPath& operator=(ClientToServer_QueryTaxiPath&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClientToServer_QueryTaxiPath& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServer_QueryTaxiPath* internal_default_instance() {
    return reinterpret_cast<const ClientToServer_QueryTaxiPath*>(
               &_ClientToServer_QueryTaxiPath_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ClientToServer_QueryTaxiPath& a, ClientToServer_QueryTaxiPath& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientToServer_QueryTaxiPath* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientToServer_QueryTaxiPath* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientToServer_QueryTaxiPath* New() const final {
    return CreateMaybeMessage<ClientToServer_QueryTaxiPath>(nullptr);
  }

  ClientToServer_QueryTaxiPath* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServer_QueryTaxiPath>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientToServer_QueryTaxiPath& from);
  void MergeFrom(const ClientToServer_QueryTaxiPath& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToServer_QueryTaxiPath* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "atc_proto.ClientToServer.QueryTaxiPath";
  }
  protected:
  explicit ClientToServer_QueryTaxiPath(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_atc_2eproto);
    return ::descriptor_table_atc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAirportIcaoFieldNumber = 1,
    kAircraftModelIcaoFieldNumber = 2,
    kFromPointFieldNumber = 3,
    kToPointFieldNumber = 4,
  };
  // string airport_icao = 1;
  void clear_airport_icao();
  const std::string& airport_icao() const;
  void set_airport_icao(const std::string& value);
  void set_airport_icao(std::string&& value);
  void set_airport_icao(const char* value);
  void set_airport_icao(const char* value, size_t size);
  std::string* mutable_airport_icao();
  std::string* release_airport_icao();
  void set_allocated_airport_icao(std::string* airport_icao);
  private:
  const std::string& _internal_airport_icao() const;
  void _internal_set_airport_icao(const std::string& value);
  std::string* _internal_mutable_airport_icao();
  public:

  // string aircraft_model_icao = 2;
  void clear_aircraft_model_icao();
  const std::string& aircraft_model_icao() const;
  void set_aircraft_model_icao(const std::string& value);
  void set_aircraft_model_icao(std::string&& value);
  void set_aircraft_model_icao(const char* value);
  void set_aircraft_model_icao(const char* value, size_t size);
  std::string* mutable_aircraft_model_icao();
  std::string* release_aircraft_model_icao();
  void set_allocated_aircraft_model_icao(std::string* aircraft_model_icao);
  private:
  const std::string& _internal_aircraft_model_icao() const;
  void _internal_set_aircraft_model_icao(const std::string& value);
  std::string* _internal_mutable_aircraft_model_icao();
  public:

  // .atc_proto.GeoPoint from_point = 3;
  bool has_from_point() const;
  private:
  bool _internal_has_from_point() const;
  public:
  void clear_from_point();
  const ::atc_proto::GeoPoint& from_point() const;
  ::atc_proto::GeoPoint* release_from_point();
  ::atc_proto::GeoPoint* mutable_from_point();
  void set_allocated_from_point(::atc_proto::GeoPoint* from_point);
  private:
  const ::atc_proto::GeoPoint& _internal_from_point() const;
  ::atc_proto::GeoPoint* _internal_mutable_from_point();
  public:
  void unsafe_arena_set_allocated_from_point(
      ::atc_proto::GeoPoint* from_point);
  ::atc_proto::GeoPoint* unsafe_arena_release_from_point();

  // .atc_proto.GeoPoint to_point = 4;
  bool has_to_point() const;
  private:
  bool _internal_has_to_point() const;
  public:
  void clear_to_point();
  const ::atc_proto::GeoPoint& to_point() const;
  ::atc_proto::GeoPoint* release_to_point();
  ::atc_proto::GeoPoint* mutable_to_point();
  void set_allocated_to_point(::atc_proto::GeoPoint* to_point);
  private:
  const ::atc_proto::GeoPoint& _internal_to_point() const;
  ::atc_proto::GeoPoint* _internal_mutable_to_point();
  public:
  void unsafe_arena_set_allocated_to_point(
      ::atc_proto::GeoPoint* to_point);
  ::atc_proto::GeoPoint* unsafe_arena_release_to_point();

  // @@protoc_insertion_point(class_scope:atc_proto.ClientToServer.QueryTaxiPath)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr airport_icao_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr aircraft_model_icao_;
  ::atc_proto::GeoPoint* from_point_;
  ::atc_proto::GeoPoint* to_point_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_atc_2eproto;
};
// -------------------------------------------------------------------

class ClientToServer_CreateAircraft PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:atc_proto.ClientToServer.CreateAircraft) */ {
 public:
  inline ClientToServer_CreateAircraft() : ClientToServer_CreateAircraft(nullptr) {}
  virtual ~ClientToServer_CreateAircraft();

  ClientToServer_CreateAircraft(const ClientToServer_CreateAircraft& from);
  ClientToServer_CreateAircraft(ClientToServer_CreateAircraft&& from) noexcept
    : ClientToServer_CreateAircraft() {
    *this = ::std::move(from);
  }

  inline ClientToServer_CreateAircraft& operator=(const ClientToServer_CreateAircraft& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToServer_CreateAircraft& operator=(ClientToServer_CreateAircraft&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClientToServer_CreateAircraft& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServer_CreateAircraft* internal_default_instance() {
    return reinterpret_cast<const ClientToServer_CreateAircraft*>(
               &_ClientToServer_CreateAircraft_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ClientToServer_CreateAircraft& a, ClientToServer_CreateAircraft& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientToServer_CreateAircraft* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientToServer_CreateAircraft* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientToServer_CreateAircraft* New() const final {
    return CreateMaybeMessage<ClientToServer_CreateAircraft>(nullptr);
  }

  ClientToServer_CreateAircraft* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServer_CreateAircraft>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientToServer_CreateAircraft& from);
  void MergeFrom(const ClientToServer_CreateAircraft& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToServer_CreateAircraft* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "atc_proto.ClientToServer.CreateAircraft";
  }
  protected:
  explicit ClientToServer_CreateAircraft(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_atc_2eproto);
    return ::descriptor_table_atc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAircraftFieldNumber = 1,
  };
  // .atc_proto.AircraftMessage aircraft = 1;
  bool has_aircraft() const;
  private:
  bool _internal_has_aircraft() const;
  public:
  void clear_aircraft();
  const ::atc_proto::AircraftMessage& aircraft() const;
  ::atc_proto::AircraftMessage* release_aircraft();
  ::atc_proto::AircraftMessage* mutable_aircraft();
  void set_allocated_aircraft(::atc_proto::AircraftMessage* aircraft);
  private:
  const ::atc_proto::AircraftMessage& _internal_aircraft() const;
  ::atc_proto::AircraftMessage* _internal_mutable_aircraft();
  public:
  void unsafe_arena_set_allocated_aircraft(
      ::atc_proto::AircraftMessage* aircraft);
  ::atc_proto::AircraftMessage* unsafe_arena_release_aircraft();

  // @@protoc_insertion_point(class_scope:atc_proto.ClientToServer.CreateAircraft)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::atc_proto::AircraftMessage* aircraft_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_atc_2eproto;
};
// -------------------------------------------------------------------

class ClientToServer_UpdateAircraftSituation PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:atc_proto.ClientToServer.UpdateAircraftSituation) */ {
 public:
  inline ClientToServer_UpdateAircraftSituation() : ClientToServer_UpdateAircraftSituation(nullptr) {}
  virtual ~ClientToServer_UpdateAircraftSituation();

  ClientToServer_UpdateAircraftSituation(const ClientToServer_UpdateAircraftSituation& from);
  ClientToServer_UpdateAircraftSituation(ClientToServer_UpdateAircraftSituation&& from) noexcept
    : ClientToServer_UpdateAircraftSituation() {
    *this = ::std::move(from);
  }

  inline ClientToServer_UpdateAircraftSituation& operator=(const ClientToServer_UpdateAircraftSituation& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToServer_UpdateAircraftSituation& operator=(ClientToServer_UpdateAircraftSituation&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClientToServer_UpdateAircraftSituation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServer_UpdateAircraftSituation* internal_default_instance() {
    return reinterpret_cast<const ClientToServer_UpdateAircraftSituation*>(
               &_ClientToServer_UpdateAircraftSituation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ClientToServer_UpdateAircraftSituation& a, ClientToServer_UpdateAircraftSituation& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientToServer_UpdateAircraftSituation* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientToServer_UpdateAircraftSituation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientToServer_UpdateAircraftSituation* New() const final {
    return CreateMaybeMessage<ClientToServer_UpdateAircraftSituation>(nullptr);
  }

  ClientToServer_UpdateAircraftSituation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServer_UpdateAircraftSituation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientToServer_UpdateAircraftSituation& from);
  void MergeFrom(const ClientToServer_UpdateAircraftSituation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToServer_UpdateAircraftSituation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "atc_proto.ClientToServer.UpdateAircraftSituation";
  }
  protected:
  explicit ClientToServer_UpdateAircraftSituation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_atc_2eproto);
    return ::descriptor_table_atc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSituationFieldNumber = 2,
    kAircraftIdFieldNumber = 1,
  };
  // .atc_proto.AircraftMessage.Situation situation = 2;
  bool has_situation() const;
  private:
  bool _internal_has_situation() const;
  public:
  void clear_situation();
  const ::atc_proto::AircraftMessage_Situation& situation() const;
  ::atc_proto::AircraftMessage_Situation* release_situation();
  ::atc_proto::AircraftMessage_Situation* mutable_situation();
  void set_allocated_situation(::atc_proto::AircraftMessage_Situation* situation);
  private:
  const ::atc_proto::AircraftMessage_Situation& _internal_situation() const;
  ::atc_proto::AircraftMessage_Situation* _internal_mutable_situation();
  public:
  void unsafe_arena_set_allocated_situation(
      ::atc_proto::AircraftMessage_Situation* situation);
  ::atc_proto::AircraftMessage_Situation* unsafe_arena_release_situation();

  // uint32 aircraft_id = 1;
  void clear_aircraft_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 aircraft_id() const;
  void set_aircraft_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_aircraft_id() const;
  void _internal_set_aircraft_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:atc_proto.ClientToServer.UpdateAircraftSituation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::atc_proto::AircraftMessage_Situation* situation_;
  ::PROTOBUF_NAMESPACE_ID::uint32 aircraft_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_atc_2eproto;
};
// -------------------------------------------------------------------

class ClientToServer_RemoveAircraft PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:atc_proto.ClientToServer.RemoveAircraft) */ {
 public:
  inline ClientToServer_RemoveAircraft() : ClientToServer_RemoveAircraft(nullptr) {}
  virtual ~ClientToServer_RemoveAircraft();

  ClientToServer_RemoveAircraft(const ClientToServer_RemoveAircraft& from);
  ClientToServer_RemoveAircraft(ClientToServer_RemoveAircraft&& from) noexcept
    : ClientToServer_RemoveAircraft() {
    *this = ::std::move(from);
  }

  inline ClientToServer_RemoveAircraft& operator=(const ClientToServer_RemoveAircraft& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToServer_RemoveAircraft& operator=(ClientToServer_RemoveAircraft&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClientToServer_RemoveAircraft& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServer_RemoveAircraft* internal_default_instance() {
    return reinterpret_cast<const ClientToServer_RemoveAircraft*>(
               &_ClientToServer_RemoveAircraft_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ClientToServer_RemoveAircraft& a, ClientToServer_RemoveAircraft& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientToServer_RemoveAircraft* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientToServer_RemoveAircraft* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientToServer_RemoveAircraft* New() const final {
    return CreateMaybeMessage<ClientToServer_RemoveAircraft>(nullptr);
  }

  ClientToServer_RemoveAircraft* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServer_RemoveAircraft>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientToServer_RemoveAircraft& from);
  void MergeFrom(const ClientToServer_RemoveAircraft& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToServer_RemoveAircraft* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "atc_proto.ClientToServer.RemoveAircraft";
  }
  protected:
  explicit ClientToServer_RemoveAircraft(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_atc_2eproto);
    return ::descriptor_table_atc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAircraftIdFieldNumber = 1,
  };
  // uint32 aircraft_id = 1;
  void clear_aircraft_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 aircraft_id() const;
  void set_aircraft_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_aircraft_id() const;
  void _internal_set_aircraft_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:atc_proto.ClientToServer.RemoveAircraft)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 aircraft_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_atc_2eproto;
};
// -------------------------------------------------------------------

class ClientToServer_UserAcquireAircraft PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:atc_proto.ClientToServer.UserAcquireAircraft) */ {
 public:
  inline ClientToServer_UserAcquireAircraft() : ClientToServer_UserAcquireAircraft(nullptr) {}
  virtual ~ClientToServer_UserAcquireAircraft();

  ClientToServer_UserAcquireAircraft(const ClientToServer_UserAcquireAircraft& from);
  ClientToServer_UserAcquireAircraft(ClientToServer_UserAcquireAircraft&& from) noexcept
    : ClientToServer_UserAcquireAircraft() {
    *this = ::std::move(from);
  }

  inline ClientToServer_UserAcquireAircraft& operator=(const ClientToServer_UserAcquireAircraft& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToServer_UserAcquireAircraft& operator=(ClientToServer_UserAcquireAircraft&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClientToServer_UserAcquireAircraft& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServer_UserAcquireAircraft* internal_default_instance() {
    return reinterpret_cast<const ClientToServer_UserAcquireAircraft*>(
               &_ClientToServer_UserAcquireAircraft_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ClientToServer_UserAcquireAircraft& a, ClientToServer_UserAcquireAircraft& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientToServer_UserAcquireAircraft* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientToServer_UserAcquireAircraft* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientToServer_UserAcquireAircraft* New() const final {
    return CreateMaybeMessage<ClientToServer_UserAcquireAircraft>(nullptr);
  }

  ClientToServer_UserAcquireAircraft* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServer_UserAcquireAircraft>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientToServer_UserAcquireAircraft& from);
  void MergeFrom(const ClientToServer_UserAcquireAircraft& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToServer_UserAcquireAircraft* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "atc_proto.ClientToServer.UserAcquireAircraft";
  }
  protected:
  explicit ClientToServer_UserAcquireAircraft(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_atc_2eproto);
    return ::descriptor_table_atc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAircraftIdFieldNumber = 1,
  };
  // uint32 aircraft_id = 1;
  void clear_aircraft_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 aircraft_id() const;
  void set_aircraft_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_aircraft_id() const;
  void _internal_set_aircraft_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:atc_proto.ClientToServer.UserAcquireAircraft)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 aircraft_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_atc_2eproto;
};
// -------------------------------------------------------------------

class ClientToServer_UserUpdateAircraftSituation PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:atc_proto.ClientToServer.UserUpdateAircraftSituation) */ {
 public:
  inline ClientToServer_UserUpdateAircraftSituation() : ClientToServer_UserUpdateAircraftSituation(nullptr) {}
  virtual ~ClientToServer_UserUpdateAircraftSituation();

  ClientToServer_UserUpdateAircraftSituation(const ClientToServer_UserUpdateAircraftSituation& from);
  ClientToServer_UserUpdateAircraftSituation(ClientToServer_UserUpdateAircraftSituation&& from) noexcept
    : ClientToServer_UserUpdateAircraftSituation() {
    *this = ::std::move(from);
  }

  inline ClientToServer_UserUpdateAircraftSituation& operator=(const ClientToServer_UserUpdateAircraftSituation& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToServer_UserUpdateAircraftSituation& operator=(ClientToServer_UserUpdateAircraftSituation&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClientToServer_UserUpdateAircraftSituation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServer_UserUpdateAircraftSituation* internal_default_instance() {
    return reinterpret_cast<const ClientToServer_UserUpdateAircraftSituation*>(
               &_ClientToServer_UserUpdateAircraftSituation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ClientToServer_UserUpdateAircraftSituation& a, ClientToServer_UserUpdateAircraftSituation& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientToServer_UserUpdateAircraftSituation* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientToServer_UserUpdateAircraftSituation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientToServer_UserUpdateAircraftSituation* New() const final {
    return CreateMaybeMessage<ClientToServer_UserUpdateAircraftSituation>(nullptr);
  }

  ClientToServer_UserUpdateAircraftSituation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServer_UserUpdateAircraftSituation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientToServer_UserUpdateAircraftSituation& from);
  void MergeFrom(const ClientToServer_UserUpdateAircraftSituation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToServer_UserUpdateAircraftSituation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "atc_proto.ClientToServer.UserUpdateAircraftSituation";
  }
  protected:
  explicit ClientToServer_UserUpdateAircraftSituation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_atc_2eproto);
    return ::descriptor_table_atc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSituationFieldNumber = 2,
    kAircraftIdFieldNumber = 1,
  };
  // .atc_proto.AircraftMessage.Situation situation = 2;
  bool has_situation() const;
  private:
  bool _internal_has_situation() const;
  public:
  void clear_situation();
  const ::atc_proto::AircraftMessage_Situation& situation() const;
  ::atc_proto::AircraftMessage_Situation* release_situation();
  ::atc_proto::AircraftMessage_Situation* mutable_situation();
  void set_allocated_situation(::atc_proto::AircraftMessage_Situation* situation);
  private:
  const ::atc_proto::AircraftMessage_Situation& _internal_situation() const;
  ::atc_proto::AircraftMessage_Situation* _internal_mutable_situation();
  public:
  void unsafe_arena_set_allocated_situation(
      ::atc_proto::AircraftMessage_Situation* situation);
  ::atc_proto::AircraftMessage_Situation* unsafe_arena_release_situation();

  // uint32 aircraft_id = 1;
  void clear_aircraft_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 aircraft_id() const;
  void set_aircraft_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_aircraft_id() const;
  void _internal_set_aircraft_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:atc_proto.ClientToServer.UserUpdateAircraftSituation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::atc_proto::AircraftMessage_Situation* situation_;
  ::PROTOBUF_NAMESPACE_ID::uint32 aircraft_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_atc_2eproto;
};
// -------------------------------------------------------------------

class ClientToServer_UserReleaseAircraft PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:atc_proto.ClientToServer.UserReleaseAircraft) */ {
 public:
  inline ClientToServer_UserReleaseAircraft() : ClientToServer_UserReleaseAircraft(nullptr) {}
  virtual ~ClientToServer_UserReleaseAircraft();

  ClientToServer_UserReleaseAircraft(const ClientToServer_UserReleaseAircraft& from);
  ClientToServer_UserReleaseAircraft(ClientToServer_UserReleaseAircraft&& from) noexcept
    : ClientToServer_UserReleaseAircraft() {
    *this = ::std::move(from);
  }

  inline ClientToServer_UserReleaseAircraft& operator=(const ClientToServer_UserReleaseAircraft& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToServer_UserReleaseAircraft& operator=(ClientToServer_UserReleaseAircraft&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClientToServer_UserReleaseAircraft& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServer_UserReleaseAircraft* internal_default_instance() {
    return reinterpret_cast<const ClientToServer_UserReleaseAircraft*>(
               &_ClientToServer_UserReleaseAircraft_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ClientToServer_UserReleaseAircraft& a, ClientToServer_UserReleaseAircraft& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientToServer_UserReleaseAircraft* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientToServer_UserReleaseAircraft* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientToServer_UserReleaseAircraft* New() const final {
    return CreateMaybeMessage<ClientToServer_UserReleaseAircraft>(nullptr);
  }

  ClientToServer_UserReleaseAircraft* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServer_UserReleaseAircraft>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientToServer_UserReleaseAircraft& from);
  void MergeFrom(const ClientToServer_UserReleaseAircraft& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToServer_UserReleaseAircraft* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "atc_proto.ClientToServer.UserReleaseAircraft";
  }
  protected:
  explicit ClientToServer_UserReleaseAircraft(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_atc_2eproto);
    return ::descriptor_table_atc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAircraftIdFieldNumber = 1,
  };
  // uint32 aircraft_id = 1;
  void clear_aircraft_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 aircraft_id() const;
  void set_aircraft_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_aircraft_id() const;
  void _internal_set_aircraft_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:atc_proto.ClientToServer.UserReleaseAircraft)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 aircraft_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_atc_2eproto;
};
// -------------------------------------------------------------------

class ClientToServer_UserPttPressed PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:atc_proto.ClientToServer.UserPttPressed) */ {
 public:
  inline ClientToServer_UserPttPressed() : ClientToServer_UserPttPressed(nullptr) {}
  virtual ~ClientToServer_UserPttPressed();

  ClientToServer_UserPttPressed(const ClientToServer_UserPttPressed& from);
  ClientToServer_UserPttPressed(ClientToServer_UserPttPressed&& from) noexcept
    : ClientToServer_UserPttPressed() {
    *this = ::std::move(from);
  }

  inline ClientToServer_UserPttPressed& operator=(const ClientToServer_UserPttPressed& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToServer_UserPttPressed& operator=(ClientToServer_UserPttPressed&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClientToServer_UserPttPressed& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServer_UserPttPressed* internal_default_instance() {
    return reinterpret_cast<const ClientToServer_UserPttPressed*>(
               &_ClientToServer_UserPttPressed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ClientToServer_UserPttPressed& a, ClientToServer_UserPttPressed& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientToServer_UserPttPressed* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientToServer_UserPttPressed* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientToServer_UserPttPressed* New() const final {
    return CreateMaybeMessage<ClientToServer_UserPttPressed>(nullptr);
  }

  ClientToServer_UserPttPressed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServer_UserPttPressed>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientToServer_UserPttPressed& from);
  void MergeFrom(const ClientToServer_UserPttPressed& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToServer_UserPttPressed* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "atc_proto.ClientToServer.UserPttPressed";
  }
  protected:
  explicit ClientToServer_UserPttPressed(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_atc_2eproto);
    return ::descriptor_table_atc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrequencyKhzFieldNumber = 1,
  };
  // uint32 frequency_khz = 1;
  void clear_frequency_khz();
  ::PROTOBUF_NAMESPACE_ID::uint32 frequency_khz() const;
  void set_frequency_khz(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_frequency_khz() const;
  void _internal_set_frequency_khz(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:atc_proto.ClientToServer.UserPttPressed)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 frequency_khz_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_atc_2eproto;
};
// -------------------------------------------------------------------

class ClientToServer_UserPttReleased PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:atc_proto.ClientToServer.UserPttReleased) */ {
 public:
  inline ClientToServer_UserPttReleased() : ClientToServer_UserPttReleased(nullptr) {}
  virtual ~ClientToServer_UserPttReleased();

  ClientToServer_UserPttReleased(const ClientToServer_UserPttReleased& from);
  ClientToServer_UserPttReleased(ClientToServer_UserPttReleased&& from) noexcept
    : ClientToServer_UserPttReleased() {
    *this = ::std::move(from);
  }

  inline ClientToServer_UserPttReleased& operator=(const ClientToServer_UserPttReleased& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToServer_UserPttReleased& operator=(ClientToServer_UserPttReleased&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClientToServer_UserPttReleased& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServer_UserPttReleased* internal_default_instance() {
    return reinterpret_cast<const ClientToServer_UserPttReleased*>(
               &_ClientToServer_UserPttReleased_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ClientToServer_UserPttReleased& a, ClientToServer_UserPttReleased& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientToServer_UserPttReleased* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientToServer_UserPttReleased* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientToServer_UserPttReleased* New() const final {
    return CreateMaybeMessage<ClientToServer_UserPttReleased>(nullptr);
  }

  ClientToServer_UserPttReleased* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServer_UserPttReleased>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientToServer_UserPttReleased& from);
  void MergeFrom(const ClientToServer_UserPttReleased& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToServer_UserPttReleased* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "atc_proto.ClientToServer.UserPttReleased";
  }
  protected:
  explicit ClientToServer_UserPttReleased(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_atc_2eproto);
    return ::descriptor_table_atc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrequencyKhzFieldNumber = 1,
  };
  // uint32 frequency_khz = 1;
  void clear_frequency_khz();
  ::PROTOBUF_NAMESPACE_ID::uint32 frequency_khz() const;
  void set_frequency_khz(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_frequency_khz() const;
  void _internal_set_frequency_khz(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:atc_proto.ClientToServer.UserPttReleased)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 frequency_khz_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_atc_2eproto;
};
// -------------------------------------------------------------------

class ClientToServer_QueryTraffic PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:atc_proto.ClientToServer.QueryTraffic) */ {
 public:
  inline ClientToServer_QueryTraffic() : ClientToServer_QueryTraffic(nullptr) {}
  virtual ~ClientToServer_QueryTraffic();

  ClientToServer_QueryTraffic(const ClientToServer_QueryTraffic& from);
  ClientToServer_QueryTraffic(ClientToServer_QueryTraffic&& from) noexcept
    : ClientToServer_QueryTraffic() {
    *this = ::std::move(from);
  }

  inline ClientToServer_QueryTraffic& operator=(const ClientToServer_QueryTraffic& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToServer_QueryTraffic& operator=(ClientToServer_QueryTraffic&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClientToServer_QueryTraffic& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServer_QueryTraffic* internal_default_instance() {
    return reinterpret_cast<const ClientToServer_QueryTraffic*>(
               &_ClientToServer_QueryTraffic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ClientToServer_QueryTraffic& a, ClientToServer_QueryTraffic& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientToServer_QueryTraffic* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientToServer_QueryTraffic* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientToServer_QueryTraffic* New() const final {
    return CreateMaybeMessage<ClientToServer_QueryTraffic>(nullptr);
  }

  ClientToServer_QueryTraffic* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServer_QueryTraffic>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientToServer_QueryTraffic& from);
  void MergeFrom(const ClientToServer_QueryTraffic& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToServer_QueryTraffic* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "atc_proto.ClientToServer.QueryTraffic";
  }
  protected:
  explicit ClientToServer_QueryTraffic(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_atc_2eproto);
    return ::descriptor_table_atc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCancellationKeyFieldNumber = 5,
    kMinLatFieldNumber = 1,
    kMinLonFieldNumber = 2,
    kMaxLatFieldNumber = 3,
    kMaxLonFieldNumber = 4,
  };
  // string cancellation_key = 5;
  void clear_cancellation_key();
  const std::string& cancellation_key() const;
  void set_cancellation_key(const std::string& value);
  void set_cancellation_key(std::string&& value);
  void set_cancellation_key(const char* value);
  void set_cancellation_key(const char* value, size_t size);
  std::string* mutable_cancellation_key();
  std::string* release_cancellation_key();
  void set_allocated_cancellation_key(std::string* cancellation_key);
  private:
  const std::string& _internal_cancellation_key() const;
  void _internal_set_cancellation_key(const std::string& value);
  std::string* _internal_mutable_cancellation_key();
  public:

  // double min_lat = 1;
  void clear_min_lat();
  double min_lat() const;
  void set_min_lat(double value);
  private:
  double _internal_min_lat() const;
  void _internal_set_min_lat(double value);
  public:

  // double min_lon = 2;
  void clear_min_lon();
  double min_lon() const;
  void set_min_lon(double value);
  private:
  double _internal_min_lon() const;
  void _internal_set_min_lon(double value);
  public:

  // double max_lat = 3;
  void clear_max_lat();
  double max_lat() const;
  void set_max_lat(double value);
  private:
  double _internal_max_lat() const;
  void _internal_set_max_lat(double value);
  public:

  // double max_lon = 4;
  void clear_max_lon();
  double max_lon() const;
  void set_max_lon(double value);
  private:
  double _internal_max_lon() const;
  void _internal_set_max_lon(double value);
  public:

  // @@protoc_insertion_point(class_scope:atc_proto.ClientToServer.QueryTraffic)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cancellation_key_;
  double min_lat_;
  double min_lon_;
  double max_lat_;
  double max_lon_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_atc_2eproto;
};
// -------------------------------------------------------------------

class ClientToServer_CancelTrafficQuery PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:atc_proto.ClientToServer.CancelTrafficQuery) */ {
 public:
  inline ClientToServer_CancelTrafficQuery() : ClientToServer_CancelTrafficQuery(nullptr) {}
  virtual ~ClientToServer_CancelTrafficQuery();

  ClientToServer_CancelTrafficQuery(const ClientToServer_CancelTrafficQuery& from);
  ClientToServer_CancelTrafficQuery(ClientToServer_CancelTrafficQuery&& from) noexcept
    : ClientToServer_CancelTrafficQuery() {
    *this = ::std::move(from);
  }

  inline ClientToServer_CancelTrafficQuery& operator=(const ClientToServer_CancelTrafficQuery& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToServer_CancelTrafficQuery& operator=(ClientToServer_CancelTrafficQuery&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClientToServer_CancelTrafficQuery& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServer_CancelTrafficQuery* internal_default_instance() {
    return reinterpret_cast<const ClientToServer_CancelTrafficQuery*>(
               &_ClientToServer_CancelTrafficQuery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ClientToServer_CancelTrafficQuery& a, ClientToServer_CancelTrafficQuery& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientToServer_CancelTrafficQuery* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientToServer_CancelTrafficQuery* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientToServer_CancelTrafficQuery* New() const final {
    return CreateMaybeMessage<ClientToServer_CancelTrafficQuery>(nullptr);
  }

  ClientToServer_CancelTrafficQuery* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServer_CancelTrafficQuery>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientToServer_CancelTrafficQuery& from);
  void MergeFrom(const ClientToServer_CancelTrafficQuery& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToServer_CancelTrafficQuery* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "atc_proto.ClientToServer.CancelTrafficQuery";
  }
  protected:
  explicit ClientToServer_CancelTrafficQuery(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_atc_2eproto);
    return ::descriptor_table_atc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCancellationKeyFieldNumber = 1,
  };
  // string cancellation_key = 1;
  void clear_cancellation_key();
  const std::string& cancellation_key() const;
  void set_cancellation_key(const std::string& value);
  void set_cancellation_key(std::string&& value);
  void set_cancellation_key(const char* value);
  void set_cancellation_key(const char* value, size_t size);
  std::string* mutable_cancellation_key();
  std::string* release_cancellation_key();
  void set_allocated_cancellation_key(std::string* cancellation_key);
  private:
  const std::string& _internal_cancellation_key() const;
  void _internal_set_cancellation_key(const std::string& value);
  std::string* _internal_mutable_cancellation_key();
  public:

  // @@protoc_insertion_point(class_scope:atc_proto.ClientToServer.CancelTrafficQuery)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cancellation_key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_atc_2eproto;
};
// -------------------------------------------------------------------

class ClientToServer PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:atc_proto.ClientToServer) */ {
 public:
  inline ClientToServer() : ClientToServer(nullptr) {}
  virtual ~ClientToServer();

  ClientToServer(const ClientToServer& from);
  ClientToServer(ClientToServer&& from) noexcept
    : ClientToServer() {
    *this = ::std::move(from);
  }

  inline ClientToServer& operator=(const ClientToServer& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToServer& operator=(ClientToServer&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClientToServer& default_instance();

  enum PayloadCase {
    kConnect = 101,
    kQueryAirport = 102,
    kCreateAircraft = 103,
    kUpdateAircraftSituation = 104,
    kRemoveAircraft = 105,
    kQueryTaxiPath = 106,
    kQueryTraffic = 107,
    kCancelTrafficQuery = 108,
    kUserAcquireAircraft = 109,
    kUserUpdateAircraftSituation = 110,
    kUserReleaseAircraft = 111,
    kUserPttPressed = 112,
    kUserPttReleased = 113,
    PAYLOAD_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServer* internal_default_instance() {
    return reinterpret_cast<const ClientToServer*>(
               &_ClientToServer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ClientToServer& a, ClientToServer& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientToServer* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientToServer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientToServer* New() const final {
    return CreateMaybeMessage<ClientToServer>(nullptr);
  }

  ClientToServer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServer>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientToServer& from);
  void MergeFrom(const ClientToServer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToServer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "atc_proto.ClientToServer";
  }
  protected:
  explicit ClientToServer(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_atc_2eproto);
    return ::descriptor_table_atc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ClientToServer_Connect Connect;
  typedef ClientToServer_QueryAirport QueryAirport;
  typedef ClientToServer_QueryTaxiPath QueryTaxiPath;
  typedef ClientToServer_CreateAircraft CreateAircraft;
  typedef ClientToServer_UpdateAircraftSituation UpdateAircraftSituation;
  typedef ClientToServer_RemoveAircraft RemoveAircraft;
  typedef ClientToServer_UserAcquireAircraft UserAcquireAircraft;
  typedef ClientToServer_UserUpdateAircraftSituation UserUpdateAircraftSituation;
  typedef ClientToServer_UserReleaseAircraft UserReleaseAircraft;
  typedef ClientToServer_UserPttPressed UserPttPressed;
  typedef ClientToServer_UserPttReleased UserPttReleased;
  typedef ClientToServer_QueryTraffic QueryTraffic;
  typedef ClientToServer_CancelTrafficQuery CancelTrafficQuery;

  // accessors -------------------------------------------------------

  enum : int {
    kSentAtFieldNumber = 2,
    kIdFieldNumber = 1,
    kConnectFieldNumber = 101,
    kQueryAirportFieldNumber = 102,
    kCreateAircraftFieldNumber = 103,
    kUpdateAircraftSituationFieldNumber = 104,
    kRemoveAircraftFieldNumber = 105,
    kQueryTaxiPathFieldNumber = 106,
    kQueryTrafficFieldNumber = 107,
    kCancelTrafficQueryFieldNumber = 108,
    kUserAcquireAircraftFieldNumber = 109,
    kUserUpdateAircraftSituationFieldNumber = 110,
    kUserReleaseAircraftFieldNumber = 111,
    kUserPttPressedFieldNumber = 112,
    kUserPttReleasedFieldNumber = 113,
  };
  // .google.protobuf.Timestamp sent_at = 2;
  bool has_sent_at() const;
  private:
  bool _internal_has_sent_at() const;
  public:
  void clear_sent_at();
  const PROTOBUF_NAMESPACE_ID::Timestamp& sent_at() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_sent_at();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_sent_at();
  void set_allocated_sent_at(PROTOBUF_NAMESPACE_ID::Timestamp* sent_at);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_sent_at() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_sent_at();
  public:
  void unsafe_arena_set_allocated_sent_at(
      PROTOBUF_NAMESPACE_ID::Timestamp* sent_at);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_sent_at();

  // uint64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .atc_proto.ClientToServer.Connect connect = 101;
  bool has_connect() const;
  private:
  bool _internal_has_connect() const;
  public:
  void clear_connect();
  const ::atc_proto::ClientToServer_Connect& connect() const;
  ::atc_proto::ClientToServer_Connect* release_connect();
  ::atc_proto::ClientToServer_Connect* mutable_connect();
  void set_allocated_connect(::atc_proto::ClientToServer_Connect* connect);
  private:
  const ::atc_proto::ClientToServer_Connect& _internal_connect() const;
  ::atc_proto::ClientToServer_Connect* _internal_mutable_connect();
  public:
  void unsafe_arena_set_allocated_connect(
      ::atc_proto::ClientToServer_Connect* connect);
  ::atc_proto::ClientToServer_Connect* unsafe_arena_release_connect();

  // .atc_proto.ClientToServer.QueryAirport query_airport = 102;
  bool has_query_airport() const;
  private:
  bool _internal_has_query_airport() const;
  public:
  void clear_query_airport();
  const ::atc_proto::ClientToServer_QueryAirport& query_airport() const;
  ::atc_proto::ClientToServer_QueryAirport* release_query_airport();
  ::atc_proto::ClientToServer_QueryAirport* mutable_query_airport();
  void set_allocated_query_airport(::atc_proto::ClientToServer_QueryAirport* query_airport);
  private:
  const ::atc_proto::ClientToServer_QueryAirport& _internal_query_airport() const;
  ::atc_proto::ClientToServer_QueryAirport* _internal_mutable_query_airport();
  public:
  void unsafe_arena_set_allocated_query_airport(
      ::atc_proto::ClientToServer_QueryAirport* query_airport);
  ::atc_proto::ClientToServer_QueryAirport* unsafe_arena_release_query_airport();

  // .atc_proto.ClientToServer.CreateAircraft create_aircraft = 103;
  bool has_create_aircraft() const;
  private:
  bool _internal_has_create_aircraft() const;
  public:
  void clear_create_aircraft();
  const ::atc_proto::ClientToServer_CreateAircraft& create_aircraft() const;
  ::atc_proto::ClientToServer_CreateAircraft* release_create_aircraft();
  ::atc_proto::ClientToServer_CreateAircraft* mutable_create_aircraft();
  void set_allocated_create_aircraft(::atc_proto::ClientToServer_CreateAircraft* create_aircraft);
  private:
  const ::atc_proto::ClientToServer_CreateAircraft& _internal_create_aircraft() const;
  ::atc_proto::ClientToServer_CreateAircraft* _internal_mutable_create_aircraft();
  public:
  void unsafe_arena_set_allocated_create_aircraft(
      ::atc_proto::ClientToServer_CreateAircraft* create_aircraft);
  ::atc_proto::ClientToServer_CreateAircraft* unsafe_arena_release_create_aircraft();

  // .atc_proto.ClientToServer.UpdateAircraftSituation update_aircraft_situation = 104;
  bool has_update_aircraft_situation() const;
  private:
  bool _internal_has_update_aircraft_situation() const;
  public:
  void clear_update_aircraft_situation();
  const ::atc_proto::ClientToServer_UpdateAircraftSituation& update_aircraft_situation() const;
  ::atc_proto::ClientToServer_UpdateAircraftSituation* release_update_aircraft_situation();
  ::atc_proto::ClientToServer_UpdateAircraftSituation* mutable_update_aircraft_situation();
  void set_allocated_update_aircraft_situation(::atc_proto::ClientToServer_UpdateAircraftSituation* update_aircraft_situation);
  private:
  const ::atc_proto::ClientToServer_UpdateAircraftSituation& _internal_update_aircraft_situation() const;
  ::atc_proto::ClientToServer_UpdateAircraftSituation* _internal_mutable_update_aircraft_situation();
  public:
  void unsafe_arena_set_allocated_update_aircraft_situation(
      ::atc_proto::ClientToServer_UpdateAircraftSituation* update_aircraft_situation);
  ::atc_proto::ClientToServer_UpdateAircraftSituation* unsafe_arena_release_update_aircraft_situation();

  // .atc_proto.ClientToServer.RemoveAircraft remove_aircraft = 105;
  bool has_remove_aircraft() const;
  private:
  bool _internal_has_remove_aircraft() const;
  public:
  void clear_remove_aircraft();
  const ::atc_proto::ClientToServer_RemoveAircraft& remove_aircraft() const;
  ::atc_proto::ClientToServer_RemoveAircraft* release_remove_aircraft();
  ::atc_proto::ClientToServer_RemoveAircraft* mutable_remove_aircraft();
  void set_allocated_remove_aircraft(::atc_proto::ClientToServer_RemoveAircraft* remove_aircraft);
  private:
  const ::atc_proto::ClientToServer_RemoveAircraft& _internal_remove_aircraft() const;
  ::atc_proto::ClientToServer_RemoveAircraft* _internal_mutable_remove_aircraft();
  public:
  void unsafe_arena_set_allocated_remove_aircraft(
      ::atc_proto::ClientToServer_RemoveAircraft* remove_aircraft);
  ::atc_proto::ClientToServer_RemoveAircraft* unsafe_arena_release_remove_aircraft();

  // .atc_proto.ClientToServer.QueryTaxiPath query_taxi_path = 106;
  bool has_query_taxi_path() const;
  private:
  bool _internal_has_query_taxi_path() const;
  public:
  void clear_query_taxi_path();
  const ::atc_proto::ClientToServer_QueryTaxiPath& query_taxi_path() const;
  ::atc_proto::ClientToServer_QueryTaxiPath* release_query_taxi_path();
  ::atc_proto::ClientToServer_QueryTaxiPath* mutable_query_taxi_path();
  void set_allocated_query_taxi_path(::atc_proto::ClientToServer_QueryTaxiPath* query_taxi_path);
  private:
  const ::atc_proto::ClientToServer_QueryTaxiPath& _internal_query_taxi_path() const;
  ::atc_proto::ClientToServer_QueryTaxiPath* _internal_mutable_query_taxi_path();
  public:
  void unsafe_arena_set_allocated_query_taxi_path(
      ::atc_proto::ClientToServer_QueryTaxiPath* query_taxi_path);
  ::atc_proto::ClientToServer_QueryTaxiPath* unsafe_arena_release_query_taxi_path();

  // .atc_proto.ClientToServer.QueryTraffic query_traffic = 107;
  bool has_query_traffic() const;
  private:
  bool _internal_has_query_traffic() const;
  public:
  void clear_query_traffic();
  const ::atc_proto::ClientToServer_QueryTraffic& query_traffic() const;
  ::atc_proto::ClientToServer_QueryTraffic* release_query_traffic();
  ::atc_proto::ClientToServer_QueryTraffic* mutable_query_traffic();
  void set_allocated_query_traffic(::atc_proto::ClientToServer_QueryTraffic* query_traffic);
  private:
  const ::atc_proto::ClientToServer_QueryTraffic& _internal_query_traffic() const;
  ::atc_proto::ClientToServer_QueryTraffic* _internal_mutable_query_traffic();
  public:
  void unsafe_arena_set_allocated_query_traffic(
      ::atc_proto::ClientToServer_QueryTraffic* query_traffic);
  ::atc_proto::ClientToServer_QueryTraffic* unsafe_arena_release_query_traffic();

  // .atc_proto.ClientToServer.CancelTrafficQuery cancel_traffic_query = 108;
  bool has_cancel_traffic_query() const;
  private:
  bool _internal_has_cancel_traffic_query() const;
  public:
  void clear_cancel_traffic_query();
  const ::atc_proto::ClientToServer_CancelTrafficQuery& cancel_traffic_query() const;
  ::atc_proto::ClientToServer_CancelTrafficQuery* release_cancel_traffic_query();
  ::atc_proto::ClientToServer_CancelTrafficQuery* mutable_cancel_traffic_query();
  void set_allocated_cancel_traffic_query(::atc_proto::ClientToServer_CancelTrafficQuery* cancel_traffic_query);
  private:
  const ::atc_proto::ClientToServer_CancelTrafficQuery& _internal_cancel_traffic_query() const;
  ::atc_proto::ClientToServer_CancelTrafficQuery* _internal_mutable_cancel_traffic_query();
  public:
  void unsafe_arena_set_allocated_cancel_traffic_query(
      ::atc_proto::ClientToServer_CancelTrafficQuery* cancel_traffic_query);
  ::atc_proto::ClientToServer_CancelTrafficQuery* unsafe_arena_release_cancel_traffic_query();

  // .atc_proto.ClientToServer.UserAcquireAircraft user_acquire_aircraft = 109;
  bool has_user_acquire_aircraft() const;
  private:
  bool _internal_has_user_acquire_aircraft() const;
  public:
  void clear_user_acquire_aircraft();
  const ::atc_proto::ClientToServer_UserAcquireAircraft& user_acquire_aircraft() const;
  ::atc_proto::ClientToServer_UserAcquireAircraft* release_user_acquire_aircraft();
  ::atc_proto::ClientToServer_UserAcquireAircraft* mutable_user_acquire_aircraft();
  void set_allocated_user_acquire_aircraft(::atc_proto::ClientToServer_UserAcquireAircraft* user_acquire_aircraft);
  private:
  const ::atc_proto::ClientToServer_UserAcquireAircraft& _internal_user_acquire_aircraft() const;
  ::atc_proto::ClientToServer_UserAcquireAircraft* _internal_mutable_user_acquire_aircraft();
  public:
  void unsafe_arena_set_allocated_user_acquire_aircraft(
      ::atc_proto::ClientToServer_UserAcquireAircraft* user_acquire_aircraft);
  ::atc_proto::ClientToServer_UserAcquireAircraft* unsafe_arena_release_user_acquire_aircraft();

  // .atc_proto.ClientToServer.UserUpdateAircraftSituation user_update_aircraft_situation = 110;
  bool has_user_update_aircraft_situation() const;
  private:
  bool _internal_has_user_update_aircraft_situation() const;
  public:
  void clear_user_update_aircraft_situation();
  const ::atc_proto::ClientToServer_UserUpdateAircraftSituation& user_update_aircraft_situation() const;
  ::atc_proto::ClientToServer_UserUpdateAircraftSituation* release_user_update_aircraft_situation();
  ::atc_proto::ClientToServer_UserUpdateAircraftSituation* mutable_user_update_aircraft_situation();
  void set_allocated_user_update_aircraft_situation(::atc_proto::ClientToServer_UserUpdateAircraftSituation* user_update_aircraft_situation);
  private:
  const ::atc_proto::ClientToServer_UserUpdateAircraftSituation& _internal_user_update_aircraft_situation() const;
  ::atc_proto::ClientToServer_UserUpdateAircraftSituation* _internal_mutable_user_update_aircraft_situation();
  public:
  void unsafe_arena_set_allocated_user_update_aircraft_situation(
      ::atc_proto::ClientToServer_UserUpdateAircraftSituation* user_update_aircraft_situation);
  ::atc_proto::ClientToServer_UserUpdateAircraftSituation* unsafe_arena_release_user_update_aircraft_situation();

  // .atc_proto.ClientToServer.UserReleaseAircraft user_release_aircraft = 111;
  bool has_user_release_aircraft() const;
  private:
  bool _internal_has_user_release_aircraft() const;
  public:
  void clear_user_release_aircraft();
  const ::atc_proto::ClientToServer_UserReleaseAircraft& user_release_aircraft() const;
  ::atc_proto::ClientToServer_UserReleaseAircraft* release_user_release_aircraft();
  ::atc_proto::ClientToServer_UserReleaseAircraft* mutable_user_release_aircraft();
  void set_allocated_user_release_aircraft(::atc_proto::ClientToServer_UserReleaseAircraft* user_release_aircraft);
  private:
  const ::atc_proto::ClientToServer_UserReleaseAircraft& _internal_user_release_aircraft() const;
  ::atc_proto::ClientToServer_UserReleaseAircraft* _internal_mutable_user_release_aircraft();
  public:
  void unsafe_arena_set_allocated_user_release_aircraft(
      ::atc_proto::ClientToServer_UserReleaseAircraft* user_release_aircraft);
  ::atc_proto::ClientToServer_UserReleaseAircraft* unsafe_arena_release_user_release_aircraft();

  // .atc_proto.ClientToServer.UserPttPressed user_ptt_pressed = 112;
  bool has_user_ptt_pressed() const;
  private:
  bool _internal_has_user_ptt_pressed() const;
  public:
  void clear_user_ptt_pressed();
  const ::atc_proto::ClientToServer_UserPttPressed& user_ptt_pressed() const;
  ::atc_proto::ClientToServer_UserPttPressed* release_user_ptt_pressed();
  ::atc_proto::ClientToServer_UserPttPressed* mutable_user_ptt_pressed();
  void set_allocated_user_ptt_pressed(::atc_proto::ClientToServer_UserPttPressed* user_ptt_pressed);
  private:
  const ::atc_proto::ClientToServer_UserPttPressed& _internal_user_ptt_pressed() const;
  ::atc_proto::ClientToServer_UserPttPressed* _internal_mutable_user_ptt_pressed();
  public:
  void unsafe_arena_set_allocated_user_ptt_pressed(
      ::atc_proto::ClientToServer_UserPttPressed* user_ptt_pressed);
  ::atc_proto::ClientToServer_UserPttPressed* unsafe_arena_release_user_ptt_pressed();

  // .atc_proto.ClientToServer.UserPttReleased user_ptt_released = 113;
  bool has_user_ptt_released() const;
  private:
  bool _internal_has_user_ptt_released() const;
  public:
  void clear_user_ptt_released();
  const ::atc_proto::ClientToServer_UserPttReleased& user_ptt_released() const;
  ::atc_proto::ClientToServer_UserPttReleased* release_user_ptt_released();
  ::atc_proto::ClientToServer_UserPttReleased* mutable_user_ptt_released();
  void set_allocated_user_ptt_released(::atc_proto::ClientToServer_UserPttReleased* user_ptt_released);
  private:
  const ::atc_proto::ClientToServer_UserPttReleased& _internal_user_ptt_released() const;
  ::atc_proto::ClientToServer_UserPttReleased* _internal_mutable_user_ptt_released();
  public:
  void unsafe_arena_set_allocated_user_ptt_released(
      ::atc_proto::ClientToServer_UserPttReleased* user_ptt_released);
  ::atc_proto::ClientToServer_UserPttReleased* unsafe_arena_release_user_ptt_released();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:atc_proto.ClientToServer)
 private:
  class _Internal;
  void set_has_connect();
  void set_has_query_airport();
  void set_has_create_aircraft();
  void set_has_update_aircraft_situation();
  void set_has_remove_aircraft();
  void set_has_query_taxi_path();
  void set_has_query_traffic();
  void set_has_cancel_traffic_query();
  void set_has_user_acquire_aircraft();
  void set_has_user_update_aircraft_situation();
  void set_has_user_release_aircraft();
  void set_has_user_ptt_pressed();
  void set_has_user_ptt_released();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  PROTOBUF_NAMESPACE_ID::Timestamp* sent_at_;
  ::PROTOBUF_NAMESPACE_ID::uint64 id_;
  union PayloadUnion {
    PayloadUnion() {}
    ::atc_proto::ClientToServer_Connect* connect_;
    ::atc_proto::ClientToServer_QueryAirport* query_airport_;
    ::atc_proto::ClientToServer_CreateAircraft* create_aircraft_;
    ::atc_proto::ClientToServer_UpdateAircraftSituation* update_aircraft_situation_;
    ::atc_proto::ClientToServer_RemoveAircraft* remove_aircraft_;
    ::atc_proto::ClientToServer_QueryTaxiPath* query_taxi_path_;
    ::atc_proto::ClientToServer_QueryTraffic* query_traffic_;
    ::atc_proto::ClientToServer_CancelTrafficQuery* cancel_traffic_query_;
    ::atc_proto::ClientToServer_UserAcquireAircraft* user_acquire_aircraft_;
    ::atc_proto::ClientToServer_UserUpdateAircraftSituation* user_update_aircraft_situation_;
    ::atc_proto::ClientToServer_UserReleaseAircraft* user_release_aircraft_;
    ::atc_proto::ClientToServer_UserPttPressed* user_ptt_pressed_;
    ::atc_proto::ClientToServer_UserPttReleased* user_ptt_released_;
  } payload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_atc_2eproto;
};
// -------------------------------------------------------------------

class ServerToClient_FaultDeclined PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:atc_proto.ServerToClient.FaultDeclined) */ {
 public:
  inline ServerToClient_FaultDeclined() : ServerToClient_FaultDeclined(nullptr) {}
  virtual ~ServerToClient_FaultDeclined();

  ServerToClient_FaultDeclined(const ServerToClient_FaultDeclined& from);
  ServerToClient_FaultDeclined(ServerToClient_FaultDeclined&& from) noexcept
    : ServerToClient_FaultDeclined() {
    *this = ::std::move(from);
  }

  inline ServerToClient_FaultDeclined& operator=(const ServerToClient_FaultDeclined& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerToClient_FaultDeclined& operator=(ServerToClient_FaultDeclined&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ServerToClient_FaultDeclined& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerToClient_FaultDeclined* internal_default_instance() {
    return reinterpret_cast<const ServerToClient_FaultDeclined*>(
               &_ServerToClient_FaultDeclined_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ServerToClient_FaultDeclined& a, ServerToClient_FaultDeclined& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerToClient_FaultDeclined* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerToClient_FaultDeclined* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerToClient_FaultDeclined* New() const final {
    return CreateMaybeMessage<ServerToClient_FaultDeclined>(nullptr);
  }

  ServerToClient_FaultDeclined* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerToClient_FaultDeclined>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ServerToClient_FaultDeclined& from);
  void MergeFrom(const ServerToClient_FaultDeclined& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerToClient_FaultDeclined* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "atc_proto.ServerToClient.FaultDeclined";
  }
  protected:
  explicit ServerToClient_FaultDeclined(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_atc_2eproto);
    return ::descriptor_table_atc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:atc_proto.ServerToClient.FaultDeclined)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_atc_2eproto;
};
// -------------------------------------------------------------------

class ServerToClient_FaultNotFound PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:atc_proto.ServerToClient.FaultNotFound) */ {
 public:
  inline ServerToClient_FaultNotFound() : ServerToClient_FaultNotFound(nullptr) {}
  virtual ~ServerToClient_FaultNotFound();

  ServerToClient_FaultNotFound(const ServerToClient_FaultNotFound& from);
  ServerToClient_FaultNotFound(ServerToClient_FaultNotFound&& from) noexcept
    : ServerToClient_FaultNotFound() {
    *this = ::std::move(from);
  }

  inline ServerToClient_FaultNotFound& operator=(const ServerToClient_FaultNotFound& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerToClient_FaultNotFound& operator=(ServerToClient_FaultNotFound&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ServerToClient_FaultNotFound& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerToClient_FaultNotFound* internal_default_instance() {
    return reinterpret_cast<const ServerToClient_FaultNotFound*>(
               &_ServerToClient_FaultNotFound_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ServerToClient_FaultNotFound& a, ServerToClient_FaultNotFound& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerToClient_FaultNotFound* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerToClient_FaultNotFound* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerToClient_FaultNotFound* New() const final {
    return CreateMaybeMessage<ServerToClient_FaultNotFound>(nullptr);
  }

  ServerToClient_FaultNotFound* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerToClient_FaultNotFound>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ServerToClient_FaultNotFound& from);
  void MergeFrom(const ServerToClient_FaultNotFound& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerToClient_FaultNotFound* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "atc_proto.ServerToClient.FaultNotFound";
  }
  protected:
  explicit ServerToClient_FaultNotFound(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_atc_2eproto);
    return ::descriptor_table_atc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:atc_proto.ServerToClient.FaultNotFound)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_atc_2eproto;
};
// -------------------------------------------------------------------

class ServerToClient_ReplyConnect PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:atc_proto.ServerToClient.ReplyConnect) */ {
 public:
  inline ServerToClient_ReplyConnect() : ServerToClient_ReplyConnect(nullptr) {}
  virtual ~ServerToClient_ReplyConnect();

  ServerToClient_ReplyConnect(const ServerToClient_ReplyConnect& from);
  ServerToClient_ReplyConnect(ServerToClient_ReplyConnect&& from) noexcept
    : ServerToClient_ReplyConnect() {
    *this = ::std::move(from);
  }

  inline ServerToClient_ReplyConnect& operator=(const ServerToClient_ReplyConnect& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerToClient_ReplyConnect& operator=(ServerToClient_ReplyConnect&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ServerToClient_ReplyConnect& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerToClient_ReplyConnect* internal_default_instance() {
    return reinterpret_cast<const ServerToClient_ReplyConnect*>(
               &_ServerToClient_ReplyConnect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ServerToClient_ReplyConnect& a, ServerToClient_ReplyConnect& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerToClient_ReplyConnect* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerToClient_ReplyConnect* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerToClient_ReplyConnect* New() const final {
    return CreateMaybeMessage<ServerToClient_ReplyConnect>(nullptr);
  }

  ServerToClient_ReplyConnect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerToClient_ReplyConnect>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ServerToClient_ReplyConnect& from);
  void MergeFrom(const ServerToClient_ReplyConnect& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerToClient_ReplyConnect* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "atc_proto.ServerToClient.ReplyConnect";
  }
  protected:
  explicit ServerToClient_ReplyConnect(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_atc_2eproto);
    return ::descriptor_table_atc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerBannerFieldNumber = 2,
  };
  // string server_banner = 2;
  void clear_server_banner();
  const std::string& server_banner() const;
  void set_server_banner(const std::string& value);
  void set_server_banner(std::string&& value);
  void set_server_banner(const char* value);
  void set_server_banner(const char* value, size_t size);
  std::string* mutable_server_banner();
  std::string* release_server_banner();
  void set_allocated_server_banner(std::string* server_banner);
  private:
  const std::string& _internal_server_banner() const;
  void _internal_set_server_banner(const std::string& value);
  std::string* _internal_mutable_server_banner();
  public:

  // @@protoc_insertion_point(class_scope:atc_proto.ServerToClient.ReplyConnect)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_banner_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_atc_2eproto;
};
// -------------------------------------------------------------------

class ServerToClient_ReplyCreateAircraft PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:atc_proto.ServerToClient.ReplyCreateAircraft) */ {
 public:
  inline ServerToClient_ReplyCreateAircraft() : ServerToClient_ReplyCreateAircraft(nullptr) {}
  virtual ~ServerToClient_ReplyCreateAircraft();

  ServerToClient_ReplyCreateAircraft(const ServerToClient_ReplyCreateAircraft& from);
  ServerToClient_ReplyCreateAircraft(ServerToClient_ReplyCreateAircraft&& from) noexcept
    : ServerToClient_ReplyCreateAircraft() {
    *this = ::std::move(from);
  }

  inline ServerToClient_ReplyCreateAircraft& operator=(const ServerToClient_ReplyCreateAircraft& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerToClient_ReplyCreateAircraft& operator=(ServerToClient_ReplyCreateAircraft&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ServerToClient_ReplyCreateAircraft& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerToClient_ReplyCreateAircraft* internal_default_instance() {
    return reinterpret_cast<const ServerToClient_ReplyCreateAircraft*>(
               &_ServerToClient_ReplyCreateAircraft_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ServerToClient_ReplyCreateAircraft& a, ServerToClient_ReplyCreateAircraft& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerToClient_ReplyCreateAircraft* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerToClient_ReplyCreateAircraft* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerToClient_ReplyCreateAircraft* New() const final {
    return CreateMaybeMessage<ServerToClient_ReplyCreateAircraft>(nullptr);
  }

  ServerToClient_ReplyCreateAircraft* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerToClient_ReplyCreateAircraft>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ServerToClient_ReplyCreateAircraft& from);
  void MergeFrom(const ServerToClient_ReplyCreateAircraft& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerToClient_ReplyCreateAircraft* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "atc_proto.ServerToClient.ReplyCreateAircraft";
  }
  protected:
  explicit ServerToClient_ReplyCreateAircraft(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_atc_2eproto);
    return ::descriptor_table_atc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCreatedAircraftIdFieldNumber = 1,
  };
  // uint32 created_aircraft_id = 1;
  void clear_created_aircraft_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 created_aircraft_id() const;
  void set_created_aircraft_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_created_aircraft_id() const;
  void _internal_set_created_aircraft_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:atc_proto.ServerToClient.ReplyCreateAircraft)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 created_aircraft_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_atc_2eproto;
};
// -------------------------------------------------------------------

class ServerToClient_ReplyQueryAirport PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:atc_proto.ServerToClient.ReplyQueryAirport) */ {
 public:
  inline ServerToClient_ReplyQueryAirport() : ServerToClient_ReplyQueryAirport(nullptr) {}
  virtual ~ServerToClient_ReplyQueryAirport();

  ServerToClient_ReplyQueryAirport(const ServerToClient_ReplyQueryAirport& from);
  ServerToClient_ReplyQueryAirport(ServerToClient_ReplyQueryAirport&& from) noexcept
    : ServerToClient_ReplyQueryAirport() {
    *this = ::std::move(from);
  }

  inline ServerToClient_ReplyQueryAirport& operator=(const ServerToClient_ReplyQueryAirport& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerToClient_ReplyQueryAirport& operator=(ServerToClient_ReplyQueryAirport&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ServerToClient_ReplyQueryAirport& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerToClient_ReplyQueryAirport* internal_default_instance() {
    return reinterpret_cast<const ServerToClient_ReplyQueryAirport*>(
               &_ServerToClient_ReplyQueryAirport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ServerToClient_ReplyQueryAirport& a, ServerToClient_ReplyQueryAirport& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerToClient_ReplyQueryAirport* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerToClient_ReplyQueryAirport* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerToClient_ReplyQueryAirport* New() const final {
    return CreateMaybeMessage<ServerToClient_ReplyQueryAirport>(nullptr);
  }

  ServerToClient_ReplyQueryAirport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerToClient_ReplyQueryAirport>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ServerToClient_ReplyQueryAirport& from);
  void MergeFrom(const ServerToClient_ReplyQueryAirport& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerToClient_ReplyQueryAirport* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "atc_proto.ServerToClient.ReplyQueryAirport";
  }
  protected:
  explicit ServerToClient_ReplyQueryAirport(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_atc_2eproto);
    return ::descriptor_table_atc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAirportFieldNumber = 1,
  };
  // .atc_proto.AirportMessage airport = 1;
  bool has_airport() const;
  private:
  bool _internal_has_airport() const;
  public:
  void clear_airport();
  const ::atc_proto::AirportMessage& airport() const;
  ::atc_proto::AirportMessage* release_airport();
  ::atc_proto::AirportMessage* mutable_airport();
  void set_allocated_airport(::atc_proto::AirportMessage* airport);
  private:
  const ::atc_proto::AirportMessage& _internal_airport() const;
  ::atc_proto::AirportMessage* _internal_mutable_airport();
  public:
  void unsafe_arena_set_allocated_airport(
      ::atc_proto::AirportMessage* airport);
  ::atc_proto::AirportMessage* unsafe_arena_release_airport();

  // @@protoc_insertion_point(class_scope:atc_proto.ServerToClient.ReplyQueryAirport)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::atc_proto::AirportMessage* airport_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_atc_2eproto;
};
// -------------------------------------------------------------------

class ServerToClient_ReplyQueryTaxiPath PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:atc_proto.ServerToClient.ReplyQueryTaxiPath) */ {
 public:
  inline ServerToClient_ReplyQueryTaxiPath() : ServerToClient_ReplyQueryTaxiPath(nullptr) {}
  virtual ~ServerToClient_ReplyQueryTaxiPath();

  ServerToClient_ReplyQueryTaxiPath(const ServerToClient_ReplyQueryTaxiPath& from);
  ServerToClient_ReplyQueryTaxiPath(ServerToClient_ReplyQueryTaxiPath&& from) noexcept
    : ServerToClient_ReplyQueryTaxiPath() {
    *this = ::std::move(from);
  }

  inline ServerToClient_ReplyQueryTaxiPath& operator=(const ServerToClient_ReplyQueryTaxiPath& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerToClient_ReplyQueryTaxiPath& operator=(ServerToClient_ReplyQueryTaxiPath&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ServerToClient_ReplyQueryTaxiPath& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerToClient_ReplyQueryTaxiPath* internal_default_instance() {
    return reinterpret_cast<const ServerToClient_ReplyQueryTaxiPath*>(
               &_ServerToClient_ReplyQueryTaxiPath_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ServerToClient_ReplyQueryTaxiPath& a, ServerToClient_ReplyQueryTaxiPath& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerToClient_ReplyQueryTaxiPath* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerToClient_ReplyQueryTaxiPath* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerToClient_ReplyQueryTaxiPath* New() const final {
    return CreateMaybeMessage<ServerToClient_ReplyQueryTaxiPath>(nullptr);
  }

  ServerToClient_ReplyQueryTaxiPath* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerToClient_ReplyQueryTaxiPath>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ServerToClient_ReplyQueryTaxiPath& from);
  void MergeFrom(const ServerToClient_ReplyQueryTaxiPath& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerToClient_ReplyQueryTaxiPath* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "atc_proto.ServerToClient.ReplyQueryTaxiPath";
  }
  protected:
  explicit ServerToClient_ReplyQueryTaxiPath(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_atc_2eproto);
    return ::descriptor_table_atc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaxiPathFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // .atc_proto.TaxiPathMessage taxi_path = 2;
  bool has_taxi_path() const;
  private:
  bool _internal_has_taxi_path() const;
  public:
  void clear_taxi_path();
  const ::atc_proto::TaxiPathMessage& taxi_path() const;
  ::atc_proto::TaxiPathMessage* release_taxi_path();
  ::atc_proto::TaxiPathMessage* mutable_taxi_path();
  void set_allocated_taxi_path(::atc_proto::TaxiPathMessage* taxi_path);
  private:
  const ::atc_proto::TaxiPathMessage& _internal_taxi_path() const;
  ::atc_proto::TaxiPathMessage* _internal_mutable_taxi_path();
  public:
  void unsafe_arena_set_allocated_taxi_path(
      ::atc_proto::TaxiPathMessage* taxi_path);
  ::atc_proto::TaxiPathMessage* unsafe_arena_release_taxi_path();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:atc_proto.ServerToClient.ReplyQueryTaxiPath)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::atc_proto::TaxiPathMessage* taxi_path_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_atc_2eproto;
};
// -------------------------------------------------------------------

class ServerToClient_ReplyQueryTraffic PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:atc_proto.ServerToClient.ReplyQueryTraffic) */ {
 public:
  inline ServerToClient_ReplyQueryTraffic() : ServerToClient_ReplyQueryTraffic(nullptr) {}
  virtual ~ServerToClient_ReplyQueryTraffic();

  ServerToClient_ReplyQueryTraffic(const ServerToClient_ReplyQueryTraffic& from);
  ServerToClient_ReplyQueryTraffic(ServerToClient_ReplyQueryTraffic&& from) noexcept
    : ServerToClient_ReplyQueryTraffic() {
    *this = ::std::move(from);
  }

  inline ServerToClient_ReplyQueryTraffic& operator=(const ServerToClient_ReplyQueryTraffic& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerToClient_ReplyQueryTraffic& operator=(ServerToClient_ReplyQueryTraffic&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ServerToClient_ReplyQueryTraffic& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerToClient_ReplyQueryTraffic* internal_default_instance() {
    return reinterpret_cast<const ServerToClient_ReplyQueryTraffic*>(
               &_ServerToClient_ReplyQueryTraffic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ServerToClient_ReplyQueryTraffic& a, ServerToClient_ReplyQueryTraffic& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerToClient_ReplyQueryTraffic* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerToClient_ReplyQueryTraffic* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerToClient_ReplyQueryTraffic* New() const final {
    return CreateMaybeMessage<ServerToClient_ReplyQueryTraffic>(nullptr);
  }

  ServerToClient_ReplyQueryTraffic* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerToClient_ReplyQueryTraffic>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ServerToClient_ReplyQueryTraffic& from);
  void MergeFrom(const ServerToClient_ReplyQueryTraffic& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerToClient_ReplyQueryTraffic* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "atc_proto.ServerToClient.ReplyQueryTraffic";
  }
  protected:
  explicit ServerToClient_ReplyQueryTraffic(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_atc_2eproto);
    return ::descriptor_table_atc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrafficBatchFieldNumber = 5,
    kMinLatFieldNumber = 1,
    kMinLonFieldNumber = 2,
    kMaxLatFieldNumber = 3,
    kMaxLonFieldNumber = 4,
    kIsLastBatchFieldNumber = 6,
  };
  // repeated .atc_proto.AircraftMessage traffic_batch = 5;
  int traffic_batch_size() const;
  private:
  int _internal_traffic_batch_size() const;
  public:
  void clear_traffic_batch();
  ::atc_proto::AircraftMessage* mutable_traffic_batch(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::atc_proto::AircraftMessage >*
      mutable_traffic_batch();
  private:
  const ::atc_proto::AircraftMessage& _internal_traffic_batch(int index) const;
  ::atc_proto::AircraftMessage* _internal_add_traffic_batch();
  public:
  const ::atc_proto::AircraftMessage& traffic_batch(int index) const;
  ::atc_proto::AircraftMessage* add_traffic_batch();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::atc_proto::AircraftMessage >&
      traffic_batch() const;

  // double min_lat = 1;
  void clear_min_lat();
  double min_lat() const;
  void set_min_lat(double value);
  private:
  double _internal_min_lat() const;
  void _internal_set_min_lat(double value);
  public:

  // double min_lon = 2;
  void clear_min_lon();
  double min_lon() const;
  void set_min_lon(double value);
  private:
  double _internal_min_lon() const;
  void _internal_set_min_lon(double value);
  public:

  // double max_lat = 3;
  void clear_max_lat();
  double max_lat() const;
  void set_max_lat(double value);
  private:
  double _internal_max_lat() const;
  void _internal_set_max_lat(double value);
  public:

  // double max_lon = 4;
  void clear_max_lon();
  double max_lon() const;
  void set_max_lon(double value);
  private:
  double _internal_max_lon() const;
  void _internal_set_max_lon(double value);
  public:

  // bool is_last_batch = 6;
  void clear_is_last_batch();
  bool is_last_batch() const;
  void set_is_last_batch(bool value);
  private:
  bool _internal_is_last_batch() const;
  void _internal_set_is_last_batch(bool value);
  public:

  // @@protoc_insertion_point(class_scope:atc_proto.ServerToClient.ReplyQueryTraffic)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::atc_proto::AircraftMessage > traffic_batch_;
  double min_lat_;
  double min_lon_;
  double max_lat_;
  double max_lon_;
  bool is_last_batch_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_atc_2eproto;
};
// -------------------------------------------------------------------

class ServerToClient_NotifyAircraftCreated PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:atc_proto.ServerToClient.NotifyAircraftCreated) */ {
 public:
  inline ServerToClient_NotifyAircraftCreated() : ServerToClient_NotifyAircraftCreated(nullptr) {}
  virtual ~ServerToClient_NotifyAircraftCreated();

  ServerToClient_NotifyAircraftCreated(const ServerToClient_NotifyAircraftCreated& from);
  ServerToClient_NotifyAircraftCreated(ServerToClient_NotifyAircraftCreated&& from) noexcept
    : ServerToClient_NotifyAircraftCreated() {
    *this = ::std::move(from);
  }

  inline ServerToClient_NotifyAircraftCreated& operator=(const ServerToClient_NotifyAircraftCreated& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerToClient_NotifyAircraftCreated& operator=(ServerToClient_NotifyAircraftCreated&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ServerToClient_NotifyAircraftCreated& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerToClient_NotifyAircraftCreated* internal_default_instance() {
    return reinterpret_cast<const ServerToClient_NotifyAircraftCreated*>(
               &_ServerToClient_NotifyAircraftCreated_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ServerToClient_NotifyAircraftCreated& a, ServerToClient_NotifyAircraftCreated& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerToClient_NotifyAircraftCreated* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerToClient_NotifyAircraftCreated* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerToClient_NotifyAircraftCreated* New() const final {
    return CreateMaybeMessage<ServerToClient_NotifyAircraftCreated>(nullptr);
  }

  ServerToClient_NotifyAircraftCreated* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerToClient_NotifyAircraftCreated>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ServerToClient_NotifyAircraftCreated& from);
  void MergeFrom(const ServerToClient_NotifyAircraftCreated& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerToClient_NotifyAircraftCreated* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "atc_proto.ServerToClient.NotifyAircraftCreated";
  }
  protected:
  explicit ServerToClient_NotifyAircraftCreated(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_atc_2eproto);
    return ::descriptor_table_atc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAircraftFieldNumber = 1,
  };
  // .atc_proto.AircraftMessage aircraft = 1;
  bool has_aircraft() const;
  private:
  bool _internal_has_aircraft() const;
  public:
  void clear_aircraft();
  const ::atc_proto::AircraftMessage& aircraft() const;
  ::atc_proto::AircraftMessage* release_aircraft();
  ::atc_proto::AircraftMessage* mutable_aircraft();
  void set_allocated_aircraft(::atc_proto::AircraftMessage* aircraft);
  private:
  const ::atc_proto::AircraftMessage& _internal_aircraft() const;
  ::atc_proto::AircraftMessage* _internal_mutable_aircraft();
  public:
  void unsafe_arena_set_allocated_aircraft(
      ::atc_proto::AircraftMessage* aircraft);
  ::atc_proto::AircraftMessage* unsafe_arena_release_aircraft();

  // @@protoc_insertion_point(class_scope:atc_proto.ServerToClient.NotifyAircraftCreated)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::atc_proto::AircraftMessage* aircraft_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_atc_2eproto;
};
// -------------------------------------------------------------------

class ServerToClient_NotifyAircraftSituationUpdated PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:atc_proto.ServerToClient.NotifyAircraftSituationUpdated) */ {
 public:
  inline ServerToClient_NotifyAircraftSituationUpdated() : ServerToClient_NotifyAircraftSituationUpdated(nullptr) {}
  virtual ~ServerToClient_NotifyAircraftSituationUpdated();

  ServerToClient_NotifyAircraftSituationUpdated(const ServerToClient_NotifyAircraftSituationUpdated& from);
  ServerToClient_NotifyAircraftSituationUpdated(ServerToClient_NotifyAircraftSituationUpdated&& from) noexcept
    : ServerToClient_NotifyAircraftSituationUpdated() {
    *this = ::std::move(from);
  }

  inline ServerToClient_NotifyAircraftSituationUpdated& operator=(const ServerToClient_NotifyAircraftSituationUpdated& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerToClient_NotifyAircraftSituationUpdated& operator=(ServerToClient_NotifyAircraftSituationUpdated&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ServerToClient_NotifyAircraftSituationUpdated& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerToClient_NotifyAircraftSituationUpdated* internal_default_instance() {
    return reinterpret_cast<const ServerToClient_NotifyAircraftSituationUpdated*>(
               &_ServerToClient_NotifyAircraftSituationUpdated_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ServerToClient_NotifyAircraftSituationUpdated& a, ServerToClient_NotifyAircraftSituationUpdated& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerToClient_NotifyAircraftSituationUpdated* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerToClient_NotifyAircraftSituationUpdated* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerToClient_NotifyAircraftSituationUpdated* New() const final {
    return CreateMaybeMessage<ServerToClient_NotifyAircraftSituationUpdated>(nullptr);
  }

  ServerToClient_NotifyAircraftSituationUpdated* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerToClient_NotifyAircraftSituationUpdated>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ServerToClient_NotifyAircraftSituationUpdated& from);
  void MergeFrom(const ServerToClient_NotifyAircraftSituationUpdated& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerToClient_NotifyAircraftSituationUpdated* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "atc_proto.ServerToClient.NotifyAircraftSituationUpdated";
  }
  protected:
  explicit ServerToClient_NotifyAircraftSituationUpdated(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_atc_2eproto);
    return ::descriptor_table_atc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSituationFieldNumber = 2,
    kAircraftIdFieldNumber = 1,
  };
  // .atc_proto.AircraftMessage.Situation situation = 2;
  bool has_situation() const;
  private:
  bool _internal_has_situation() const;
  public:
  void clear_situation();
  const ::atc_proto::AircraftMessage_Situation& situation() const;
  ::atc_proto::AircraftMessage_Situation* release_situation();
  ::atc_proto::AircraftMessage_Situation* mutable_situation();
  void set_allocated_situation(::atc_proto::AircraftMessage_Situation* situation);
  private:
  const ::atc_proto::AircraftMessage_Situation& _internal_situation() const;
  ::atc_proto::AircraftMessage_Situation* _internal_mutable_situation();
  public:
  void unsafe_arena_set_allocated_situation(
      ::atc_proto::AircraftMessage_Situation* situation);
  ::atc_proto::AircraftMessage_Situation* unsafe_arena_release_situation();

  // uint32 aircraft_id = 1;
  void clear_aircraft_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 aircraft_id() const;
  void set_aircraft_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_aircraft_id() const;
  void _internal_set_aircraft_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:atc_proto.ServerToClient.NotifyAircraftSituationUpdated)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::atc_proto::AircraftMessage_Situation* situation_;
  ::PROTOBUF_NAMESPACE_ID::uint32 aircraft_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_atc_2eproto;
};
// -------------------------------------------------------------------

class ServerToClient_NotifyAircraftRemoved PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:atc_proto.ServerToClient.NotifyAircraftRemoved) */ {
 public:
  inline ServerToClient_NotifyAircraftRemoved() : ServerToClient_NotifyAircraftRemoved(nullptr) {}
  virtual ~ServerToClient_NotifyAircraftRemoved();

  ServerToClient_NotifyAircraftRemoved(const ServerToClient_NotifyAircraftRemoved& from);
  ServerToClient_NotifyAircraftRemoved(ServerToClient_NotifyAircraftRemoved&& from) noexcept
    : ServerToClient_NotifyAircraftRemoved() {
    *this = ::std::move(from);
  }

  inline ServerToClient_NotifyAircraftRemoved& operator=(const ServerToClient_NotifyAircraftRemoved& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerToClient_NotifyAircraftRemoved& operator=(ServerToClient_NotifyAircraftRemoved&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ServerToClient_NotifyAircraftRemoved& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerToClient_NotifyAircraftRemoved* internal_default_instance() {
    return reinterpret_cast<const ServerToClient_NotifyAircraftRemoved*>(
               &_ServerToClient_NotifyAircraftRemoved_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ServerToClient_NotifyAircraftRemoved& a, ServerToClient_NotifyAircraftRemoved& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerToClient_NotifyAircraftRemoved* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerToClient_NotifyAircraftRemoved* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerToClient_NotifyAircraftRemoved* New() const final {
    return CreateMaybeMessage<ServerToClient_NotifyAircraftRemoved>(nullptr);
  }

  ServerToClient_NotifyAircraftRemoved* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerToClient_NotifyAircraftRemoved>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ServerToClient_NotifyAircraftRemoved& from);
  void MergeFrom(const ServerToClient_NotifyAircraftRemoved& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerToClient_NotifyAircraftRemoved* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "atc_proto.ServerToClient.NotifyAircraftRemoved";
  }
  protected:
  explicit ServerToClient_NotifyAircraftRemoved(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_atc_2eproto);
    return ::descriptor_table_atc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAircraftIdFieldNumber = 1,
  };
  // uint32 aircraft_id = 1;
  void clear_aircraft_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 aircraft_id() const;
  void set_aircraft_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_aircraft_id() const;
  void _internal_set_aircraft_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:atc_proto.ServerToClient.NotifyAircraftRemoved)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 aircraft_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_atc_2eproto;
};
// -------------------------------------------------------------------

class ServerToClient_ReplyUserAcquireAircraft PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:atc_proto.ServerToClient.ReplyUserAcquireAircraft) */ {
 public:
  inline ServerToClient_ReplyUserAcquireAircraft() : ServerToClient_ReplyUserAcquireAircraft(nullptr) {}
  virtual ~ServerToClient_ReplyUserAcquireAircraft();

  ServerToClient_ReplyUserAcquireAircraft(const ServerToClient_ReplyUserAcquireAircraft& from);
  ServerToClient_ReplyUserAcquireAircraft(ServerToClient_ReplyUserAcquireAircraft&& from) noexcept
    : ServerToClient_ReplyUserAcquireAircraft() {
    *this = ::std::move(from);
  }

  inline ServerToClient_ReplyUserAcquireAircraft& operator=(const ServerToClient_ReplyUserAcquireAircraft& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerToClient_ReplyUserAcquireAircraft& operator=(ServerToClient_ReplyUserAcquireAircraft&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ServerToClient_ReplyUserAcquireAircraft& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerToClient_ReplyUserAcquireAircraft* internal_default_instance() {
    return reinterpret_cast<const ServerToClient_ReplyUserAcquireAircraft*>(
               &_ServerToClient_ReplyUserAcquireAircraft_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ServerToClient_ReplyUserAcquireAircraft& a, ServerToClient_ReplyUserAcquireAircraft& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerToClient_ReplyUserAcquireAircraft* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerToClient_ReplyUserAcquireAircraft* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerToClient_ReplyUserAcquireAircraft* New() const final {
    return CreateMaybeMessage<ServerToClient_ReplyUserAcquireAircraft>(nullptr);
  }

  ServerToClient_ReplyUserAcquireAircraft* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerToClient_ReplyUserAcquireAircraft>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ServerToClient_ReplyUserAcquireAircraft& from);
  void MergeFrom(const ServerToClient_ReplyUserAcquireAircraft& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerToClient_ReplyUserAcquireAircraft* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "atc_proto.ServerToClient.ReplyUserAcquireAircraft";
  }
  protected:
  explicit ServerToClient_ReplyUserAcquireAircraft(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_atc_2eproto);
    return ::descriptor_table_atc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAircraftIdFieldNumber = 1,
    kSuccessFieldNumber = 2,
  };
  // uint32 aircraft_id = 1;
  void clear_aircraft_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 aircraft_id() const;
  void set_aircraft_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_aircraft_id() const;
  void _internal_set_aircraft_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // bool success = 2;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:atc_proto.ServerToClient.ReplyUserAcquireAircraft)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 aircraft_id_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_atc_2eproto;
};
// -------------------------------------------------------------------

class ServerToClient PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:atc_proto.ServerToClient) */ {
 public:
  inline ServerToClient() : ServerToClient(nullptr) {}
  virtual ~ServerToClient();

  ServerToClient(const ServerToClient& from);
  ServerToClient(ServerToClient&& from) noexcept
    : ServerToClient() {
    *this = ::std::move(from);
  }

  inline ServerToClient& operator=(const ServerToClient& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerToClient& operator=(ServerToClient&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ServerToClient& default_instance();

  enum PayloadCase {
    kReplyConnect = 1101,
    kReplyQueryAirport = 1102,
    kReplyCreateAircraft = 1103,
    kReplyQueryTaxiPath = 1106,
    kReplyQueryTraffic = 1107,
    kNotifyAircraftCreated = 201,
    kNotifyAircraftSituationUpdated = 202,
    kNotifyAircraftRemoved = 203,
    kReplyUserAcquireAircraft = 204,
    kFaultDeclined = 3001,
    kFaultNotFound = 3002,
    PAYLOAD_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerToClient* internal_default_instance() {
    return reinterpret_cast<const ServerToClient*>(
               &_ServerToClient_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(ServerToClient& a, ServerToClient& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerToClient* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerToClient* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerToClient* New() const final {
    return CreateMaybeMessage<ServerToClient>(nullptr);
  }

  ServerToClient* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerToClient>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ServerToClient& from);
  void MergeFrom(const ServerToClient& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerToClient* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "atc_proto.ServerToClient";
  }
  protected:
  explicit ServerToClient(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_atc_2eproto);
    return ::descriptor_table_atc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ServerToClient_FaultDeclined FaultDeclined;
  typedef ServerToClient_FaultNotFound FaultNotFound;
  typedef ServerToClient_ReplyConnect ReplyConnect;
  typedef ServerToClient_ReplyCreateAircraft ReplyCreateAircraft;
  typedef ServerToClient_ReplyQueryAirport ReplyQueryAirport;
  typedef ServerToClient_ReplyQueryTaxiPath ReplyQueryTaxiPath;
  typedef ServerToClient_ReplyQueryTraffic ReplyQueryTraffic;
  typedef ServerToClient_NotifyAircraftCreated NotifyAircraftCreated;
  typedef ServerToClient_NotifyAircraftSituationUpdated NotifyAircraftSituationUpdated;
  typedef ServerToClient_NotifyAircraftRemoved NotifyAircraftRemoved;
  typedef ServerToClient_ReplyUserAcquireAircraft ReplyUserAcquireAircraft;

  // accessors -------------------------------------------------------

  enum : int {
    kSentAtFieldNumber = 4,
    kRequestSentAtFieldNumber = 5,
    kRequestReceivedAtFieldNumber = 6,
    kIdFieldNumber = 2,
    kReplyToRequestIdFieldNumber = 3,
    kReplyConnectFieldNumber = 1101,
    kReplyQueryAirportFieldNumber = 1102,
    kReplyCreateAircraftFieldNumber = 1103,
    kReplyQueryTaxiPathFieldNumber = 1106,
    kReplyQueryTrafficFieldNumber = 1107,
    kNotifyAircraftCreatedFieldNumber = 201,
    kNotifyAircraftSituationUpdatedFieldNumber = 202,
    kNotifyAircraftRemovedFieldNumber = 203,
    kReplyUserAcquireAircraftFieldNumber = 204,
    kFaultDeclinedFieldNumber = 3001,
    kFaultNotFoundFieldNumber = 3002,
  };
  // .google.protobuf.Timestamp sent_at = 4;
  bool has_sent_at() const;
  private:
  bool _internal_has_sent_at() const;
  public:
  void clear_sent_at();
  const PROTOBUF_NAMESPACE_ID::Timestamp& sent_at() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_sent_at();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_sent_at();
  void set_allocated_sent_at(PROTOBUF_NAMESPACE_ID::Timestamp* sent_at);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_sent_at() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_sent_at();
  public:
  void unsafe_arena_set_allocated_sent_at(
      PROTOBUF_NAMESPACE_ID::Timestamp* sent_at);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_sent_at();

  // .google.protobuf.Timestamp request_sent_at = 5;
  bool has_request_sent_at() const;
  private:
  bool _internal_has_request_sent_at() const;
  public:
  void clear_request_sent_at();
  const PROTOBUF_NAMESPACE_ID::Timestamp& request_sent_at() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_request_sent_at();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_request_sent_at();
  void set_allocated_request_sent_at(PROTOBUF_NAMESPACE_ID::Timestamp* request_sent_at);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_request_sent_at() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_request_sent_at();
  public:
  void unsafe_arena_set_allocated_request_sent_at(
      PROTOBUF_NAMESPACE_ID::Timestamp* request_sent_at);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_request_sent_at();

  // .google.protobuf.Timestamp request_received_at = 6;
  bool has_request_received_at() const;
  private:
  bool _internal_has_request_received_at() const;
  public:
  void clear_request_received_at();
  const PROTOBUF_NAMESPACE_ID::Timestamp& request_received_at() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_request_received_at();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_request_received_at();
  void set_allocated_request_received_at(PROTOBUF_NAMESPACE_ID::Timestamp* request_received_at);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_request_received_at() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_request_received_at();
  public:
  void unsafe_arena_set_allocated_request_received_at(
      PROTOBUF_NAMESPACE_ID::Timestamp* request_received_at);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_request_received_at();

  // uint64 id = 2;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 reply_to_request_id = 3;
  void clear_reply_to_request_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 reply_to_request_id() const;
  void set_reply_to_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_reply_to_request_id() const;
  void _internal_set_reply_to_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .atc_proto.ServerToClient.ReplyConnect reply_connect = 1101;
  bool has_reply_connect() const;
  private:
  bool _internal_has_reply_connect() const;
  public:
  void clear_reply_connect();
  const ::atc_proto::ServerToClient_ReplyConnect& reply_connect() const;
  ::atc_proto::ServerToClient_ReplyConnect* release_reply_connect();
  ::atc_proto::ServerToClient_ReplyConnect* mutable_reply_connect();
  void set_allocated_reply_connect(::atc_proto::ServerToClient_ReplyConnect* reply_connect);
  private:
  const ::atc_proto::ServerToClient_ReplyConnect& _internal_reply_connect() const;
  ::atc_proto::ServerToClient_ReplyConnect* _internal_mutable_reply_connect();
  public:
  void unsafe_arena_set_allocated_reply_connect(
      ::atc_proto::ServerToClient_ReplyConnect* reply_connect);
  ::atc_proto::ServerToClient_ReplyConnect* unsafe_arena_release_reply_connect();

  // .atc_proto.ServerToClient.ReplyQueryAirport reply_query_airport = 1102;
  bool has_reply_query_airport() const;
  private:
  bool _internal_has_reply_query_airport() const;
  public:
  void clear_reply_query_airport();
  const ::atc_proto::ServerToClient_ReplyQueryAirport& reply_query_airport() const;
  ::atc_proto::ServerToClient_ReplyQueryAirport* release_reply_query_airport();
  ::atc_proto::ServerToClient_ReplyQueryAirport* mutable_reply_query_airport();
  void set_allocated_reply_query_airport(::atc_proto::ServerToClient_ReplyQueryAirport* reply_query_airport);
  private:
  const ::atc_proto::ServerToClient_ReplyQueryAirport& _internal_reply_query_airport() const;
  ::atc_proto::ServerToClient_ReplyQueryAirport* _internal_mutable_reply_query_airport();
  public:
  void unsafe_arena_set_allocated_reply_query_airport(
      ::atc_proto::ServerToClient_ReplyQueryAirport* reply_query_airport);
  ::atc_proto::ServerToClient_ReplyQueryAirport* unsafe_arena_release_reply_query_airport();

  // .atc_proto.ServerToClient.ReplyCreateAircraft reply_create_aircraft = 1103;
  bool has_reply_create_aircraft() const;
  private:
  bool _internal_has_reply_create_aircraft() const;
  public:
  void clear_reply_create_aircraft();
  const ::atc_proto::ServerToClient_ReplyCreateAircraft& reply_create_aircraft() const;
  ::atc_proto::ServerToClient_ReplyCreateAircraft* release_reply_create_aircraft();
  ::atc_proto::ServerToClient_ReplyCreateAircraft* mutable_reply_create_aircraft();
  void set_allocated_reply_create_aircraft(::atc_proto::ServerToClient_ReplyCreateAircraft* reply_create_aircraft);
  private:
  const ::atc_proto::ServerToClient_ReplyCreateAircraft& _internal_reply_create_aircraft() const;
  ::atc_proto::ServerToClient_ReplyCreateAircraft* _internal_mutable_reply_create_aircraft();
  public:
  void unsafe_arena_set_allocated_reply_create_aircraft(
      ::atc_proto::ServerToClient_ReplyCreateAircraft* reply_create_aircraft);
  ::atc_proto::ServerToClient_ReplyCreateAircraft* unsafe_arena_release_reply_create_aircraft();

  // .atc_proto.ServerToClient.ReplyQueryTaxiPath reply_query_taxi_path = 1106;
  bool has_reply_query_taxi_path() const;
  private:
  bool _internal_has_reply_query_taxi_path() const;
  public:
  void clear_reply_query_taxi_path();
  const ::atc_proto::ServerToClient_ReplyQueryTaxiPath& reply_query_taxi_path() const;
  ::atc_proto::ServerToClient_ReplyQueryTaxiPath* release_reply_query_taxi_path();
  ::atc_proto::ServerToClient_ReplyQueryTaxiPath* mutable_reply_query_taxi_path();
  void set_allocated_reply_query_taxi_path(::atc_proto::ServerToClient_ReplyQueryTaxiPath* reply_query_taxi_path);
  private:
  const ::atc_proto::ServerToClient_ReplyQueryTaxiPath& _internal_reply_query_taxi_path() const;
  ::atc_proto::ServerToClient_ReplyQueryTaxiPath* _internal_mutable_reply_query_taxi_path();
  public:
  void unsafe_arena_set_allocated_reply_query_taxi_path(
      ::atc_proto::ServerToClient_ReplyQueryTaxiPath* reply_query_taxi_path);
  ::atc_proto::ServerToClient_ReplyQueryTaxiPath* unsafe_arena_release_reply_query_taxi_path();

  // .atc_proto.ServerToClient.ReplyQueryTraffic reply_query_traffic = 1107;
  bool has_reply_query_traffic() const;
  private:
  bool _internal_has_reply_query_traffic() const;
  public:
  void clear_reply_query_traffic();
  const ::atc_proto::ServerToClient_ReplyQueryTraffic& reply_query_traffic() const;
  ::atc_proto::ServerToClient_ReplyQueryTraffic* release_reply_query_traffic();
  ::atc_proto::ServerToClient_ReplyQueryTraffic* mutable_reply_query_traffic();
  void set_allocated_reply_query_traffic(::atc_proto::ServerToClient_ReplyQueryTraffic* reply_query_traffic);
  private:
  const ::atc_proto::ServerToClient_ReplyQueryTraffic& _internal_reply_query_traffic() const;
  ::atc_proto::ServerToClient_ReplyQueryTraffic* _internal_mutable_reply_query_traffic();
  public:
  void unsafe_arena_set_allocated_reply_query_traffic(
      ::atc_proto::ServerToClient_ReplyQueryTraffic* reply_query_traffic);
  ::atc_proto::ServerToClient_ReplyQueryTraffic* unsafe_arena_release_reply_query_traffic();

  // .atc_proto.ServerToClient.NotifyAircraftCreated notify_aircraft_created = 201;
  bool has_notify_aircraft_created() const;
  private:
  bool _internal_has_notify_aircraft_created() const;
  public:
  void clear_notify_aircraft_created();
  const ::atc_proto::ServerToClient_NotifyAircraftCreated& notify_aircraft_created() const;
  ::atc_proto::ServerToClient_NotifyAircraftCreated* release_notify_aircraft_created();
  ::atc_proto::ServerToClient_NotifyAircraftCreated* mutable_notify_aircraft_created();
  void set_allocated_notify_aircraft_created(::atc_proto::ServerToClient_NotifyAircraftCreated* notify_aircraft_created);
  private:
  const ::atc_proto::ServerToClient_NotifyAircraftCreated& _internal_notify_aircraft_created() const;
  ::atc_proto::ServerToClient_NotifyAircraftCreated* _internal_mutable_notify_aircraft_created();
  public:
  void unsafe_arena_set_allocated_notify_aircraft_created(
      ::atc_proto::ServerToClient_NotifyAircraftCreated* notify_aircraft_created);
  ::atc_proto::ServerToClient_NotifyAircraftCreated* unsafe_arena_release_notify_aircraft_created();

  // .atc_proto.ServerToClient.NotifyAircraftSituationUpdated notify_aircraft_situation_updated = 202;
  bool has_notify_aircraft_situation_updated() const;
  private:
  bool _internal_has_notify_aircraft_situation_updated() const;
  public:
  void clear_notify_aircraft_situation_updated();
  const ::atc_proto::ServerToClient_NotifyAircraftSituationUpdated& notify_aircraft_situation_updated() const;
  ::atc_proto::ServerToClient_NotifyAircraftSituationUpdated* release_notify_aircraft_situation_updated();
  ::atc_proto::ServerToClient_NotifyAircraftSituationUpdated* mutable_notify_aircraft_situation_updated();
  void set_allocated_notify_aircraft_situation_updated(::atc_proto::ServerToClient_NotifyAircraftSituationUpdated* notify_aircraft_situation_updated);
  private:
  const ::atc_proto::ServerToClient_NotifyAircraftSituationUpdated& _internal_notify_aircraft_situation_updated() const;
  ::atc_proto::ServerToClient_NotifyAircraftSituationUpdated* _internal_mutable_notify_aircraft_situation_updated();
  public:
  void unsafe_arena_set_allocated_notify_aircraft_situation_updated(
      ::atc_proto::ServerToClient_NotifyAircraftSituationUpdated* notify_aircraft_situation_updated);
  ::atc_proto::ServerToClient_NotifyAircraftSituationUpdated* unsafe_arena_release_notify_aircraft_situation_updated();

  // .atc_proto.ServerToClient.NotifyAircraftRemoved notify_aircraft_removed = 203;
  bool has_notify_aircraft_removed() const;
  private:
  bool _internal_has_notify_aircraft_removed() const;
  public:
  void clear_notify_aircraft_removed();
  const ::atc_proto::ServerToClient_NotifyAircraftRemoved& notify_aircraft_removed() const;
  ::atc_proto::ServerToClient_NotifyAircraftRemoved* release_notify_aircraft_removed();
  ::atc_proto::ServerToClient_NotifyAircraftRemoved* mutable_notify_aircraft_removed();
  void set_allocated_notify_aircraft_removed(::atc_proto::ServerToClient_NotifyAircraftRemoved* notify_aircraft_removed);
  private:
  const ::atc_proto::ServerToClient_NotifyAircraftRemoved& _internal_notify_aircraft_removed() const;
  ::atc_proto::ServerToClient_NotifyAircraftRemoved* _internal_mutable_notify_aircraft_removed();
  public:
  void unsafe_arena_set_allocated_notify_aircraft_removed(
      ::atc_proto::ServerToClient_NotifyAircraftRemoved* notify_aircraft_removed);
  ::atc_proto::ServerToClient_NotifyAircraftRemoved* unsafe_arena_release_notify_aircraft_removed();

  // .atc_proto.ServerToClient.ReplyUserAcquireAircraft reply_user_acquire_aircraft = 204;
  bool has_reply_user_acquire_aircraft() const;
  private:
  bool _internal_has_reply_user_acquire_aircraft() const;
  public:
  void clear_reply_user_acquire_aircraft();
  const ::atc_proto::ServerToClient_ReplyUserAcquireAircraft& reply_user_acquire_aircraft() const;
  ::atc_proto::ServerToClient_ReplyUserAcquireAircraft* release_reply_user_acquire_aircraft();
  ::atc_proto::ServerToClient_ReplyUserAcquireAircraft* mutable_reply_user_acquire_aircraft();
  void set_allocated_reply_user_acquire_aircraft(::atc_proto::ServerToClient_ReplyUserAcquireAircraft* reply_user_acquire_aircraft);
  private:
  const ::atc_proto::ServerToClient_ReplyUserAcquireAircraft& _internal_reply_user_acquire_aircraft() const;
  ::atc_proto::ServerToClient_ReplyUserAcquireAircraft* _internal_mutable_reply_user_acquire_aircraft();
  public:
  void unsafe_arena_set_allocated_reply_user_acquire_aircraft(
      ::atc_proto::ServerToClient_ReplyUserAcquireAircraft* reply_user_acquire_aircraft);
  ::atc_proto::ServerToClient_ReplyUserAcquireAircraft* unsafe_arena_release_reply_user_acquire_aircraft();

  // .atc_proto.ServerToClient.FaultDeclined fault_declined = 3001;
  bool has_fault_declined() const;
  private:
  bool _internal_has_fault_declined() const;
  public:
  void clear_fault_declined();
  const ::atc_proto::ServerToClient_FaultDeclined& fault_declined() const;
  ::atc_proto::ServerToClient_FaultDeclined* release_fault_declined();
  ::atc_proto::ServerToClient_FaultDeclined* mutable_fault_declined();
  void set_allocated_fault_declined(::atc_proto::ServerToClient_FaultDeclined* fault_declined);
  private:
  const ::atc_proto::ServerToClient_FaultDeclined& _internal_fault_declined() const;
  ::atc_proto::ServerToClient_FaultDeclined* _internal_mutable_fault_declined();
  public:
  void unsafe_arena_set_allocated_fault_declined(
      ::atc_proto::ServerToClient_FaultDeclined* fault_declined);
  ::atc_proto::ServerToClient_FaultDeclined* unsafe_arena_release_fault_declined();

  // .atc_proto.ServerToClient.FaultNotFound fault_not_found = 3002;
  bool has_fault_not_found() const;
  private:
  bool _internal_has_fault_not_found() const;
  public:
  void clear_fault_not_found();
  const ::atc_proto::ServerToClient_FaultNotFound& fault_not_found() const;
  ::atc_proto::ServerToClient_FaultNotFound* release_fault_not_found();
  ::atc_proto::ServerToClient_FaultNotFound* mutable_fault_not_found();
  void set_allocated_fault_not_found(::atc_proto::ServerToClient_FaultNotFound* fault_not_found);
  private:
  const ::atc_proto::ServerToClient_FaultNotFound& _internal_fault_not_found() const;
  ::atc_proto::ServerToClient_FaultNotFound* _internal_mutable_fault_not_found();
  public:
  void unsafe_arena_set_allocated_fault_not_found(
      ::atc_proto::ServerToClient_FaultNotFound* fault_not_found);
  ::atc_proto::ServerToClient_FaultNotFound* unsafe_arena_release_fault_not_found();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:atc_proto.ServerToClient)
 private:
  class _Internal;
  void set_has_reply_connect();
  void set_has_reply_query_airport();
  void set_has_reply_create_aircraft();
  void set_has_reply_query_taxi_path();
  void set_has_reply_query_traffic();
  void set_has_notify_aircraft_created();
  void set_has_notify_aircraft_situation_updated();
  void set_has_notify_aircraft_removed();
  void set_has_reply_user_acquire_aircraft();
  void set_has_fault_declined();
  void set_has_fault_not_found();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  PROTOBUF_NAMESPACE_ID::Timestamp* sent_at_;
  PROTOBUF_NAMESPACE_ID::Timestamp* request_sent_at_;
  PROTOBUF_NAMESPACE_ID::Timestamp* request_received_at_;
  ::PROTOBUF_NAMESPACE_ID::uint64 id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 reply_to_request_id_;
  union PayloadUnion {
    PayloadUnion() {}
    ::atc_proto::ServerToClient_ReplyConnect* reply_connect_;
    ::atc_proto::ServerToClient_ReplyQueryAirport* reply_query_airport_;
    ::atc_proto::ServerToClient_ReplyCreateAircraft* reply_create_aircraft_;
    ::atc_proto::ServerToClient_ReplyQueryTaxiPath* reply_query_taxi_path_;
    ::atc_proto::ServerToClient_ReplyQueryTraffic* reply_query_traffic_;
    ::atc_proto::ServerToClient_NotifyAircraftCreated* notify_aircraft_created_;
    ::atc_proto::ServerToClient_NotifyAircraftSituationUpdated* notify_aircraft_situation_updated_;
    ::atc_proto::ServerToClient_NotifyAircraftRemoved* notify_aircraft_removed_;
    ::atc_proto::ServerToClient_ReplyUserAcquireAircraft* reply_user_acquire_aircraft_;
    ::atc_proto::ServerToClient_FaultDeclined* fault_declined_;
    ::atc_proto::ServerToClient_FaultNotFound* fault_not_found_;
  } payload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_atc_2eproto;
};
// -------------------------------------------------------------------

class GeoPoint PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:atc_proto.GeoPoint) */ {
 public:
  inline GeoPoint() : GeoPoint(nullptr) {}
  virtual ~GeoPoint();

  GeoPoint(const GeoPoint& from);
  GeoPoint(GeoPoint&& from) noexcept
    : GeoPoint() {
    *this = ::std::move(from);
  }

  inline GeoPoint& operator=(const GeoPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoPoint& operator=(GeoPoint&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GeoPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GeoPoint* internal_default_instance() {
    return reinterpret_cast<const GeoPoint*>(
               &_GeoPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(GeoPoint& a, GeoPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(GeoPoint* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoPoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GeoPoint* New() const final {
    return CreateMaybeMessage<GeoPoint>(nullptr);
  }

  GeoPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GeoPoint>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GeoPoint& from);
  void MergeFrom(const GeoPoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GeoPoint* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "atc_proto.GeoPoint";
  }
  protected:
  explicit GeoPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_atc_2eproto);
    return ::descriptor_table_atc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLatFieldNumber = 1,
    kLonFieldNumber = 2,
  };
  // double lat = 1;
  void clear_lat();
  double lat() const;
  void set_lat(double value);
  private:
  double _internal_lat() const;
  void _internal_set_lat(double value);
  public:

  // double lon = 2;
  void clear_lon();
  double lon() const;
  void set_lon(double value);
  private:
  double _internal_lon() const;
  void _internal_set_lon(double value);
  public:

  // @@protoc_insertion_point(class_scope:atc_proto.GeoPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double lat_;
  double lon_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_atc_2eproto;
};
// -------------------------------------------------------------------

class GeoPolygon_GeoEdge PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:atc_proto.GeoPolygon.GeoEdge) */ {
 public:
  inline GeoPolygon_GeoEdge() : GeoPolygon_GeoEdge(nullptr) {}
  virtual ~GeoPolygon_GeoEdge();

  GeoPolygon_GeoEdge(const GeoPolygon_GeoEdge& from);
  GeoPolygon_GeoEdge(GeoPolygon_GeoEdge&& from) noexcept
    : GeoPolygon_GeoEdge() {
    *this = ::std::move(from);
  }

  inline GeoPolygon_GeoEdge& operator=(const GeoPolygon_GeoEdge& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoPolygon_GeoEdge& operator=(GeoPolygon_GeoEdge&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GeoPolygon_GeoEdge& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GeoPolygon_GeoEdge* internal_default_instance() {
    return reinterpret_cast<const GeoPolygon_GeoEdge*>(
               &_GeoPolygon_GeoEdge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(GeoPolygon_GeoEdge& a, GeoPolygon_GeoEdge& b) {
    a.Swap(&b);
  }
  inline void Swap(GeoPolygon_GeoEdge* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoPolygon_GeoEdge* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GeoPolygon_GeoEdge* New() const final {
    return CreateMaybeMessage<GeoPolygon_GeoEdge>(nullptr);
  }

  GeoPolygon_GeoEdge* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GeoPolygon_GeoEdge>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GeoPolygon_GeoEdge& from);
  void MergeFrom(const GeoPolygon_GeoEdge& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GeoPolygon_GeoEdge* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "atc_proto.GeoPolygon.GeoEdge";
  }
  protected:
  explicit GeoPolygon_GeoEdge(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_atc_2eproto);
    return ::descriptor_table_atc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromPointFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .atc_proto.GeoPoint from_point = 2;
  bool has_from_point() const;
  private:
  bool _internal_has_from_point() const;
  public:
  void clear_from_point();
  const ::atc_proto::GeoPoint& from_point() const;
  ::atc_proto::GeoPoint* release_from_point();
  ::atc_proto::GeoPoint* mutable_from_point();
  void set_allocated_from_point(::atc_proto::GeoPoint* from_point);
  private:
  const ::atc_proto::GeoPoint& _internal_from_point() const;
  ::atc_proto::GeoPoint* _internal_mutable_from_point();
  public:
  void unsafe_arena_set_allocated_from_point(
      ::atc_proto::GeoPoint* from_point);
  ::atc_proto::GeoPoint* unsafe_arena_release_from_point();

  // .atc_proto.GeoEdgeType type = 1;
  void clear_type();
  ::atc_proto::GeoEdgeType type() const;
  void set_type(::atc_proto::GeoEdgeType value);
  private:
  ::atc_proto::GeoEdgeType _internal_type() const;
  void _internal_set_type(::atc_proto::GeoEdgeType value);
  public:

  // @@protoc_insertion_point(class_scope:atc_proto.GeoPolygon.GeoEdge)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::atc_proto::GeoPoint* from_point_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_atc_2eproto;
};
// -------------------------------------------------------------------

class GeoPolygon PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:atc_proto.GeoPolygon) */ {
 public:
  inline GeoPolygon() : GeoPolygon(nullptr) {}
  virtual ~GeoPolygon();

  GeoPolygon(const GeoPolygon& from);
  GeoPolygon(GeoPolygon&& from) noexcept
    : GeoPolygon() {
    *this = ::std::move(from);
  }

  inline GeoPolygon& operator=(const GeoPolygon& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoPolygon& operator=(GeoPolygon&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GeoPolygon& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GeoPolygon* internal_default_instance() {
    return reinterpret_cast<const GeoPolygon*>(
               &_GeoPolygon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(GeoPolygon& a, GeoPolygon& b) {
    a.Swap(&b);
  }
  inline void Swap(GeoPolygon* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoPolygon* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GeoPolygon* New() const final {
    return CreateMaybeMessage<GeoPolygon>(nullptr);
  }

  GeoPolygon* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GeoPolygon>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GeoPolygon& from);
  void MergeFrom(const GeoPolygon& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GeoPolygon* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "atc_proto.GeoPolygon";
  }
  protected:
  explicit GeoPolygon(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_atc_2eproto);
    return ::descriptor_table_atc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef GeoPolygon_GeoEdge GeoEdge;

  // accessors -------------------------------------------------------

  enum : int {
    kEdgesFieldNumber = 1,
  };
  // repeated .atc_proto.GeoPolygon.GeoEdge edges = 1;
  int edges_size() const;
  private:
  int _internal_edges_size() const;
  public:
  void clear_edges();
  ::atc_proto::GeoPolygon_GeoEdge* mutable_edges(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::atc_proto::GeoPolygon_GeoEdge >*
      mutable_edges();
  private:
  const ::atc_proto::GeoPolygon_GeoEdge& _internal_edges(int index) const;
  ::atc_proto::GeoPolygon_GeoEdge* _internal_add_edges();
  public:
  const ::atc_proto::GeoPolygon_GeoEdge& edges(int index) const;
  ::atc_proto::GeoPolygon_GeoEdge* add_edges();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::atc_proto::GeoPolygon_GeoEdge >&
      edges() const;

  // @@protoc_insertion_point(class_scope:atc_proto.GeoPolygon)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::atc_proto::GeoPolygon_GeoEdge > edges_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_atc_2eproto;
};
// -------------------------------------------------------------------

class Vector3dMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:atc_proto.Vector3dMessage) */ {
 public:
  inline Vector3dMessage() : Vector3dMessage(nullptr) {}
  virtual ~Vector3dMessage();

  Vector3dMessage(const Vector3dMessage& from);
  Vector3dMessage(Vector3dMessage&& from) noexcept
    : Vector3dMessage() {
    *this = ::std::move(from);
  }

  inline Vector3dMessage& operator=(const Vector3dMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector3dMessage& operator=(Vector3dMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Vector3dMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vector3dMessage* internal_default_instance() {
    return reinterpret_cast<const Vector3dMessage*>(
               &_Vector3dMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(Vector3dMessage& a, Vector3dMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector3dMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector3dMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vector3dMessage* New() const final {
    return CreateMaybeMessage<Vector3dMessage>(nullptr);
  }

  Vector3dMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vector3dMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Vector3dMessage& from);
  void MergeFrom(const Vector3dMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector3dMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "atc_proto.Vector3dMessage";
  }
  protected:
  explicit Vector3dMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_atc_2eproto);
    return ::descriptor_table_atc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLatFieldNumber = 1,
    kLonFieldNumber = 2,
    kAltFieldNumber = 3,
  };
  // double lat = 1;
  void clear_lat();
  double lat() const;
  void set_lat(double value);
  private:
  double _internal_lat() const;
  void _internal_set_lat(double value);
  public:

  // double lon = 2;
  void clear_lon();
  double lon() const;
  void set_lon(double value);
  private:
  double _internal_lon() const;
  void _internal_set_lon(double value);
  public:

  // double alt = 3;
  void clear_alt();
  double alt() const;
  void set_alt(double value);
  private:
  double _internal_alt() const;
  void _internal_set_alt(double value);
  public:

  // @@protoc_insertion_point(class_scope:atc_proto.Vector3dMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double lat_;
  double lon_;
  double alt_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_atc_2eproto;
};
// -------------------------------------------------------------------

class AttitudeMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:atc_proto.AttitudeMessage) */ {
 public:
  inline AttitudeMessage() : AttitudeMessage(nullptr) {}
  virtual ~AttitudeMessage();

  AttitudeMessage(const AttitudeMessage& from);
  AttitudeMessage(AttitudeMessage&& from) noexcept
    : AttitudeMessage() {
    *this = ::std::move(from);
  }

  inline AttitudeMessage& operator=(const AttitudeMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AttitudeMessage& operator=(AttitudeMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AttitudeMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AttitudeMessage* internal_default_instance() {
    return reinterpret_cast<const AttitudeMessage*>(
               &_AttitudeMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(AttitudeMessage& a, AttitudeMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AttitudeMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AttitudeMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AttitudeMessage* New() const final {
    return CreateMaybeMessage<AttitudeMessage>(nullptr);
  }

  AttitudeMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AttitudeMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AttitudeMessage& from);
  void MergeFrom(const AttitudeMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AttitudeMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "atc_proto.AttitudeMessage";
  }
  protected:
  explicit AttitudeMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_atc_2eproto);
    return ::descriptor_table_atc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeadingFieldNumber = 1,
    kPitchFieldNumber = 2,
    kRollFieldNumber = 3,
  };
  // float heading = 1;
  void clear_heading();
  float heading() const;
  void set_heading(float value);
  private:
  float _internal_heading() const;
  void _internal_set_heading(float value);
  public:

  // float pitch = 2;
  void clear_pitch();
  float pitch() const;
  void set_pitch(float value);
  private:
  float _internal_pitch() const;
  void _internal_set_pitch(float value);
  public:

  // float roll = 3;
  void clear_roll();
  float roll() const;
  void set_roll(float value);
  private:
  float _internal_roll() const;
  void _internal_set_roll(float value);
  public:

  // @@protoc_insertion_point(class_scope:atc_proto.AttitudeMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float heading_;
  float pitch_;
  float roll_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_atc_2eproto;
};
// -------------------------------------------------------------------

class AirportMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:atc_proto.AirportMessage) */ {
 public:
  inline AirportMessage() : AirportMessage(nullptr) {}
  virtual ~AirportMessage();

  AirportMessage(const AirportMessage& from);
  AirportMessage(AirportMessage&& from) noexcept
    : AirportMessage() {
    *this = ::std::move(from);
  }

  inline AirportMessage& operator=(const AirportMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AirportMessage& operator=(AirportMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AirportMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AirportMessage* internal_default_instance() {
    return reinterpret_cast<const AirportMessage*>(
               &_AirportMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(AirportMessage& a, AirportMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AirportMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AirportMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AirportMessage* New() const final {
    return CreateMaybeMessage<AirportMessage>(nullptr);
  }

  AirportMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AirportMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AirportMessage& from);
  void MergeFrom(const AirportMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AirportMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "atc_proto.AirportMessage";
  }
  protected:
  explicit AirportMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_atc_2eproto);
    return ::descriptor_table_atc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRunwaysFieldNumber = 3,
    kParkingStandsFieldNumber = 4,
    kTaxiNodesFieldNumber = 5,
    kTaxiEdgesFieldNumber = 6,
    kIcaoFieldNumber = 1,
    kLocationFieldNumber = 2,
  };
  // repeated .atc_proto.RunwayMessage runways = 3;
  int runways_size() const;
  private:
  int _internal_runways_size() const;
  public:
  void clear_runways();
  ::atc_proto::RunwayMessage* mutable_runways(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::atc_proto::RunwayMessage >*
      mutable_runways();
  private:
  const ::atc_proto::RunwayMessage& _internal_runways(int index) const;
  ::atc_proto::RunwayMessage* _internal_add_runways();
  public:
  const ::atc_proto::RunwayMessage& runways(int index) const;
  ::atc_proto::RunwayMessage* add_runways();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::atc_proto::RunwayMessage >&
      runways() const;

  // repeated .atc_proto.ParkingStandMessage parking_stands = 4;
  int parking_stands_size() const;
  private:
  int _internal_parking_stands_size() const;
  public:
  void clear_parking_stands();
  ::atc_proto::ParkingStandMessage* mutable_parking_stands(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::atc_proto::ParkingStandMessage >*
      mutable_parking_stands();
  private:
  const ::atc_proto::ParkingStandMessage& _internal_parking_stands(int index) const;
  ::atc_proto::ParkingStandMessage* _internal_add_parking_stands();
  public:
  const ::atc_proto::ParkingStandMessage& parking_stands(int index) const;
  ::atc_proto::ParkingStandMessage* add_parking_stands();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::atc_proto::ParkingStandMessage >&
      parking_stands() const;

  // repeated .atc_proto.TaxiNodeMessage taxi_nodes = 5;
  int taxi_nodes_size() const;
  private:
  int _internal_taxi_nodes_size() const;
  public:
  void clear_taxi_nodes();
  ::atc_proto::TaxiNodeMessage* mutable_taxi_nodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::atc_proto::TaxiNodeMessage >*
      mutable_taxi_nodes();
  private:
  const ::atc_proto::TaxiNodeMessage& _internal_taxi_nodes(int index) const;
  ::atc_proto::TaxiNodeMessage* _internal_add_taxi_nodes();
  public:
  const ::atc_proto::TaxiNodeMessage& taxi_nodes(int index) const;
  ::atc_proto::TaxiNodeMessage* add_taxi_nodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::atc_proto::TaxiNodeMessage >&
      taxi_nodes() const;

  // repeated .atc_proto.TaxiEdgeMessage taxi_edges = 6;
  int taxi_edges_size() const;
  private:
  int _internal_taxi_edges_size() const;
  public:
  void clear_taxi_edges();
  ::atc_proto::TaxiEdgeMessage* mutable_taxi_edges(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::atc_proto::TaxiEdgeMessage >*
      mutable_taxi_edges();
  private:
  const ::atc_proto::TaxiEdgeMessage& _internal_taxi_edges(int index) const;
  ::atc_proto::TaxiEdgeMessage* _internal_add_taxi_edges();
  public:
  const ::atc_proto::TaxiEdgeMessage& taxi_edges(int index) const;
  ::atc_proto::TaxiEdgeMessage* add_taxi_edges();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::atc_proto::TaxiEdgeMessage >&
      taxi_edges() const;

  // string icao = 1;
  void clear_icao();
  const std::string& icao() const;
  void set_icao(const std::string& value);
  void set_icao(std::string&& value);
  void set_icao(const char* value);
  void set_icao(const char* value, size_t size);
  std::string* mutable_icao();
  std::string* release_icao();
  void set_allocated_icao(std::string* icao);
  private:
  const std::string& _internal_icao() const;
  void _internal_set_icao(const std::string& value);
  std::string* _internal_mutable_icao();
  public:

  // .atc_proto.GeoPoint location = 2;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const ::atc_proto::GeoPoint& location() const;
  ::atc_proto::GeoPoint* release_location();
  ::atc_proto::GeoPoint* mutable_location();
  void set_allocated_location(::atc_proto::GeoPoint* location);
  private:
  const ::atc_proto::GeoPoint& _internal_location() const;
  ::atc_proto::GeoPoint* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::atc_proto::GeoPoint* location);
  ::atc_proto::GeoPoint* unsafe_arena_release_location();

  // @@protoc_insertion_point(class_scope:atc_proto.AirportMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::atc_proto::RunwayMessage > runways_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::atc_proto::ParkingStandMessage > parking_stands_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::atc_proto::TaxiNodeMessage > taxi_nodes_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::atc_proto::TaxiEdgeMessage > taxi_edges_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr icao_;
  ::atc_proto::GeoPoint* location_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_atc_2eproto;
};
// -------------------------------------------------------------------

class RunwayMessage_End PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:atc_proto.RunwayMessage.End) */ {
 public:
  inline RunwayMessage_End() : RunwayMessage_End(nullptr) {}
  virtual ~RunwayMessage_End();

  RunwayMessage_End(const RunwayMessage_End& from);
  RunwayMessage_End(RunwayMessage_End&& from) noexcept
    : RunwayMessage_End() {
    *this = ::std::move(from);
  }

  inline RunwayMessage_End& operator=(const RunwayMessage_End& from) {
    CopyFrom(from);
    return *this;
  }
  inline RunwayMessage_End& operator=(RunwayMessage_End&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RunwayMessage_End& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RunwayMessage_End* internal_default_instance() {
    return reinterpret_cast<const RunwayMessage_End*>(
               &_RunwayMessage_End_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(RunwayMessage_End& a, RunwayMessage_End& b) {
    a.Swap(&b);
  }
  inline void Swap(RunwayMessage_End* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RunwayMessage_End* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RunwayMessage_End* New() const final {
    return CreateMaybeMessage<RunwayMessage_End>(nullptr);
  }

  RunwayMessage_End* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RunwayMessage_End>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RunwayMessage_End& from);
  void MergeFrom(const RunwayMessage_End& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RunwayMessage_End* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "atc_proto.RunwayMessage.End";
  }
  protected:
  explicit RunwayMessage_End(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_atc_2eproto);
    return ::descriptor_table_atc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kCenterlinePointFieldNumber = 3,
    kHeadingFieldNumber = 2,
    kDisplacedThresholdMetersFieldNumber = 4,
    kOverrunAreaMetersFieldNumber = 5,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .atc_proto.GeoPoint centerline_point = 3;
  bool has_centerline_point() const;
  private:
  bool _internal_has_centerline_point() const;
  public:
  void clear_centerline_point();
  const ::atc_proto::GeoPoint& centerline_point() const;
  ::atc_proto::GeoPoint* release_centerline_point();
  ::atc_proto::GeoPoint* mutable_centerline_point();
  void set_allocated_centerline_point(::atc_proto::GeoPoint* centerline_point);
  private:
  const ::atc_proto::GeoPoint& _internal_centerline_point() const;
  ::atc_proto::GeoPoint* _internal_mutable_centerline_point();
  public:
  void unsafe_arena_set_allocated_centerline_point(
      ::atc_proto::GeoPoint* centerline_point);
  ::atc_proto::GeoPoint* unsafe_arena_release_centerline_point();

  // float heading = 2;
  void clear_heading();
  float heading() const;
  void set_heading(float value);
  private:
  float _internal_heading() const;
  void _internal_set_heading(float value);
  public:

  // float displaced_threshold_meters = 4;
  void clear_displaced_threshold_meters();
  float displaced_threshold_meters() const;
  void set_displaced_threshold_meters(float value);
  private:
  float _internal_displaced_threshold_meters() const;
  void _internal_set_displaced_threshold_meters(float value);
  public:

  // float overrun_area_meters = 5;
  void clear_overrun_area_meters();
  float overrun_area_meters() const;
  void set_overrun_area_meters(float value);
  private:
  float _internal_overrun_area_meters() const;
  void _internal_set_overrun_area_meters(float value);
  public:

  // @@protoc_insertion_point(class_scope:atc_proto.RunwayMessage.End)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::atc_proto::GeoPoint* centerline_point_;
  float heading_;
  float displaced_threshold_meters_;
  float overrun_area_meters_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_atc_2eproto;
};
// -------------------------------------------------------------------

class RunwayMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:atc_proto.RunwayMessage) */ {
 public:
  inline RunwayMessage() : RunwayMessage(nullptr) {}
  virtual ~RunwayMessage();

  RunwayMessage(const RunwayMessage& from);
  RunwayMessage(RunwayMessage&& from) noexcept
    : RunwayMessage() {
    *this = ::std::move(from);
  }

  inline RunwayMessage& operator=(const RunwayMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline RunwayMessage& operator=(RunwayMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RunwayMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RunwayMessage* internal_default_instance() {
    return reinterpret_cast<const RunwayMessage*>(
               &_RunwayMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(RunwayMessage& a, RunwayMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(RunwayMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RunwayMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RunwayMessage* New() const final {
    return CreateMaybeMessage<RunwayMessage>(nullptr);
  }

  RunwayMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RunwayMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RunwayMessage& from);
  void MergeFrom(const RunwayMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RunwayMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "atc_proto.RunwayMessage";
  }
  protected:
  explicit RunwayMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_atc_2eproto);
    return ::descriptor_table_atc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef RunwayMessage_End End;

  // accessors -------------------------------------------------------

  enum : int {
    kEnd1FieldNumber = 4,
    kEnd2FieldNumber = 5,
    kWidthMetersFieldNumber = 1,
    kLengthMetersFieldNumber = 2,
    kMaskBitFieldNumber = 3,
  };
  // .atc_proto.RunwayMessage.End end_1 = 4;
  bool has_end_1() const;
  private:
  bool _internal_has_end_1() const;
  public:
  void clear_end_1();
  const ::atc_proto::RunwayMessage_End& end_1() const;
  ::atc_proto::RunwayMessage_End* release_end_1();
  ::atc_proto::RunwayMessage_End* mutable_end_1();
  void set_allocated_end_1(::atc_proto::RunwayMessage_End* end_1);
  private:
  const ::atc_proto::RunwayMessage_End& _internal_end_1() const;
  ::atc_proto::RunwayMessage_End* _internal_mutable_end_1();
  public:
  void unsafe_arena_set_allocated_end_1(
      ::atc_proto::RunwayMessage_End* end_1);
  ::atc_proto::RunwayMessage_End* unsafe_arena_release_end_1();

  // .atc_proto.RunwayMessage.End end_2 = 5;
  bool has_end_2() const;
  private:
  bool _internal_has_end_2() const;
  public:
  void clear_end_2();
  const ::atc_proto::RunwayMessage_End& end_2() const;
  ::atc_proto::RunwayMessage_End* release_end_2();
  ::atc_proto::RunwayMessage_End* mutable_end_2();
  void set_allocated_end_2(::atc_proto::RunwayMessage_End* end_2);
  private:
  const ::atc_proto::RunwayMessage_End& _internal_end_2() const;
  ::atc_proto::RunwayMessage_End* _internal_mutable_end_2();
  public:
  void unsafe_arena_set_allocated_end_2(
      ::atc_proto::RunwayMessage_End* end_2);
  ::atc_proto::RunwayMessage_End* unsafe_arena_release_end_2();

  // float width_meters = 1;
  void clear_width_meters();
  float width_meters() const;
  void set_width_meters(float value);
  private:
  float _internal_width_meters() const;
  void _internal_set_width_meters(float value);
  public:

  // float length_meters = 2;
  void clear_length_meters();
  float length_meters() const;
  void set_length_meters(float value);
  private:
  float _internal_length_meters() const;
  void _internal_set_length_meters(float value);
  public:

  // uint32 mask_bit = 3;
  void clear_mask_bit();
  ::PROTOBUF_NAMESPACE_ID::uint32 mask_bit() const;
  void set_mask_bit(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_mask_bit() const;
  void _internal_set_mask_bit(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:atc_proto.RunwayMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::atc_proto::RunwayMessage_End* end_1_;
  ::atc_proto::RunwayMessage_End* end_2_;
  float width_meters_;
  float length_meters_;
  ::PROTOBUF_NAMESPACE_ID::uint32 mask_bit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_atc_2eproto;
};
// -------------------------------------------------------------------

class TaxiNodeMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:atc_proto.TaxiNodeMessage) */ {
 public:
  inline TaxiNodeMessage() : TaxiNodeMessage(nullptr) {}
  virtual ~TaxiNodeMessage();

  TaxiNodeMessage(const TaxiNodeMessage& from);
  TaxiNodeMessage(TaxiNodeMessage&& from) noexcept
    : TaxiNodeMessage() {
    *this = ::std::move(from);
  }

  inline TaxiNodeMessage& operator=(const TaxiNodeMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaxiNodeMessage& operator=(TaxiNodeMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TaxiNodeMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaxiNodeMessage* internal_default_instance() {
    return reinterpret_cast<const TaxiNodeMessage*>(
               &_TaxiNodeMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(TaxiNodeMessage& a, TaxiNodeMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(TaxiNodeMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaxiNodeMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TaxiNodeMessage* New() const final {
    return CreateMaybeMessage<TaxiNodeMessage>(nullptr);
  }

  TaxiNodeMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TaxiNodeMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TaxiNodeMessage& from);
  void MergeFrom(const TaxiNodeMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaxiNodeMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "atc_proto.TaxiNodeMessage";
  }
  protected:
  explicit TaxiNodeMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_atc_2eproto);
    return ::descriptor_table_atc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 2,
    kIdFieldNumber = 1,
    kIsJunctionFieldNumber = 3,
  };
  // .atc_proto.GeoPoint location = 2;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const ::atc_proto::GeoPoint& location() const;
  ::atc_proto::GeoPoint* release_location();
  ::atc_proto::GeoPoint* mutable_location();
  void set_allocated_location(::atc_proto::GeoPoint* location);
  private:
  const ::atc_proto::GeoPoint& _internal_location() const;
  ::atc_proto::GeoPoint* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::atc_proto::GeoPoint* location);
  ::atc_proto::GeoPoint* unsafe_arena_release_location();

  // int32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool is_junction = 3;
  void clear_is_junction();
  bool is_junction() const;
  void set_is_junction(bool value);
  private:
  bool _internal_is_junction() const;
  void _internal_set_is_junction(bool value);
  public:

  // @@protoc_insertion_point(class_scope:atc_proto.TaxiNodeMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::atc_proto::GeoPoint* location_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  bool is_junction_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_atc_2eproto;
};
// -------------------------------------------------------------------

class TaxiEdgeMessage_ActiveZoneMatrix PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:atc_proto.TaxiEdgeMessage.ActiveZoneMatrix) */ {
 public:
  inline TaxiEdgeMessage_ActiveZoneMatrix() : TaxiEdgeMessage_ActiveZoneMatrix(nullptr) {}
  virtual ~TaxiEdgeMessage_ActiveZoneMatrix();

  TaxiEdgeMessage_ActiveZoneMatrix(const TaxiEdgeMessage_ActiveZoneMatrix& from);
  TaxiEdgeMessage_ActiveZoneMatrix(TaxiEdgeMessage_ActiveZoneMatrix&& from) noexcept
    : TaxiEdgeMessage_ActiveZoneMatrix() {
    *this = ::std::move(from);
  }

  inline TaxiEdgeMessage_ActiveZoneMatrix& operator=(const TaxiEdgeMessage_ActiveZoneMatrix& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaxiEdgeMessage_ActiveZoneMatrix& operator=(TaxiEdgeMessage_ActiveZoneMatrix&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TaxiEdgeMessage_ActiveZoneMatrix& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaxiEdgeMessage_ActiveZoneMatrix* internal_default_instance() {
    return reinterpret_cast<const TaxiEdgeMessage_ActiveZoneMatrix*>(
               &_TaxiEdgeMessage_ActiveZoneMatrix_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(TaxiEdgeMessage_ActiveZoneMatrix& a, TaxiEdgeMessage_ActiveZoneMatrix& b) {
    a.Swap(&b);
  }
  inline void Swap(TaxiEdgeMessage_ActiveZoneMatrix* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaxiEdgeMessage_ActiveZoneMatrix* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TaxiEdgeMessage_ActiveZoneMatrix* New() const final {
    return CreateMaybeMessage<TaxiEdgeMessage_ActiveZoneMatrix>(nullptr);
  }

  TaxiEdgeMessage_ActiveZoneMatrix* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TaxiEdgeMessage_ActiveZoneMatrix>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TaxiEdgeMessage_ActiveZoneMatrix& from);
  void MergeFrom(const TaxiEdgeMessage_ActiveZoneMatrix& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaxiEdgeMessage_ActiveZoneMatrix* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "atc_proto.TaxiEdgeMessage.ActiveZoneMatrix";
  }
  protected:
  explicit TaxiEdgeMessage_ActiveZoneMatrix(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_atc_2eproto);
    return ::descriptor_table_atc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDepartureFieldNumber = 1,
    kArrivalFieldNumber = 2,
    kIlsFieldNumber = 3,
  };
  // uint64 departure = 1;
  void clear_departure();
  ::PROTOBUF_NAMESPACE_ID::uint64 departure() const;
  void set_departure(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_departure() const;
  void _internal_set_departure(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 arrival = 2;
  void clear_arrival();
  ::PROTOBUF_NAMESPACE_ID::uint64 arrival() const;
  void set_arrival(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_arrival() const;
  void _internal_set_arrival(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 ils = 3;
  void clear_ils();
  ::PROTOBUF_NAMESPACE_ID::uint64 ils() const;
  void set_ils(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_ils() const;
  void _internal_set_ils(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:atc_proto.TaxiEdgeMessage.ActiveZoneMatrix)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 departure_;
  ::PROTOBUF_NAMESPACE_ID::uint64 arrival_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ils_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_atc_2eproto;
};
// -------------------------------------------------------------------

class TaxiEdgeMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:atc_proto.TaxiEdgeMessage) */ {
 public:
  inline TaxiEdgeMessage() : TaxiEdgeMessage(nullptr) {}
  virtual ~TaxiEdgeMessage();

  TaxiEdgeMessage(const TaxiEdgeMessage& from);
  TaxiEdgeMessage(TaxiEdgeMessage&& from) noexcept
    : TaxiEdgeMessage() {
    *this = ::std::move(from);
  }

  inline TaxiEdgeMessage& operator=(const TaxiEdgeMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaxiEdgeMessage& operator=(TaxiEdgeMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TaxiEdgeMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaxiEdgeMessage* internal_default_instance() {
    return reinterpret_cast<const TaxiEdgeMessage*>(
               &_TaxiEdgeMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(TaxiEdgeMessage& a, TaxiEdgeMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(TaxiEdgeMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaxiEdgeMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TaxiEdgeMessage* New() const final {
    return CreateMaybeMessage<TaxiEdgeMessage>(nullptr);
  }

  TaxiEdgeMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TaxiEdgeMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TaxiEdgeMessage& from);
  void MergeFrom(const TaxiEdgeMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaxiEdgeMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "atc_proto.TaxiEdgeMessage";
  }
  protected:
  explicit TaxiEdgeMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_atc_2eproto);
    return ::descriptor_table_atc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef TaxiEdgeMessage_ActiveZoneMatrix ActiveZoneMatrix;

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kActiveZonesFieldNumber = 10,
    kIdFieldNumber = 1,
    kNodeId1FieldNumber = 3,
    kNodeId2FieldNumber = 4,
    kTypeFieldNumber = 5,
    kIsOneWayFieldNumber = 6,
    kIsHighSpeedExitFieldNumber = 7,
    kLengthMetersFieldNumber = 8,
    kHeadingFieldNumber = 9,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .atc_proto.TaxiEdgeMessage.ActiveZoneMatrix active_zones = 10;
  bool has_active_zones() const;
  private:
  bool _internal_has_active_zones() const;
  public:
  void clear_active_zones();
  const ::atc_proto::TaxiEdgeMessage_ActiveZoneMatrix& active_zones() const;
  ::atc_proto::TaxiEdgeMessage_ActiveZoneMatrix* release_active_zones();
  ::atc_proto::TaxiEdgeMessage_ActiveZoneMatrix* mutable_active_zones();
  void set_allocated_active_zones(::atc_proto::TaxiEdgeMessage_ActiveZoneMatrix* active_zones);
  private:
  const ::atc_proto::TaxiEdgeMessage_ActiveZoneMatrix& _internal_active_zones() const;
  ::atc_proto::TaxiEdgeMessage_ActiveZoneMatrix* _internal_mutable_active_zones();
  public:
  void unsafe_arena_set_allocated_active_zones(
      ::atc_proto::TaxiEdgeMessage_ActiveZoneMatrix* active_zones);
  ::atc_proto::TaxiEdgeMessage_ActiveZoneMatrix* unsafe_arena_release_active_zones();

  // int32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 node_id_1 = 3;
  void clear_node_id_1();
  ::PROTOBUF_NAMESPACE_ID::int32 node_id_1() const;
  void set_node_id_1(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_node_id_1() const;
  void _internal_set_node_id_1(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 node_id_2 = 4;
  void clear_node_id_2();
  ::PROTOBUF_NAMESPACE_ID::int32 node_id_2() const;
  void set_node_id_2(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_node_id_2() const;
  void _internal_set_node_id_2(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .atc_proto.TaxiEdgeType type = 5;
  void clear_type();
  ::atc_proto::TaxiEdgeType type() const;
  void set_type(::atc_proto::TaxiEdgeType value);
  private:
  ::atc_proto::TaxiEdgeType _internal_type() const;
  void _internal_set_type(::atc_proto::TaxiEdgeType value);
  public:

  // bool is_one_way = 6;
  void clear_is_one_way();
  bool is_one_way() const;
  void set_is_one_way(bool value);
  private:
  bool _internal_is_one_way() const;
  void _internal_set_is_one_way(bool value);
  public:

  // bool is_high_speed_exit = 7;
  void clear_is_high_speed_exit();
  bool is_high_speed_exit() const;
  void set_is_high_speed_exit(bool value);
  private:
  bool _internal_is_high_speed_exit() const;
  void _internal_set_is_high_speed_exit(bool value);
  public:

  // float length_meters = 8;
  void clear_length_meters();
  float length_meters() const;
  void set_length_meters(float value);
  private:
  float _internal_length_meters() const;
  void _internal_set_length_meters(float value);
  public:

  // float heading = 9;
  void clear_heading();
  float heading() const;
  void set_heading(float value);
  private:
  float _internal_heading() const;
  void _internal_set_heading(float value);
  public:

  // @@protoc_insertion_point(class_scope:atc_proto.TaxiEdgeMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::atc_proto::TaxiEdgeMessage_ActiveZoneMatrix* active_zones_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  ::PROTOBUF_NAMESPACE_ID::int32 node_id_1_;
  ::PROTOBUF_NAMESPACE_ID::int32 node_id_2_;
  int type_;
  bool is_one_way_;
  bool is_high_speed_exit_;
  float length_meters_;
  float heading_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_atc_2eproto;
};
// -------------------------------------------------------------------

class ParkingStandMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:atc_proto.ParkingStandMessage) */ {
 public:
  inline ParkingStandMessage() : ParkingStandMessage(nullptr) {}
  virtual ~ParkingStandMessage();

  ParkingStandMessage(const ParkingStandMessage& from);
  ParkingStandMessage(ParkingStandMessage&& from) noexcept
    : ParkingStandMessage() {
    *this = ::std::move(from);
  }

  inline ParkingStandMessage& operator=(const ParkingStandMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParkingStandMessage& operator=(ParkingStandMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ParkingStandMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ParkingStandMessage* internal_default_instance() {
    return reinterpret_cast<const ParkingStandMessage*>(
               &_ParkingStandMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(ParkingStandMessage& a, ParkingStandMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ParkingStandMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParkingStandMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ParkingStandMessage* New() const final {
    return CreateMaybeMessage<ParkingStandMessage>(nullptr);
  }

  ParkingStandMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ParkingStandMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ParkingStandMessage& from);
  void MergeFrom(const ParkingStandMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParkingStandMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "atc_proto.ParkingStandMessage";
  }
  protected:
  explicit ParkingStandMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_atc_2eproto);
    return ::descriptor_table_atc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoriesFieldNumber = 7,
    kOperationTypesFieldNumber = 8,
    kAirlineIcaosFieldNumber = 9,
    kNameFieldNumber = 2,
    kWidthCodeFieldNumber = 6,
    kLocationFieldNumber = 4,
    kIdFieldNumber = 1,
    kTypeFieldNumber = 3,
    kHeadingFieldNumber = 5,
  };
  // repeated .atc_proto.AircraftCategory categories = 7;
  int categories_size() const;
  private:
  int _internal_categories_size() const;
  public:
  void clear_categories();
  private:
  ::atc_proto::AircraftCategory _internal_categories(int index) const;
  void _internal_add_categories(::atc_proto::AircraftCategory value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_categories();
  public:
  ::atc_proto::AircraftCategory categories(int index) const;
  void set_categories(int index, ::atc_proto::AircraftCategory value);
  void add_categories(::atc_proto::AircraftCategory value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& categories() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_categories();

  // repeated .atc_proto.OperationType operation_types = 8;
  int operation_types_size() const;
  private:
  int _internal_operation_types_size() const;
  public:
  void clear_operation_types();
  private:
  ::atc_proto::OperationType _internal_operation_types(int index) const;
  void _internal_add_operation_types(::atc_proto::OperationType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_operation_types();
  public:
  ::atc_proto::OperationType operation_types(int index) const;
  void set_operation_types(int index, ::atc_proto::OperationType value);
  void add_operation_types(::atc_proto::OperationType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& operation_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_operation_types();

  // repeated string airline_icaos = 9;
  int airline_icaos_size() const;
  private:
  int _internal_airline_icaos_size() const;
  public:
  void clear_airline_icaos();
  const std::string& airline_icaos(int index) const;
  std::string* mutable_airline_icaos(int index);
  void set_airline_icaos(int index, const std::string& value);
  void set_airline_icaos(int index, std::string&& value);
  void set_airline_icaos(int index, const char* value);
  void set_airline_icaos(int index, const char* value, size_t size);
  std::string* add_airline_icaos();
  void add_airline_icaos(const std::string& value);
  void add_airline_icaos(std::string&& value);
  void add_airline_icaos(const char* value);
  void add_airline_icaos(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& airline_icaos() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_airline_icaos();
  private:
  const std::string& _internal_airline_icaos(int index) const;
  std::string* _internal_add_airline_icaos();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string width_code = 6;
  void clear_width_code();
  const std::string& width_code() const;
  void set_width_code(const std::string& value);
  void set_width_code(std::string&& value);
  void set_width_code(const char* value);
  void set_width_code(const char* value, size_t size);
  std::string* mutable_width_code();
  std::string* release_width_code();
  void set_allocated_width_code(std::string* width_code);
  private:
  const std::string& _internal_width_code() const;
  void _internal_set_width_code(const std::string& value);
  std::string* _internal_mutable_width_code();
  public:

  // .atc_proto.GeoPoint location = 4;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const ::atc_proto::GeoPoint& location() const;
  ::atc_proto::GeoPoint* release_location();
  ::atc_proto::GeoPoint* mutable_location();
  void set_allocated_location(::atc_proto::GeoPoint* location);
  private:
  const ::atc_proto::GeoPoint& _internal_location() const;
  ::atc_proto::GeoPoint* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::atc_proto::GeoPoint* location);
  ::atc_proto::GeoPoint* unsafe_arena_release_location();

  // int32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .atc_proto.ParkingStandType type = 3;
  void clear_type();
  ::atc_proto::ParkingStandType type() const;
  void set_type(::atc_proto::ParkingStandType value);
  private:
  ::atc_proto::ParkingStandType _internal_type() const;
  void _internal_set_type(::atc_proto::ParkingStandType value);
  public:

  // float heading = 5;
  void clear_heading();
  float heading() const;
  void set_heading(float value);
  private:
  float _internal_heading() const;
  void _internal_set_heading(float value);
  public:

  // @@protoc_insertion_point(class_scope:atc_proto.ParkingStandMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> categories_;
  mutable std::atomic<int> _categories_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> operation_types_;
  mutable std::atomic<int> _operation_types_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> airline_icaos_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr width_code_;
  ::atc_proto::GeoPoint* location_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  int type_;
  float heading_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_atc_2eproto;
};
// -------------------------------------------------------------------

class AirspaceGeometryMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:atc_proto.AirspaceGeometryMessage) */ {
 public:
  inline AirspaceGeometryMessage() : AirspaceGeometryMessage(nullptr) {}
  virtual ~AirspaceGeometryMessage();

  AirspaceGeometryMessage(const AirspaceGeometryMessage& from);
  AirspaceGeometryMessage(AirspaceGeometryMessage&& from) noexcept
    : AirspaceGeometryMessage() {
    *this = ::std::move(from);
  }

  inline AirspaceGeometryMessage& operator=(const AirspaceGeometryMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AirspaceGeometryMessage& operator=(AirspaceGeometryMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AirspaceGeometryMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AirspaceGeometryMessage* internal_default_instance() {
    return reinterpret_cast<const AirspaceGeometryMessage*>(
               &_AirspaceGeometryMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(AirspaceGeometryMessage& a, AirspaceGeometryMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AirspaceGeometryMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AirspaceGeometryMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AirspaceGeometryMessage* New() const final {
    return CreateMaybeMessage<AirspaceGeometryMessage>(nullptr);
  }

  AirspaceGeometryMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AirspaceGeometryMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AirspaceGeometryMessage& from);
  void MergeFrom(const AirspaceGeometryMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AirspaceGeometryMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "atc_proto.AirspaceGeometryMessage";
  }
  protected:
  explicit AirspaceGeometryMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_atc_2eproto);
    return ::descriptor_table_atc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLateralBoundsFieldNumber = 1,
    kLowerBoundFeetFieldNumber = 2,
    kUpperBoundFeetFieldNumber = 3,
  };
  // .atc_proto.GeoPolygon lateral_bounds = 1;
  bool has_lateral_bounds() const;
  private:
  bool _internal_has_lateral_bounds() const;
  public:
  void clear_lateral_bounds();
  const ::atc_proto::GeoPolygon& lateral_bounds() const;
  ::atc_proto::GeoPolygon* release_lateral_bounds();
  ::atc_proto::GeoPolygon* mutable_lateral_bounds();
  void set_allocated_lateral_bounds(::atc_proto::GeoPolygon* lateral_bounds);
  private:
  const ::atc_proto::GeoPolygon& _internal_lateral_bounds() const;
  ::atc_proto::GeoPolygon* _internal_mutable_lateral_bounds();
  public:
  void unsafe_arena_set_allocated_lateral_bounds(
      ::atc_proto::GeoPolygon* lateral_bounds);
  ::atc_proto::GeoPolygon* unsafe_arena_release_lateral_bounds();

  // float lower_bound_feet = 2;
  void clear_lower_bound_feet();
  float lower_bound_feet() const;
  void set_lower_bound_feet(float value);
  private:
  float _internal_lower_bound_feet() const;
  void _internal_set_lower_bound_feet(float value);
  public:

  // float upper_bound_feet = 3;
  void clear_upper_bound_feet();
  float upper_bound_feet() const;
  void set_upper_bound_feet(float value);
  private:
  float _internal_upper_bound_feet() const;
  void _internal_set_upper_bound_feet(float value);
  public:

  // @@protoc_insertion_point(class_scope:atc_proto.AirspaceGeometryMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::atc_proto::GeoPolygon* lateral_bounds_;
  float lower_bound_feet_;
  float upper_bound_feet_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_atc_2eproto;
};
// -------------------------------------------------------------------

class AircraftMessage_Situation PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:atc_proto.AircraftMessage.Situation) */ {
 public:
  inline AircraftMessage_Situation() : AircraftMessage_Situation(nullptr) {}
  virtual ~AircraftMessage_Situation();

  AircraftMessage_Situation(const AircraftMessage_Situation& from);
  AircraftMessage_Situation(AircraftMessage_Situation&& from) noexcept
    : AircraftMessage_Situation() {
    *this = ::std::move(from);
  }

  inline AircraftMessage_Situation& operator=(const AircraftMessage_Situation& from) {
    CopyFrom(from);
    return *this;
  }
  inline AircraftMessage_Situation& operator=(AircraftMessage_Situation&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AircraftMessage_Situation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AircraftMessage_Situation* internal_default_instance() {
    return reinterpret_cast<const AircraftMessage_Situation*>(
               &_AircraftMessage_Situation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(AircraftMessage_Situation& a, AircraftMessage_Situation& b) {
    a.Swap(&b);
  }
  inline void Swap(AircraftMessage_Situation* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AircraftMessage_Situation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AircraftMessage_Situation* New() const final {
    return CreateMaybeMessage<AircraftMessage_Situation>(nullptr);
  }

  AircraftMessage_Situation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AircraftMessage_Situation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AircraftMessage_Situation& from);
  void MergeFrom(const AircraftMessage_Situation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AircraftMessage_Situation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "atc_proto.AircraftMessage.Situation";
  }
  protected:
  explicit AircraftMessage_Situation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_atc_2eproto);
    return ::descriptor_table_atc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMonitoringFrequencyKhzFieldNumber = 14,
    kSquawkFieldNumber = 16,
    kLocationFieldNumber = 1,
    kAltitudeFeetMslFieldNumber = 2,
    kHeadingFieldNumber = 4,
    kPitchFieldNumber = 5,
    kRollFieldNumber = 6,
    kFlapRatioFieldNumber = 7,
    kSpoilerRatioFieldNumber = 8,
    kGearRatioFieldNumber = 9,
    kIsOnGroundFieldNumber = 3,
    kLandingLightsFieldNumber = 11,
    kTaxiLightsFieldNumber = 12,
    kStrobeLightsFieldNumber = 13,
    kNoseWheelAngleFieldNumber = 10,
    kTransmittingFrequencyKhzFieldNumber = 15,
    kModeCFieldNumber = 17,
    kModeSFieldNumber = 18,
  };
  // repeated int32 monitoring_frequency_khz = 14;
  int monitoring_frequency_khz_size() const;
  private:
  int _internal_monitoring_frequency_khz_size() const;
  public:
  void clear_monitoring_frequency_khz();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_monitoring_frequency_khz(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_monitoring_frequency_khz() const;
  void _internal_add_monitoring_frequency_khz(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_monitoring_frequency_khz();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 monitoring_frequency_khz(int index) const;
  void set_monitoring_frequency_khz(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_monitoring_frequency_khz(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      monitoring_frequency_khz() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_monitoring_frequency_khz();

  // string squawk = 16;
  void clear_squawk();
  const std::string& squawk() const;
  void set_squawk(const std::string& value);
  void set_squawk(std::string&& value);
  void set_squawk(const char* value);
  void set_squawk(const char* value, size_t size);
  std::string* mutable_squawk();
  std::string* release_squawk();
  void set_allocated_squawk(std::string* squawk);
  private:
  const std::string& _internal_squawk() const;
  void _internal_set_squawk(const std::string& value);
  std::string* _internal_mutable_squawk();
  public:

  // .atc_proto.GeoPoint location = 1;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const ::atc_proto::GeoPoint& location() const;
  ::atc_proto::GeoPoint* release_location();
  ::atc_proto::GeoPoint* mutable_location();
  void set_allocated_location(::atc_proto::GeoPoint* location);
  private:
  const ::atc_proto::GeoPoint& _internal_location() const;
  ::atc_proto::GeoPoint* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::atc_proto::GeoPoint* location);
  ::atc_proto::GeoPoint* unsafe_arena_release_location();

  // float altitude_feet_msl = 2;
  void clear_altitude_feet_msl();
  float altitude_feet_msl() const;
  void set_altitude_feet_msl(float value);
  private:
  float _internal_altitude_feet_msl() const;
  void _internal_set_altitude_feet_msl(float value);
  public:

  // float heading = 4;
  void clear_heading();
  float heading() const;
  void set_heading(float value);
  private:
  float _internal_heading() const;
  void _internal_set_heading(float value);
  public:

  // float pitch = 5;
  void clear_pitch();
  float pitch() const;
  void set_pitch(float value);
  private:
  float _internal_pitch() const;
  void _internal_set_pitch(float value);
  public:

  // float roll = 6;
  void clear_roll();
  float roll() const;
  void set_roll(float value);
  private:
  float _internal_roll() const;
  void _internal_set_roll(float value);
  public:

  // float flap_ratio = 7;
  void clear_flap_ratio();
  float flap_ratio() const;
  void set_flap_ratio(float value);
  private:
  float _internal_flap_ratio() const;
  void _internal_set_flap_ratio(float value);
  public:

  // float spoiler_ratio = 8;
  void clear_spoiler_ratio();
  float spoiler_ratio() const;
  void set_spoiler_ratio(float value);
  private:
  float _internal_spoiler_ratio() const;
  void _internal_set_spoiler_ratio(float value);
  public:

  // float gear_ratio = 9;
  void clear_gear_ratio();
  float gear_ratio() const;
  void set_gear_ratio(float value);
  private:
  float _internal_gear_ratio() const;
  void _internal_set_gear_ratio(float value);
  public:

  // bool is_on_ground = 3;
  void clear_is_on_ground();
  bool is_on_ground() const;
  void set_is_on_ground(bool value);
  private:
  bool _internal_is_on_ground() const;
  void _internal_set_is_on_ground(bool value);
  public:

  // bool landing_lights = 11;
  void clear_landing_lights();
  bool landing_lights() const;
  void set_landing_lights(bool value);
  private:
  bool _internal_landing_lights() const;
  void _internal_set_landing_lights(bool value);
  public:

  // bool taxi_lights = 12;
  void clear_taxi_lights();
  bool taxi_lights() const;
  void set_taxi_lights(bool value);
  private:
  bool _internal_taxi_lights() const;
  void _internal_set_taxi_lights(bool value);
  public:

  // bool strobe_lights = 13;
  void clear_strobe_lights();
  bool strobe_lights() const;
  void set_strobe_lights(bool value);
  private:
  bool _internal_strobe_lights() const;
  void _internal_set_strobe_lights(bool value);
  public:

  // float nose_wheel_angle = 10;
  void clear_nose_wheel_angle();
  float nose_wheel_angle() const;
  void set_nose_wheel_angle(float value);
  private:
  float _internal_nose_wheel_angle() const;
  void _internal_set_nose_wheel_angle(float value);
  public:

  // int32 transmitting_frequency_khz = 15;
  void clear_transmitting_frequency_khz();
  ::PROTOBUF_NAMESPACE_ID::int32 transmitting_frequency_khz() const;
  void set_transmitting_frequency_khz(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_transmitting_frequency_khz() const;
  void _internal_set_transmitting_frequency_khz(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool mode_c = 17;
  void clear_mode_c();
  bool mode_c() const;
  void set_mode_c(bool value);
  private:
  bool _internal_mode_c() const;
  void _internal_set_mode_c(bool value);
  public:

  // bool mode_s = 18;
  void clear_mode_s();
  bool mode_s() const;
  void set_mode_s(bool value);
  private:
  bool _internal_mode_s() const;
  void _internal_set_mode_s(bool value);
  public:

  // @@protoc_insertion_point(class_scope:atc_proto.AircraftMessage.Situation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > monitoring_frequency_khz_;
  mutable std::atomic<int> _monitoring_frequency_khz_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr squawk_;
  ::atc_proto::GeoPoint* location_;
  float altitude_feet_msl_;
  float heading_;
  float pitch_;
  float roll_;
  float flap_ratio_;
  float spoiler_ratio_;
  float gear_ratio_;
  bool is_on_ground_;
  bool landing_lights_;
  bool taxi_lights_;
  bool strobe_lights_;
  float nose_wheel_angle_;
  ::PROTOBUF_NAMESPACE_ID::int32 transmitting_frequency_khz_;
  bool mode_c_;
  bool mode_s_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_atc_2eproto;
};
// -------------------------------------------------------------------

class AircraftMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:atc_proto.AircraftMessage) */ {
 public:
  inline AircraftMessage() : AircraftMessage(nullptr) {}
  virtual ~AircraftMessage();

  AircraftMessage(const AircraftMessage& from);
  AircraftMessage(AircraftMessage&& from) noexcept
    : AircraftMessage() {
    *this = ::std::move(from);
  }

  inline AircraftMessage& operator=(const AircraftMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AircraftMessage& operator=(AircraftMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AircraftMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AircraftMessage* internal_default_instance() {
    return reinterpret_cast<const AircraftMessage*>(
               &_AircraftMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(AircraftMessage& a, AircraftMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AircraftMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AircraftMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AircraftMessage* New() const final {
    return CreateMaybeMessage<AircraftMessage>(nullptr);
  }

  AircraftMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AircraftMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AircraftMessage& from);
  void MergeFrom(const AircraftMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AircraftMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "atc_proto.AircraftMessage";
  }
  protected:
  explicit AircraftMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_atc_2eproto);
    return ::descriptor_table_atc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef AircraftMessage_Situation Situation;

  // accessors -------------------------------------------------------

  enum : int {
    kModelIcaoFieldNumber = 2,
    kAirlineIcaoFieldNumber = 3,
    kTailNoFieldNumber = 4,
    kCallSignFieldNumber = 5,
    kSituationFieldNumber = 6,
    kIdFieldNumber = 1,
  };
  // string model_icao = 2;
  void clear_model_icao();
  const std::string& model_icao() const;
  void set_model_icao(const std::string& value);
  void set_model_icao(std::string&& value);
  void set_model_icao(const char* value);
  void set_model_icao(const char* value, size_t size);
  std::string* mutable_model_icao();
  std::string* release_model_icao();
  void set_allocated_model_icao(std::string* model_icao);
  private:
  const std::string& _internal_model_icao() const;
  void _internal_set_model_icao(const std::string& value);
  std::string* _internal_mutable_model_icao();
  public:

  // string airline_icao = 3;
  void clear_airline_icao();
  const std::string& airline_icao() const;
  void set_airline_icao(const std::string& value);
  void set_airline_icao(std::string&& value);
  void set_airline_icao(const char* value);
  void set_airline_icao(const char* value, size_t size);
  std::string* mutable_airline_icao();
  std::string* release_airline_icao();
  void set_allocated_airline_icao(std::string* airline_icao);
  private:
  const std::string& _internal_airline_icao() const;
  void _internal_set_airline_icao(const std::string& value);
  std::string* _internal_mutable_airline_icao();
  public:

  // string tail_no = 4;
  void clear_tail_no();
  const std::string& tail_no() const;
  void set_tail_no(const std::string& value);
  void set_tail_no(std::string&& value);
  void set_tail_no(const char* value);
  void set_tail_no(const char* value, size_t size);
  std::string* mutable_tail_no();
  std::string* release_tail_no();
  void set_allocated_tail_no(std::string* tail_no);
  private:
  const std::string& _internal_tail_no() const;
  void _internal_set_tail_no(const std::string& value);
  std::string* _internal_mutable_tail_no();
  public:

  // string call_sign = 5;
  void clear_call_sign();
  const std::string& call_sign() const;
  void set_call_sign(const std::string& value);
  void set_call_sign(std::string&& value);
  void set_call_sign(const char* value);
  void set_call_sign(const char* value, size_t size);
  std::string* mutable_call_sign();
  std::string* release_call_sign();
  void set_allocated_call_sign(std::string* call_sign);
  private:
  const std::string& _internal_call_sign() const;
  void _internal_set_call_sign(const std::string& value);
  std::string* _internal_mutable_call_sign();
  public:

  // .atc_proto.AircraftMessage.Situation situation = 6;
  bool has_situation() const;
  private:
  bool _internal_has_situation() const;
  public:
  void clear_situation();
  const ::atc_proto::AircraftMessage_Situation& situation() const;
  ::atc_proto::AircraftMessage_Situation* release_situation();
  ::atc_proto::AircraftMessage_Situation* mutable_situation();
  void set_allocated_situation(::atc_proto::AircraftMessage_Situation* situation);
  private:
  const ::atc_proto::AircraftMessage_Situation& _internal_situation() const;
  ::atc_proto::AircraftMessage_Situation* _internal_mutable_situation();
  public:
  void unsafe_arena_set_allocated_situation(
      ::atc_proto::AircraftMessage_Situation* situation);
  ::atc_proto::AircraftMessage_Situation* unsafe_arena_release_situation();

  // uint32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:atc_proto.AircraftMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_icao_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr airline_icao_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tail_no_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr call_sign_;
  ::atc_proto::AircraftMessage_Situation* situation_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_atc_2eproto;
};
// -------------------------------------------------------------------

class TaxiPathMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:atc_proto.TaxiPathMessage) */ {
 public:
  inline TaxiPathMessage() : TaxiPathMessage(nullptr) {}
  virtual ~TaxiPathMessage();

  TaxiPathMessage(const TaxiPathMessage& from);
  TaxiPathMessage(TaxiPathMessage&& from) noexcept
    : TaxiPathMessage() {
    *this = ::std::move(from);
  }

  inline TaxiPathMessage& operator=(const TaxiPathMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaxiPathMessage& operator=(TaxiPathMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TaxiPathMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaxiPathMessage* internal_default_instance() {
    return reinterpret_cast<const TaxiPathMessage*>(
               &_TaxiPathMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(TaxiPathMessage& a, TaxiPathMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(TaxiPathMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaxiPathMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TaxiPathMessage* New() const final {
    return CreateMaybeMessage<TaxiPathMessage>(nullptr);
  }

  TaxiPathMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TaxiPathMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TaxiPathMessage& from);
  void MergeFrom(const TaxiPathMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaxiPathMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "atc_proto.TaxiPathMessage";
  }
  protected:
  explicit TaxiPathMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_atc_2eproto);
    return ::descriptor_table_atc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEdgeIdsFieldNumber = 3,
    kFromNodeIdFieldNumber = 1,
    kToNodeIdFieldNumber = 2,
  };
  // repeated int32 edge_ids = 3;
  int edge_ids_size() const;
  private:
  int _internal_edge_ids_size() const;
  public:
  void clear_edge_ids();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_edge_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_edge_ids() const;
  void _internal_add_edge_ids(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_edge_ids();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 edge_ids(int index) const;
  void set_edge_ids(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_edge_ids(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      edge_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_edge_ids();

  // int32 from_node_id = 1;
  void clear_from_node_id();
  ::PROTOBUF_NAMESPACE_ID::int32 from_node_id() const;
  void set_from_node_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_from_node_id() const;
  void _internal_set_from_node_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 to_node_id = 2;
  void clear_to_node_id();
  ::PROTOBUF_NAMESPACE_ID::int32 to_node_id() const;
  void set_to_node_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_to_node_id() const;
  void _internal_set_to_node_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:atc_proto.TaxiPathMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > edge_ids_;
  mutable std::atomic<int> _edge_ids_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 from_node_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 to_node_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_atc_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ClientToServer_Connect

// string token = 1;
inline void ClientToServer_Connect::clear_token() {
  token_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ClientToServer_Connect::token() const {
  // @@protoc_insertion_point(field_get:atc_proto.ClientToServer.Connect.token)
  return _internal_token();
}
inline void ClientToServer_Connect::set_token(const std::string& value) {
  _internal_set_token(value);
  // @@protoc_insertion_point(field_set:atc_proto.ClientToServer.Connect.token)
}
inline std::string* ClientToServer_Connect::mutable_token() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ClientToServer.Connect.token)
  return _internal_mutable_token();
}
inline const std::string& ClientToServer_Connect::_internal_token() const {
  return token_.Get();
}
inline void ClientToServer_Connect::_internal_set_token(const std::string& value) {
  
  token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ClientToServer_Connect::set_token(std::string&& value) {
  
  token_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:atc_proto.ClientToServer.Connect.token)
}
inline void ClientToServer_Connect::set_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:atc_proto.ClientToServer.Connect.token)
}
inline void ClientToServer_Connect::set_token(const char* value,
    size_t size) {
  
  token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:atc_proto.ClientToServer.Connect.token)
}
inline std::string* ClientToServer_Connect::_internal_mutable_token() {
  
  return token_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ClientToServer_Connect::release_token() {
  // @@protoc_insertion_point(field_release:atc_proto.ClientToServer.Connect.token)
  return token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ClientToServer_Connect::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:atc_proto.ClientToServer.Connect.token)
}

// -------------------------------------------------------------------

// ClientToServer_QueryAirport

// string icao_code = 1;
inline void ClientToServer_QueryAirport::clear_icao_code() {
  icao_code_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ClientToServer_QueryAirport::icao_code() const {
  // @@protoc_insertion_point(field_get:atc_proto.ClientToServer.QueryAirport.icao_code)
  return _internal_icao_code();
}
inline void ClientToServer_QueryAirport::set_icao_code(const std::string& value) {
  _internal_set_icao_code(value);
  // @@protoc_insertion_point(field_set:atc_proto.ClientToServer.QueryAirport.icao_code)
}
inline std::string* ClientToServer_QueryAirport::mutable_icao_code() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ClientToServer.QueryAirport.icao_code)
  return _internal_mutable_icao_code();
}
inline const std::string& ClientToServer_QueryAirport::_internal_icao_code() const {
  return icao_code_.Get();
}
inline void ClientToServer_QueryAirport::_internal_set_icao_code(const std::string& value) {
  
  icao_code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ClientToServer_QueryAirport::set_icao_code(std::string&& value) {
  
  icao_code_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:atc_proto.ClientToServer.QueryAirport.icao_code)
}
inline void ClientToServer_QueryAirport::set_icao_code(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  icao_code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:atc_proto.ClientToServer.QueryAirport.icao_code)
}
inline void ClientToServer_QueryAirport::set_icao_code(const char* value,
    size_t size) {
  
  icao_code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:atc_proto.ClientToServer.QueryAirport.icao_code)
}
inline std::string* ClientToServer_QueryAirport::_internal_mutable_icao_code() {
  
  return icao_code_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ClientToServer_QueryAirport::release_icao_code() {
  // @@protoc_insertion_point(field_release:atc_proto.ClientToServer.QueryAirport.icao_code)
  return icao_code_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ClientToServer_QueryAirport::set_allocated_icao_code(std::string* icao_code) {
  if (icao_code != nullptr) {
    
  } else {
    
  }
  icao_code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), icao_code,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:atc_proto.ClientToServer.QueryAirport.icao_code)
}

// -------------------------------------------------------------------

// ClientToServer_QueryTaxiPath

// string airport_icao = 1;
inline void ClientToServer_QueryTaxiPath::clear_airport_icao() {
  airport_icao_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ClientToServer_QueryTaxiPath::airport_icao() const {
  // @@protoc_insertion_point(field_get:atc_proto.ClientToServer.QueryTaxiPath.airport_icao)
  return _internal_airport_icao();
}
inline void ClientToServer_QueryTaxiPath::set_airport_icao(const std::string& value) {
  _internal_set_airport_icao(value);
  // @@protoc_insertion_point(field_set:atc_proto.ClientToServer.QueryTaxiPath.airport_icao)
}
inline std::string* ClientToServer_QueryTaxiPath::mutable_airport_icao() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ClientToServer.QueryTaxiPath.airport_icao)
  return _internal_mutable_airport_icao();
}
inline const std::string& ClientToServer_QueryTaxiPath::_internal_airport_icao() const {
  return airport_icao_.Get();
}
inline void ClientToServer_QueryTaxiPath::_internal_set_airport_icao(const std::string& value) {
  
  airport_icao_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ClientToServer_QueryTaxiPath::set_airport_icao(std::string&& value) {
  
  airport_icao_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:atc_proto.ClientToServer.QueryTaxiPath.airport_icao)
}
inline void ClientToServer_QueryTaxiPath::set_airport_icao(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  airport_icao_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:atc_proto.ClientToServer.QueryTaxiPath.airport_icao)
}
inline void ClientToServer_QueryTaxiPath::set_airport_icao(const char* value,
    size_t size) {
  
  airport_icao_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:atc_proto.ClientToServer.QueryTaxiPath.airport_icao)
}
inline std::string* ClientToServer_QueryTaxiPath::_internal_mutable_airport_icao() {
  
  return airport_icao_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ClientToServer_QueryTaxiPath::release_airport_icao() {
  // @@protoc_insertion_point(field_release:atc_proto.ClientToServer.QueryTaxiPath.airport_icao)
  return airport_icao_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ClientToServer_QueryTaxiPath::set_allocated_airport_icao(std::string* airport_icao) {
  if (airport_icao != nullptr) {
    
  } else {
    
  }
  airport_icao_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), airport_icao,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:atc_proto.ClientToServer.QueryTaxiPath.airport_icao)
}

// string aircraft_model_icao = 2;
inline void ClientToServer_QueryTaxiPath::clear_aircraft_model_icao() {
  aircraft_model_icao_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ClientToServer_QueryTaxiPath::aircraft_model_icao() const {
  // @@protoc_insertion_point(field_get:atc_proto.ClientToServer.QueryTaxiPath.aircraft_model_icao)
  return _internal_aircraft_model_icao();
}
inline void ClientToServer_QueryTaxiPath::set_aircraft_model_icao(const std::string& value) {
  _internal_set_aircraft_model_icao(value);
  // @@protoc_insertion_point(field_set:atc_proto.ClientToServer.QueryTaxiPath.aircraft_model_icao)
}
inline std::string* ClientToServer_QueryTaxiPath::mutable_aircraft_model_icao() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ClientToServer.QueryTaxiPath.aircraft_model_icao)
  return _internal_mutable_aircraft_model_icao();
}
inline const std::string& ClientToServer_QueryTaxiPath::_internal_aircraft_model_icao() const {
  return aircraft_model_icao_.Get();
}
inline void ClientToServer_QueryTaxiPath::_internal_set_aircraft_model_icao(const std::string& value) {
  
  aircraft_model_icao_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ClientToServer_QueryTaxiPath::set_aircraft_model_icao(std::string&& value) {
  
  aircraft_model_icao_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:atc_proto.ClientToServer.QueryTaxiPath.aircraft_model_icao)
}
inline void ClientToServer_QueryTaxiPath::set_aircraft_model_icao(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  aircraft_model_icao_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:atc_proto.ClientToServer.QueryTaxiPath.aircraft_model_icao)
}
inline void ClientToServer_QueryTaxiPath::set_aircraft_model_icao(const char* value,
    size_t size) {
  
  aircraft_model_icao_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:atc_proto.ClientToServer.QueryTaxiPath.aircraft_model_icao)
}
inline std::string* ClientToServer_QueryTaxiPath::_internal_mutable_aircraft_model_icao() {
  
  return aircraft_model_icao_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ClientToServer_QueryTaxiPath::release_aircraft_model_icao() {
  // @@protoc_insertion_point(field_release:atc_proto.ClientToServer.QueryTaxiPath.aircraft_model_icao)
  return aircraft_model_icao_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ClientToServer_QueryTaxiPath::set_allocated_aircraft_model_icao(std::string* aircraft_model_icao) {
  if (aircraft_model_icao != nullptr) {
    
  } else {
    
  }
  aircraft_model_icao_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), aircraft_model_icao,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:atc_proto.ClientToServer.QueryTaxiPath.aircraft_model_icao)
}

// .atc_proto.GeoPoint from_point = 3;
inline bool ClientToServer_QueryTaxiPath::_internal_has_from_point() const {
  return this != internal_default_instance() && from_point_ != nullptr;
}
inline bool ClientToServer_QueryTaxiPath::has_from_point() const {
  return _internal_has_from_point();
}
inline void ClientToServer_QueryTaxiPath::clear_from_point() {
  if (GetArena() == nullptr && from_point_ != nullptr) {
    delete from_point_;
  }
  from_point_ = nullptr;
}
inline const ::atc_proto::GeoPoint& ClientToServer_QueryTaxiPath::_internal_from_point() const {
  const ::atc_proto::GeoPoint* p = from_point_;
  return p != nullptr ? *p : *reinterpret_cast<const ::atc_proto::GeoPoint*>(
      &::atc_proto::_GeoPoint_default_instance_);
}
inline const ::atc_proto::GeoPoint& ClientToServer_QueryTaxiPath::from_point() const {
  // @@protoc_insertion_point(field_get:atc_proto.ClientToServer.QueryTaxiPath.from_point)
  return _internal_from_point();
}
inline void ClientToServer_QueryTaxiPath::unsafe_arena_set_allocated_from_point(
    ::atc_proto::GeoPoint* from_point) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(from_point_);
  }
  from_point_ = from_point;
  if (from_point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.ClientToServer.QueryTaxiPath.from_point)
}
inline ::atc_proto::GeoPoint* ClientToServer_QueryTaxiPath::release_from_point() {
  
  ::atc_proto::GeoPoint* temp = from_point_;
  from_point_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::atc_proto::GeoPoint* ClientToServer_QueryTaxiPath::unsafe_arena_release_from_point() {
  // @@protoc_insertion_point(field_release:atc_proto.ClientToServer.QueryTaxiPath.from_point)
  
  ::atc_proto::GeoPoint* temp = from_point_;
  from_point_ = nullptr;
  return temp;
}
inline ::atc_proto::GeoPoint* ClientToServer_QueryTaxiPath::_internal_mutable_from_point() {
  
  if (from_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::atc_proto::GeoPoint>(GetArena());
    from_point_ = p;
  }
  return from_point_;
}
inline ::atc_proto::GeoPoint* ClientToServer_QueryTaxiPath::mutable_from_point() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ClientToServer.QueryTaxiPath.from_point)
  return _internal_mutable_from_point();
}
inline void ClientToServer_QueryTaxiPath::set_allocated_from_point(::atc_proto::GeoPoint* from_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete from_point_;
  }
  if (from_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(from_point);
    if (message_arena != submessage_arena) {
      from_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, from_point, submessage_arena);
    }
    
  } else {
    
  }
  from_point_ = from_point;
  // @@protoc_insertion_point(field_set_allocated:atc_proto.ClientToServer.QueryTaxiPath.from_point)
}

// .atc_proto.GeoPoint to_point = 4;
inline bool ClientToServer_QueryTaxiPath::_internal_has_to_point() const {
  return this != internal_default_instance() && to_point_ != nullptr;
}
inline bool ClientToServer_QueryTaxiPath::has_to_point() const {
  return _internal_has_to_point();
}
inline void ClientToServer_QueryTaxiPath::clear_to_point() {
  if (GetArena() == nullptr && to_point_ != nullptr) {
    delete to_point_;
  }
  to_point_ = nullptr;
}
inline const ::atc_proto::GeoPoint& ClientToServer_QueryTaxiPath::_internal_to_point() const {
  const ::atc_proto::GeoPoint* p = to_point_;
  return p != nullptr ? *p : *reinterpret_cast<const ::atc_proto::GeoPoint*>(
      &::atc_proto::_GeoPoint_default_instance_);
}
inline const ::atc_proto::GeoPoint& ClientToServer_QueryTaxiPath::to_point() const {
  // @@protoc_insertion_point(field_get:atc_proto.ClientToServer.QueryTaxiPath.to_point)
  return _internal_to_point();
}
inline void ClientToServer_QueryTaxiPath::unsafe_arena_set_allocated_to_point(
    ::atc_proto::GeoPoint* to_point) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(to_point_);
  }
  to_point_ = to_point;
  if (to_point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.ClientToServer.QueryTaxiPath.to_point)
}
inline ::atc_proto::GeoPoint* ClientToServer_QueryTaxiPath::release_to_point() {
  
  ::atc_proto::GeoPoint* temp = to_point_;
  to_point_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::atc_proto::GeoPoint* ClientToServer_QueryTaxiPath::unsafe_arena_release_to_point() {
  // @@protoc_insertion_point(field_release:atc_proto.ClientToServer.QueryTaxiPath.to_point)
  
  ::atc_proto::GeoPoint* temp = to_point_;
  to_point_ = nullptr;
  return temp;
}
inline ::atc_proto::GeoPoint* ClientToServer_QueryTaxiPath::_internal_mutable_to_point() {
  
  if (to_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::atc_proto::GeoPoint>(GetArena());
    to_point_ = p;
  }
  return to_point_;
}
inline ::atc_proto::GeoPoint* ClientToServer_QueryTaxiPath::mutable_to_point() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ClientToServer.QueryTaxiPath.to_point)
  return _internal_mutable_to_point();
}
inline void ClientToServer_QueryTaxiPath::set_allocated_to_point(::atc_proto::GeoPoint* to_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete to_point_;
  }
  if (to_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(to_point);
    if (message_arena != submessage_arena) {
      to_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, to_point, submessage_arena);
    }
    
  } else {
    
  }
  to_point_ = to_point;
  // @@protoc_insertion_point(field_set_allocated:atc_proto.ClientToServer.QueryTaxiPath.to_point)
}

// -------------------------------------------------------------------

// ClientToServer_CreateAircraft

// .atc_proto.AircraftMessage aircraft = 1;
inline bool ClientToServer_CreateAircraft::_internal_has_aircraft() const {
  return this != internal_default_instance() && aircraft_ != nullptr;
}
inline bool ClientToServer_CreateAircraft::has_aircraft() const {
  return _internal_has_aircraft();
}
inline void ClientToServer_CreateAircraft::clear_aircraft() {
  if (GetArena() == nullptr && aircraft_ != nullptr) {
    delete aircraft_;
  }
  aircraft_ = nullptr;
}
inline const ::atc_proto::AircraftMessage& ClientToServer_CreateAircraft::_internal_aircraft() const {
  const ::atc_proto::AircraftMessage* p = aircraft_;
  return p != nullptr ? *p : *reinterpret_cast<const ::atc_proto::AircraftMessage*>(
      &::atc_proto::_AircraftMessage_default_instance_);
}
inline const ::atc_proto::AircraftMessage& ClientToServer_CreateAircraft::aircraft() const {
  // @@protoc_insertion_point(field_get:atc_proto.ClientToServer.CreateAircraft.aircraft)
  return _internal_aircraft();
}
inline void ClientToServer_CreateAircraft::unsafe_arena_set_allocated_aircraft(
    ::atc_proto::AircraftMessage* aircraft) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(aircraft_);
  }
  aircraft_ = aircraft;
  if (aircraft) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.ClientToServer.CreateAircraft.aircraft)
}
inline ::atc_proto::AircraftMessage* ClientToServer_CreateAircraft::release_aircraft() {
  
  ::atc_proto::AircraftMessage* temp = aircraft_;
  aircraft_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::atc_proto::AircraftMessage* ClientToServer_CreateAircraft::unsafe_arena_release_aircraft() {
  // @@protoc_insertion_point(field_release:atc_proto.ClientToServer.CreateAircraft.aircraft)
  
  ::atc_proto::AircraftMessage* temp = aircraft_;
  aircraft_ = nullptr;
  return temp;
}
inline ::atc_proto::AircraftMessage* ClientToServer_CreateAircraft::_internal_mutable_aircraft() {
  
  if (aircraft_ == nullptr) {
    auto* p = CreateMaybeMessage<::atc_proto::AircraftMessage>(GetArena());
    aircraft_ = p;
  }
  return aircraft_;
}
inline ::atc_proto::AircraftMessage* ClientToServer_CreateAircraft::mutable_aircraft() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ClientToServer.CreateAircraft.aircraft)
  return _internal_mutable_aircraft();
}
inline void ClientToServer_CreateAircraft::set_allocated_aircraft(::atc_proto::AircraftMessage* aircraft) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete aircraft_;
  }
  if (aircraft) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(aircraft);
    if (message_arena != submessage_arena) {
      aircraft = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, aircraft, submessage_arena);
    }
    
  } else {
    
  }
  aircraft_ = aircraft;
  // @@protoc_insertion_point(field_set_allocated:atc_proto.ClientToServer.CreateAircraft.aircraft)
}

// -------------------------------------------------------------------

// ClientToServer_UpdateAircraftSituation

// uint32 aircraft_id = 1;
inline void ClientToServer_UpdateAircraftSituation::clear_aircraft_id() {
  aircraft_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ClientToServer_UpdateAircraftSituation::_internal_aircraft_id() const {
  return aircraft_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ClientToServer_UpdateAircraftSituation::aircraft_id() const {
  // @@protoc_insertion_point(field_get:atc_proto.ClientToServer.UpdateAircraftSituation.aircraft_id)
  return _internal_aircraft_id();
}
inline void ClientToServer_UpdateAircraftSituation::_internal_set_aircraft_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  aircraft_id_ = value;
}
inline void ClientToServer_UpdateAircraftSituation::set_aircraft_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_aircraft_id(value);
  // @@protoc_insertion_point(field_set:atc_proto.ClientToServer.UpdateAircraftSituation.aircraft_id)
}

// .atc_proto.AircraftMessage.Situation situation = 2;
inline bool ClientToServer_UpdateAircraftSituation::_internal_has_situation() const {
  return this != internal_default_instance() && situation_ != nullptr;
}
inline bool ClientToServer_UpdateAircraftSituation::has_situation() const {
  return _internal_has_situation();
}
inline void ClientToServer_UpdateAircraftSituation::clear_situation() {
  if (GetArena() == nullptr && situation_ != nullptr) {
    delete situation_;
  }
  situation_ = nullptr;
}
inline const ::atc_proto::AircraftMessage_Situation& ClientToServer_UpdateAircraftSituation::_internal_situation() const {
  const ::atc_proto::AircraftMessage_Situation* p = situation_;
  return p != nullptr ? *p : *reinterpret_cast<const ::atc_proto::AircraftMessage_Situation*>(
      &::atc_proto::_AircraftMessage_Situation_default_instance_);
}
inline const ::atc_proto::AircraftMessage_Situation& ClientToServer_UpdateAircraftSituation::situation() const {
  // @@protoc_insertion_point(field_get:atc_proto.ClientToServer.UpdateAircraftSituation.situation)
  return _internal_situation();
}
inline void ClientToServer_UpdateAircraftSituation::unsafe_arena_set_allocated_situation(
    ::atc_proto::AircraftMessage_Situation* situation) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(situation_);
  }
  situation_ = situation;
  if (situation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.ClientToServer.UpdateAircraftSituation.situation)
}
inline ::atc_proto::AircraftMessage_Situation* ClientToServer_UpdateAircraftSituation::release_situation() {
  
  ::atc_proto::AircraftMessage_Situation* temp = situation_;
  situation_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::atc_proto::AircraftMessage_Situation* ClientToServer_UpdateAircraftSituation::unsafe_arena_release_situation() {
  // @@protoc_insertion_point(field_release:atc_proto.ClientToServer.UpdateAircraftSituation.situation)
  
  ::atc_proto::AircraftMessage_Situation* temp = situation_;
  situation_ = nullptr;
  return temp;
}
inline ::atc_proto::AircraftMessage_Situation* ClientToServer_UpdateAircraftSituation::_internal_mutable_situation() {
  
  if (situation_ == nullptr) {
    auto* p = CreateMaybeMessage<::atc_proto::AircraftMessage_Situation>(GetArena());
    situation_ = p;
  }
  return situation_;
}
inline ::atc_proto::AircraftMessage_Situation* ClientToServer_UpdateAircraftSituation::mutable_situation() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ClientToServer.UpdateAircraftSituation.situation)
  return _internal_mutable_situation();
}
inline void ClientToServer_UpdateAircraftSituation::set_allocated_situation(::atc_proto::AircraftMessage_Situation* situation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete situation_;
  }
  if (situation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(situation);
    if (message_arena != submessage_arena) {
      situation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, situation, submessage_arena);
    }
    
  } else {
    
  }
  situation_ = situation;
  // @@protoc_insertion_point(field_set_allocated:atc_proto.ClientToServer.UpdateAircraftSituation.situation)
}

// -------------------------------------------------------------------

// ClientToServer_RemoveAircraft

// uint32 aircraft_id = 1;
inline void ClientToServer_RemoveAircraft::clear_aircraft_id() {
  aircraft_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ClientToServer_RemoveAircraft::_internal_aircraft_id() const {
  return aircraft_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ClientToServer_RemoveAircraft::aircraft_id() const {
  // @@protoc_insertion_point(field_get:atc_proto.ClientToServer.RemoveAircraft.aircraft_id)
  return _internal_aircraft_id();
}
inline void ClientToServer_RemoveAircraft::_internal_set_aircraft_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  aircraft_id_ = value;
}
inline void ClientToServer_RemoveAircraft::set_aircraft_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_aircraft_id(value);
  // @@protoc_insertion_point(field_set:atc_proto.ClientToServer.RemoveAircraft.aircraft_id)
}

// -------------------------------------------------------------------

// ClientToServer_UserAcquireAircraft

// uint32 aircraft_id = 1;
inline void ClientToServer_UserAcquireAircraft::clear_aircraft_id() {
  aircraft_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ClientToServer_UserAcquireAircraft::_internal_aircraft_id() const {
  return aircraft_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ClientToServer_UserAcquireAircraft::aircraft_id() const {
  // @@protoc_insertion_point(field_get:atc_proto.ClientToServer.UserAcquireAircraft.aircraft_id)
  return _internal_aircraft_id();
}
inline void ClientToServer_UserAcquireAircraft::_internal_set_aircraft_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  aircraft_id_ = value;
}
inline void ClientToServer_UserAcquireAircraft::set_aircraft_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_aircraft_id(value);
  // @@protoc_insertion_point(field_set:atc_proto.ClientToServer.UserAcquireAircraft.aircraft_id)
}

// -------------------------------------------------------------------

// ClientToServer_UserUpdateAircraftSituation

// uint32 aircraft_id = 1;
inline void ClientToServer_UserUpdateAircraftSituation::clear_aircraft_id() {
  aircraft_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ClientToServer_UserUpdateAircraftSituation::_internal_aircraft_id() const {
  return aircraft_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ClientToServer_UserUpdateAircraftSituation::aircraft_id() const {
  // @@protoc_insertion_point(field_get:atc_proto.ClientToServer.UserUpdateAircraftSituation.aircraft_id)
  return _internal_aircraft_id();
}
inline void ClientToServer_UserUpdateAircraftSituation::_internal_set_aircraft_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  aircraft_id_ = value;
}
inline void ClientToServer_UserUpdateAircraftSituation::set_aircraft_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_aircraft_id(value);
  // @@protoc_insertion_point(field_set:atc_proto.ClientToServer.UserUpdateAircraftSituation.aircraft_id)
}

// .atc_proto.AircraftMessage.Situation situation = 2;
inline bool ClientToServer_UserUpdateAircraftSituation::_internal_has_situation() const {
  return this != internal_default_instance() && situation_ != nullptr;
}
inline bool ClientToServer_UserUpdateAircraftSituation::has_situation() const {
  return _internal_has_situation();
}
inline void ClientToServer_UserUpdateAircraftSituation::clear_situation() {
  if (GetArena() == nullptr && situation_ != nullptr) {
    delete situation_;
  }
  situation_ = nullptr;
}
inline const ::atc_proto::AircraftMessage_Situation& ClientToServer_UserUpdateAircraftSituation::_internal_situation() const {
  const ::atc_proto::AircraftMessage_Situation* p = situation_;
  return p != nullptr ? *p : *reinterpret_cast<const ::atc_proto::AircraftMessage_Situation*>(
      &::atc_proto::_AircraftMessage_Situation_default_instance_);
}
inline const ::atc_proto::AircraftMessage_Situation& ClientToServer_UserUpdateAircraftSituation::situation() const {
  // @@protoc_insertion_point(field_get:atc_proto.ClientToServer.UserUpdateAircraftSituation.situation)
  return _internal_situation();
}
inline void ClientToServer_UserUpdateAircraftSituation::unsafe_arena_set_allocated_situation(
    ::atc_proto::AircraftMessage_Situation* situation) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(situation_);
  }
  situation_ = situation;
  if (situation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.ClientToServer.UserUpdateAircraftSituation.situation)
}
inline ::atc_proto::AircraftMessage_Situation* ClientToServer_UserUpdateAircraftSituation::release_situation() {
  
  ::atc_proto::AircraftMessage_Situation* temp = situation_;
  situation_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::atc_proto::AircraftMessage_Situation* ClientToServer_UserUpdateAircraftSituation::unsafe_arena_release_situation() {
  // @@protoc_insertion_point(field_release:atc_proto.ClientToServer.UserUpdateAircraftSituation.situation)
  
  ::atc_proto::AircraftMessage_Situation* temp = situation_;
  situation_ = nullptr;
  return temp;
}
inline ::atc_proto::AircraftMessage_Situation* ClientToServer_UserUpdateAircraftSituation::_internal_mutable_situation() {
  
  if (situation_ == nullptr) {
    auto* p = CreateMaybeMessage<::atc_proto::AircraftMessage_Situation>(GetArena());
    situation_ = p;
  }
  return situation_;
}
inline ::atc_proto::AircraftMessage_Situation* ClientToServer_UserUpdateAircraftSituation::mutable_situation() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ClientToServer.UserUpdateAircraftSituation.situation)
  return _internal_mutable_situation();
}
inline void ClientToServer_UserUpdateAircraftSituation::set_allocated_situation(::atc_proto::AircraftMessage_Situation* situation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete situation_;
  }
  if (situation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(situation);
    if (message_arena != submessage_arena) {
      situation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, situation, submessage_arena);
    }
    
  } else {
    
  }
  situation_ = situation;
  // @@protoc_insertion_point(field_set_allocated:atc_proto.ClientToServer.UserUpdateAircraftSituation.situation)
}

// -------------------------------------------------------------------

// ClientToServer_UserReleaseAircraft

// uint32 aircraft_id = 1;
inline void ClientToServer_UserReleaseAircraft::clear_aircraft_id() {
  aircraft_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ClientToServer_UserReleaseAircraft::_internal_aircraft_id() const {
  return aircraft_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ClientToServer_UserReleaseAircraft::aircraft_id() const {
  // @@protoc_insertion_point(field_get:atc_proto.ClientToServer.UserReleaseAircraft.aircraft_id)
  return _internal_aircraft_id();
}
inline void ClientToServer_UserReleaseAircraft::_internal_set_aircraft_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  aircraft_id_ = value;
}
inline void ClientToServer_UserReleaseAircraft::set_aircraft_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_aircraft_id(value);
  // @@protoc_insertion_point(field_set:atc_proto.ClientToServer.UserReleaseAircraft.aircraft_id)
}

// -------------------------------------------------------------------

// ClientToServer_UserPttPressed

// uint32 frequency_khz = 1;
inline void ClientToServer_UserPttPressed::clear_frequency_khz() {
  frequency_khz_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ClientToServer_UserPttPressed::_internal_frequency_khz() const {
  return frequency_khz_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ClientToServer_UserPttPressed::frequency_khz() const {
  // @@protoc_insertion_point(field_get:atc_proto.ClientToServer.UserPttPressed.frequency_khz)
  return _internal_frequency_khz();
}
inline void ClientToServer_UserPttPressed::_internal_set_frequency_khz(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  frequency_khz_ = value;
}
inline void ClientToServer_UserPttPressed::set_frequency_khz(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_frequency_khz(value);
  // @@protoc_insertion_point(field_set:atc_proto.ClientToServer.UserPttPressed.frequency_khz)
}

// -------------------------------------------------------------------

// ClientToServer_UserPttReleased

// uint32 frequency_khz = 1;
inline void ClientToServer_UserPttReleased::clear_frequency_khz() {
  frequency_khz_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ClientToServer_UserPttReleased::_internal_frequency_khz() const {
  return frequency_khz_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ClientToServer_UserPttReleased::frequency_khz() const {
  // @@protoc_insertion_point(field_get:atc_proto.ClientToServer.UserPttReleased.frequency_khz)
  return _internal_frequency_khz();
}
inline void ClientToServer_UserPttReleased::_internal_set_frequency_khz(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  frequency_khz_ = value;
}
inline void ClientToServer_UserPttReleased::set_frequency_khz(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_frequency_khz(value);
  // @@protoc_insertion_point(field_set:atc_proto.ClientToServer.UserPttReleased.frequency_khz)
}

// -------------------------------------------------------------------

// ClientToServer_QueryTraffic

// double min_lat = 1;
inline void ClientToServer_QueryTraffic::clear_min_lat() {
  min_lat_ = 0;
}
inline double ClientToServer_QueryTraffic::_internal_min_lat() const {
  return min_lat_;
}
inline double ClientToServer_QueryTraffic::min_lat() const {
  // @@protoc_insertion_point(field_get:atc_proto.ClientToServer.QueryTraffic.min_lat)
  return _internal_min_lat();
}
inline void ClientToServer_QueryTraffic::_internal_set_min_lat(double value) {
  
  min_lat_ = value;
}
inline void ClientToServer_QueryTraffic::set_min_lat(double value) {
  _internal_set_min_lat(value);
  // @@protoc_insertion_point(field_set:atc_proto.ClientToServer.QueryTraffic.min_lat)
}

// double min_lon = 2;
inline void ClientToServer_QueryTraffic::clear_min_lon() {
  min_lon_ = 0;
}
inline double ClientToServer_QueryTraffic::_internal_min_lon() const {
  return min_lon_;
}
inline double ClientToServer_QueryTraffic::min_lon() const {
  // @@protoc_insertion_point(field_get:atc_proto.ClientToServer.QueryTraffic.min_lon)
  return _internal_min_lon();
}
inline void ClientToServer_QueryTraffic::_internal_set_min_lon(double value) {
  
  min_lon_ = value;
}
inline void ClientToServer_QueryTraffic::set_min_lon(double value) {
  _internal_set_min_lon(value);
  // @@protoc_insertion_point(field_set:atc_proto.ClientToServer.QueryTraffic.min_lon)
}

// double max_lat = 3;
inline void ClientToServer_QueryTraffic::clear_max_lat() {
  max_lat_ = 0;
}
inline double ClientToServer_QueryTraffic::_internal_max_lat() const {
  return max_lat_;
}
inline double ClientToServer_QueryTraffic::max_lat() const {
  // @@protoc_insertion_point(field_get:atc_proto.ClientToServer.QueryTraffic.max_lat)
  return _internal_max_lat();
}
inline void ClientToServer_QueryTraffic::_internal_set_max_lat(double value) {
  
  max_lat_ = value;
}
inline void ClientToServer_QueryTraffic::set_max_lat(double value) {
  _internal_set_max_lat(value);
  // @@protoc_insertion_point(field_set:atc_proto.ClientToServer.QueryTraffic.max_lat)
}

// double max_lon = 4;
inline void ClientToServer_QueryTraffic::clear_max_lon() {
  max_lon_ = 0;
}
inline double ClientToServer_QueryTraffic::_internal_max_lon() const {
  return max_lon_;
}
inline double ClientToServer_QueryTraffic::max_lon() const {
  // @@protoc_insertion_point(field_get:atc_proto.ClientToServer.QueryTraffic.max_lon)
  return _internal_max_lon();
}
inline void ClientToServer_QueryTraffic::_internal_set_max_lon(double value) {
  
  max_lon_ = value;
}
inline void ClientToServer_QueryTraffic::set_max_lon(double value) {
  _internal_set_max_lon(value);
  // @@protoc_insertion_point(field_set:atc_proto.ClientToServer.QueryTraffic.max_lon)
}

// string cancellation_key = 5;
inline void ClientToServer_QueryTraffic::clear_cancellation_key() {
  cancellation_key_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ClientToServer_QueryTraffic::cancellation_key() const {
  // @@protoc_insertion_point(field_get:atc_proto.ClientToServer.QueryTraffic.cancellation_key)
  return _internal_cancellation_key();
}
inline void ClientToServer_QueryTraffic::set_cancellation_key(const std::string& value) {
  _internal_set_cancellation_key(value);
  // @@protoc_insertion_point(field_set:atc_proto.ClientToServer.QueryTraffic.cancellation_key)
}
inline std::string* ClientToServer_QueryTraffic::mutable_cancellation_key() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ClientToServer.QueryTraffic.cancellation_key)
  return _internal_mutable_cancellation_key();
}
inline const std::string& ClientToServer_QueryTraffic::_internal_cancellation_key() const {
  return cancellation_key_.Get();
}
inline void ClientToServer_QueryTraffic::_internal_set_cancellation_key(const std::string& value) {
  
  cancellation_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ClientToServer_QueryTraffic::set_cancellation_key(std::string&& value) {
  
  cancellation_key_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:atc_proto.ClientToServer.QueryTraffic.cancellation_key)
}
inline void ClientToServer_QueryTraffic::set_cancellation_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  cancellation_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:atc_proto.ClientToServer.QueryTraffic.cancellation_key)
}
inline void ClientToServer_QueryTraffic::set_cancellation_key(const char* value,
    size_t size) {
  
  cancellation_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:atc_proto.ClientToServer.QueryTraffic.cancellation_key)
}
inline std::string* ClientToServer_QueryTraffic::_internal_mutable_cancellation_key() {
  
  return cancellation_key_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ClientToServer_QueryTraffic::release_cancellation_key() {
  // @@protoc_insertion_point(field_release:atc_proto.ClientToServer.QueryTraffic.cancellation_key)
  return cancellation_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ClientToServer_QueryTraffic::set_allocated_cancellation_key(std::string* cancellation_key) {
  if (cancellation_key != nullptr) {
    
  } else {
    
  }
  cancellation_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cancellation_key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:atc_proto.ClientToServer.QueryTraffic.cancellation_key)
}

// -------------------------------------------------------------------

// ClientToServer_CancelTrafficQuery

// string cancellation_key = 1;
inline void ClientToServer_CancelTrafficQuery::clear_cancellation_key() {
  cancellation_key_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ClientToServer_CancelTrafficQuery::cancellation_key() const {
  // @@protoc_insertion_point(field_get:atc_proto.ClientToServer.CancelTrafficQuery.cancellation_key)
  return _internal_cancellation_key();
}
inline void ClientToServer_CancelTrafficQuery::set_cancellation_key(const std::string& value) {
  _internal_set_cancellation_key(value);
  // @@protoc_insertion_point(field_set:atc_proto.ClientToServer.CancelTrafficQuery.cancellation_key)
}
inline std::string* ClientToServer_CancelTrafficQuery::mutable_cancellation_key() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ClientToServer.CancelTrafficQuery.cancellation_key)
  return _internal_mutable_cancellation_key();
}
inline const std::string& ClientToServer_CancelTrafficQuery::_internal_cancellation_key() const {
  return cancellation_key_.Get();
}
inline void ClientToServer_CancelTrafficQuery::_internal_set_cancellation_key(const std::string& value) {
  
  cancellation_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ClientToServer_CancelTrafficQuery::set_cancellation_key(std::string&& value) {
  
  cancellation_key_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:atc_proto.ClientToServer.CancelTrafficQuery.cancellation_key)
}
inline void ClientToServer_CancelTrafficQuery::set_cancellation_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  cancellation_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:atc_proto.ClientToServer.CancelTrafficQuery.cancellation_key)
}
inline void ClientToServer_CancelTrafficQuery::set_cancellation_key(const char* value,
    size_t size) {
  
  cancellation_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:atc_proto.ClientToServer.CancelTrafficQuery.cancellation_key)
}
inline std::string* ClientToServer_CancelTrafficQuery::_internal_mutable_cancellation_key() {
  
  return cancellation_key_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ClientToServer_CancelTrafficQuery::release_cancellation_key() {
  // @@protoc_insertion_point(field_release:atc_proto.ClientToServer.CancelTrafficQuery.cancellation_key)
  return cancellation_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ClientToServer_CancelTrafficQuery::set_allocated_cancellation_key(std::string* cancellation_key) {
  if (cancellation_key != nullptr) {
    
  } else {
    
  }
  cancellation_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cancellation_key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:atc_proto.ClientToServer.CancelTrafficQuery.cancellation_key)
}

// -------------------------------------------------------------------

// ClientToServer

// uint64 id = 1;
inline void ClientToServer::clear_id() {
  id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ClientToServer::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ClientToServer::id() const {
  // @@protoc_insertion_point(field_get:atc_proto.ClientToServer.id)
  return _internal_id();
}
inline void ClientToServer::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  id_ = value;
}
inline void ClientToServer::set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:atc_proto.ClientToServer.id)
}

// .google.protobuf.Timestamp sent_at = 2;
inline bool ClientToServer::_internal_has_sent_at() const {
  return this != internal_default_instance() && sent_at_ != nullptr;
}
inline bool ClientToServer::has_sent_at() const {
  return _internal_has_sent_at();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ClientToServer::_internal_sent_at() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = sent_at_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ClientToServer::sent_at() const {
  // @@protoc_insertion_point(field_get:atc_proto.ClientToServer.sent_at)
  return _internal_sent_at();
}
inline void ClientToServer::unsafe_arena_set_allocated_sent_at(
    PROTOBUF_NAMESPACE_ID::Timestamp* sent_at) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sent_at_);
  }
  sent_at_ = sent_at;
  if (sent_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.ClientToServer.sent_at)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ClientToServer::release_sent_at() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = sent_at_;
  sent_at_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ClientToServer::unsafe_arena_release_sent_at() {
  // @@protoc_insertion_point(field_release:atc_proto.ClientToServer.sent_at)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = sent_at_;
  sent_at_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ClientToServer::_internal_mutable_sent_at() {
  
  if (sent_at_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    sent_at_ = p;
  }
  return sent_at_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ClientToServer::mutable_sent_at() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ClientToServer.sent_at)
  return _internal_mutable_sent_at();
}
inline void ClientToServer::set_allocated_sent_at(PROTOBUF_NAMESPACE_ID::Timestamp* sent_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(sent_at_);
  }
  if (sent_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sent_at)->GetArena();
    if (message_arena != submessage_arena) {
      sent_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sent_at, submessage_arena);
    }
    
  } else {
    
  }
  sent_at_ = sent_at;
  // @@protoc_insertion_point(field_set_allocated:atc_proto.ClientToServer.sent_at)
}

// .atc_proto.ClientToServer.Connect connect = 101;
inline bool ClientToServer::_internal_has_connect() const {
  return payload_case() == kConnect;
}
inline bool ClientToServer::has_connect() const {
  return _internal_has_connect();
}
inline void ClientToServer::set_has_connect() {
  _oneof_case_[0] = kConnect;
}
inline void ClientToServer::clear_connect() {
  if (_internal_has_connect()) {
    if (GetArena() == nullptr) {
      delete payload_.connect_;
    }
    clear_has_payload();
  }
}
inline ::atc_proto::ClientToServer_Connect* ClientToServer::release_connect() {
  // @@protoc_insertion_point(field_release:atc_proto.ClientToServer.connect)
  if (_internal_has_connect()) {
    clear_has_payload();
      ::atc_proto::ClientToServer_Connect* temp = payload_.connect_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.connect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::atc_proto::ClientToServer_Connect& ClientToServer::_internal_connect() const {
  return _internal_has_connect()
      ? *payload_.connect_
      : *reinterpret_cast< ::atc_proto::ClientToServer_Connect*>(&::atc_proto::_ClientToServer_Connect_default_instance_);
}
inline const ::atc_proto::ClientToServer_Connect& ClientToServer::connect() const {
  // @@protoc_insertion_point(field_get:atc_proto.ClientToServer.connect)
  return _internal_connect();
}
inline ::atc_proto::ClientToServer_Connect* ClientToServer::unsafe_arena_release_connect() {
  // @@protoc_insertion_point(field_unsafe_arena_release:atc_proto.ClientToServer.connect)
  if (_internal_has_connect()) {
    clear_has_payload();
    ::atc_proto::ClientToServer_Connect* temp = payload_.connect_;
    payload_.connect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientToServer::unsafe_arena_set_allocated_connect(::atc_proto::ClientToServer_Connect* connect) {
  clear_payload();
  if (connect) {
    set_has_connect();
    payload_.connect_ = connect;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.ClientToServer.connect)
}
inline ::atc_proto::ClientToServer_Connect* ClientToServer::_internal_mutable_connect() {
  if (!_internal_has_connect()) {
    clear_payload();
    set_has_connect();
    payload_.connect_ = CreateMaybeMessage< ::atc_proto::ClientToServer_Connect >(GetArena());
  }
  return payload_.connect_;
}
inline ::atc_proto::ClientToServer_Connect* ClientToServer::mutable_connect() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ClientToServer.connect)
  return _internal_mutable_connect();
}

// .atc_proto.ClientToServer.QueryAirport query_airport = 102;
inline bool ClientToServer::_internal_has_query_airport() const {
  return payload_case() == kQueryAirport;
}
inline bool ClientToServer::has_query_airport() const {
  return _internal_has_query_airport();
}
inline void ClientToServer::set_has_query_airport() {
  _oneof_case_[0] = kQueryAirport;
}
inline void ClientToServer::clear_query_airport() {
  if (_internal_has_query_airport()) {
    if (GetArena() == nullptr) {
      delete payload_.query_airport_;
    }
    clear_has_payload();
  }
}
inline ::atc_proto::ClientToServer_QueryAirport* ClientToServer::release_query_airport() {
  // @@protoc_insertion_point(field_release:atc_proto.ClientToServer.query_airport)
  if (_internal_has_query_airport()) {
    clear_has_payload();
      ::atc_proto::ClientToServer_QueryAirport* temp = payload_.query_airport_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.query_airport_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::atc_proto::ClientToServer_QueryAirport& ClientToServer::_internal_query_airport() const {
  return _internal_has_query_airport()
      ? *payload_.query_airport_
      : *reinterpret_cast< ::atc_proto::ClientToServer_QueryAirport*>(&::atc_proto::_ClientToServer_QueryAirport_default_instance_);
}
inline const ::atc_proto::ClientToServer_QueryAirport& ClientToServer::query_airport() const {
  // @@protoc_insertion_point(field_get:atc_proto.ClientToServer.query_airport)
  return _internal_query_airport();
}
inline ::atc_proto::ClientToServer_QueryAirport* ClientToServer::unsafe_arena_release_query_airport() {
  // @@protoc_insertion_point(field_unsafe_arena_release:atc_proto.ClientToServer.query_airport)
  if (_internal_has_query_airport()) {
    clear_has_payload();
    ::atc_proto::ClientToServer_QueryAirport* temp = payload_.query_airport_;
    payload_.query_airport_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientToServer::unsafe_arena_set_allocated_query_airport(::atc_proto::ClientToServer_QueryAirport* query_airport) {
  clear_payload();
  if (query_airport) {
    set_has_query_airport();
    payload_.query_airport_ = query_airport;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.ClientToServer.query_airport)
}
inline ::atc_proto::ClientToServer_QueryAirport* ClientToServer::_internal_mutable_query_airport() {
  if (!_internal_has_query_airport()) {
    clear_payload();
    set_has_query_airport();
    payload_.query_airport_ = CreateMaybeMessage< ::atc_proto::ClientToServer_QueryAirport >(GetArena());
  }
  return payload_.query_airport_;
}
inline ::atc_proto::ClientToServer_QueryAirport* ClientToServer::mutable_query_airport() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ClientToServer.query_airport)
  return _internal_mutable_query_airport();
}

// .atc_proto.ClientToServer.CreateAircraft create_aircraft = 103;
inline bool ClientToServer::_internal_has_create_aircraft() const {
  return payload_case() == kCreateAircraft;
}
inline bool ClientToServer::has_create_aircraft() const {
  return _internal_has_create_aircraft();
}
inline void ClientToServer::set_has_create_aircraft() {
  _oneof_case_[0] = kCreateAircraft;
}
inline void ClientToServer::clear_create_aircraft() {
  if (_internal_has_create_aircraft()) {
    if (GetArena() == nullptr) {
      delete payload_.create_aircraft_;
    }
    clear_has_payload();
  }
}
inline ::atc_proto::ClientToServer_CreateAircraft* ClientToServer::release_create_aircraft() {
  // @@protoc_insertion_point(field_release:atc_proto.ClientToServer.create_aircraft)
  if (_internal_has_create_aircraft()) {
    clear_has_payload();
      ::atc_proto::ClientToServer_CreateAircraft* temp = payload_.create_aircraft_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.create_aircraft_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::atc_proto::ClientToServer_CreateAircraft& ClientToServer::_internal_create_aircraft() const {
  return _internal_has_create_aircraft()
      ? *payload_.create_aircraft_
      : *reinterpret_cast< ::atc_proto::ClientToServer_CreateAircraft*>(&::atc_proto::_ClientToServer_CreateAircraft_default_instance_);
}
inline const ::atc_proto::ClientToServer_CreateAircraft& ClientToServer::create_aircraft() const {
  // @@protoc_insertion_point(field_get:atc_proto.ClientToServer.create_aircraft)
  return _internal_create_aircraft();
}
inline ::atc_proto::ClientToServer_CreateAircraft* ClientToServer::unsafe_arena_release_create_aircraft() {
  // @@protoc_insertion_point(field_unsafe_arena_release:atc_proto.ClientToServer.create_aircraft)
  if (_internal_has_create_aircraft()) {
    clear_has_payload();
    ::atc_proto::ClientToServer_CreateAircraft* temp = payload_.create_aircraft_;
    payload_.create_aircraft_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientToServer::unsafe_arena_set_allocated_create_aircraft(::atc_proto::ClientToServer_CreateAircraft* create_aircraft) {
  clear_payload();
  if (create_aircraft) {
    set_has_create_aircraft();
    payload_.create_aircraft_ = create_aircraft;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.ClientToServer.create_aircraft)
}
inline ::atc_proto::ClientToServer_CreateAircraft* ClientToServer::_internal_mutable_create_aircraft() {
  if (!_internal_has_create_aircraft()) {
    clear_payload();
    set_has_create_aircraft();
    payload_.create_aircraft_ = CreateMaybeMessage< ::atc_proto::ClientToServer_CreateAircraft >(GetArena());
  }
  return payload_.create_aircraft_;
}
inline ::atc_proto::ClientToServer_CreateAircraft* ClientToServer::mutable_create_aircraft() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ClientToServer.create_aircraft)
  return _internal_mutable_create_aircraft();
}

// .atc_proto.ClientToServer.UpdateAircraftSituation update_aircraft_situation = 104;
inline bool ClientToServer::_internal_has_update_aircraft_situation() const {
  return payload_case() == kUpdateAircraftSituation;
}
inline bool ClientToServer::has_update_aircraft_situation() const {
  return _internal_has_update_aircraft_situation();
}
inline void ClientToServer::set_has_update_aircraft_situation() {
  _oneof_case_[0] = kUpdateAircraftSituation;
}
inline void ClientToServer::clear_update_aircraft_situation() {
  if (_internal_has_update_aircraft_situation()) {
    if (GetArena() == nullptr) {
      delete payload_.update_aircraft_situation_;
    }
    clear_has_payload();
  }
}
inline ::atc_proto::ClientToServer_UpdateAircraftSituation* ClientToServer::release_update_aircraft_situation() {
  // @@protoc_insertion_point(field_release:atc_proto.ClientToServer.update_aircraft_situation)
  if (_internal_has_update_aircraft_situation()) {
    clear_has_payload();
      ::atc_proto::ClientToServer_UpdateAircraftSituation* temp = payload_.update_aircraft_situation_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.update_aircraft_situation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::atc_proto::ClientToServer_UpdateAircraftSituation& ClientToServer::_internal_update_aircraft_situation() const {
  return _internal_has_update_aircraft_situation()
      ? *payload_.update_aircraft_situation_
      : *reinterpret_cast< ::atc_proto::ClientToServer_UpdateAircraftSituation*>(&::atc_proto::_ClientToServer_UpdateAircraftSituation_default_instance_);
}
inline const ::atc_proto::ClientToServer_UpdateAircraftSituation& ClientToServer::update_aircraft_situation() const {
  // @@protoc_insertion_point(field_get:atc_proto.ClientToServer.update_aircraft_situation)
  return _internal_update_aircraft_situation();
}
inline ::atc_proto::ClientToServer_UpdateAircraftSituation* ClientToServer::unsafe_arena_release_update_aircraft_situation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:atc_proto.ClientToServer.update_aircraft_situation)
  if (_internal_has_update_aircraft_situation()) {
    clear_has_payload();
    ::atc_proto::ClientToServer_UpdateAircraftSituation* temp = payload_.update_aircraft_situation_;
    payload_.update_aircraft_situation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientToServer::unsafe_arena_set_allocated_update_aircraft_situation(::atc_proto::ClientToServer_UpdateAircraftSituation* update_aircraft_situation) {
  clear_payload();
  if (update_aircraft_situation) {
    set_has_update_aircraft_situation();
    payload_.update_aircraft_situation_ = update_aircraft_situation;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.ClientToServer.update_aircraft_situation)
}
inline ::atc_proto::ClientToServer_UpdateAircraftSituation* ClientToServer::_internal_mutable_update_aircraft_situation() {
  if (!_internal_has_update_aircraft_situation()) {
    clear_payload();
    set_has_update_aircraft_situation();
    payload_.update_aircraft_situation_ = CreateMaybeMessage< ::atc_proto::ClientToServer_UpdateAircraftSituation >(GetArena());
  }
  return payload_.update_aircraft_situation_;
}
inline ::atc_proto::ClientToServer_UpdateAircraftSituation* ClientToServer::mutable_update_aircraft_situation() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ClientToServer.update_aircraft_situation)
  return _internal_mutable_update_aircraft_situation();
}

// .atc_proto.ClientToServer.RemoveAircraft remove_aircraft = 105;
inline bool ClientToServer::_internal_has_remove_aircraft() const {
  return payload_case() == kRemoveAircraft;
}
inline bool ClientToServer::has_remove_aircraft() const {
  return _internal_has_remove_aircraft();
}
inline void ClientToServer::set_has_remove_aircraft() {
  _oneof_case_[0] = kRemoveAircraft;
}
inline void ClientToServer::clear_remove_aircraft() {
  if (_internal_has_remove_aircraft()) {
    if (GetArena() == nullptr) {
      delete payload_.remove_aircraft_;
    }
    clear_has_payload();
  }
}
inline ::atc_proto::ClientToServer_RemoveAircraft* ClientToServer::release_remove_aircraft() {
  // @@protoc_insertion_point(field_release:atc_proto.ClientToServer.remove_aircraft)
  if (_internal_has_remove_aircraft()) {
    clear_has_payload();
      ::atc_proto::ClientToServer_RemoveAircraft* temp = payload_.remove_aircraft_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.remove_aircraft_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::atc_proto::ClientToServer_RemoveAircraft& ClientToServer::_internal_remove_aircraft() const {
  return _internal_has_remove_aircraft()
      ? *payload_.remove_aircraft_
      : *reinterpret_cast< ::atc_proto::ClientToServer_RemoveAircraft*>(&::atc_proto::_ClientToServer_RemoveAircraft_default_instance_);
}
inline const ::atc_proto::ClientToServer_RemoveAircraft& ClientToServer::remove_aircraft() const {
  // @@protoc_insertion_point(field_get:atc_proto.ClientToServer.remove_aircraft)
  return _internal_remove_aircraft();
}
inline ::atc_proto::ClientToServer_RemoveAircraft* ClientToServer::unsafe_arena_release_remove_aircraft() {
  // @@protoc_insertion_point(field_unsafe_arena_release:atc_proto.ClientToServer.remove_aircraft)
  if (_internal_has_remove_aircraft()) {
    clear_has_payload();
    ::atc_proto::ClientToServer_RemoveAircraft* temp = payload_.remove_aircraft_;
    payload_.remove_aircraft_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientToServer::unsafe_arena_set_allocated_remove_aircraft(::atc_proto::ClientToServer_RemoveAircraft* remove_aircraft) {
  clear_payload();
  if (remove_aircraft) {
    set_has_remove_aircraft();
    payload_.remove_aircraft_ = remove_aircraft;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.ClientToServer.remove_aircraft)
}
inline ::atc_proto::ClientToServer_RemoveAircraft* ClientToServer::_internal_mutable_remove_aircraft() {
  if (!_internal_has_remove_aircraft()) {
    clear_payload();
    set_has_remove_aircraft();
    payload_.remove_aircraft_ = CreateMaybeMessage< ::atc_proto::ClientToServer_RemoveAircraft >(GetArena());
  }
  return payload_.remove_aircraft_;
}
inline ::atc_proto::ClientToServer_RemoveAircraft* ClientToServer::mutable_remove_aircraft() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ClientToServer.remove_aircraft)
  return _internal_mutable_remove_aircraft();
}

// .atc_proto.ClientToServer.QueryTaxiPath query_taxi_path = 106;
inline bool ClientToServer::_internal_has_query_taxi_path() const {
  return payload_case() == kQueryTaxiPath;
}
inline bool ClientToServer::has_query_taxi_path() const {
  return _internal_has_query_taxi_path();
}
inline void ClientToServer::set_has_query_taxi_path() {
  _oneof_case_[0] = kQueryTaxiPath;
}
inline void ClientToServer::clear_query_taxi_path() {
  if (_internal_has_query_taxi_path()) {
    if (GetArena() == nullptr) {
      delete payload_.query_taxi_path_;
    }
    clear_has_payload();
  }
}
inline ::atc_proto::ClientToServer_QueryTaxiPath* ClientToServer::release_query_taxi_path() {
  // @@protoc_insertion_point(field_release:atc_proto.ClientToServer.query_taxi_path)
  if (_internal_has_query_taxi_path()) {
    clear_has_payload();
      ::atc_proto::ClientToServer_QueryTaxiPath* temp = payload_.query_taxi_path_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.query_taxi_path_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::atc_proto::ClientToServer_QueryTaxiPath& ClientToServer::_internal_query_taxi_path() const {
  return _internal_has_query_taxi_path()
      ? *payload_.query_taxi_path_
      : *reinterpret_cast< ::atc_proto::ClientToServer_QueryTaxiPath*>(&::atc_proto::_ClientToServer_QueryTaxiPath_default_instance_);
}
inline const ::atc_proto::ClientToServer_QueryTaxiPath& ClientToServer::query_taxi_path() const {
  // @@protoc_insertion_point(field_get:atc_proto.ClientToServer.query_taxi_path)
  return _internal_query_taxi_path();
}
inline ::atc_proto::ClientToServer_QueryTaxiPath* ClientToServer::unsafe_arena_release_query_taxi_path() {
  // @@protoc_insertion_point(field_unsafe_arena_release:atc_proto.ClientToServer.query_taxi_path)
  if (_internal_has_query_taxi_path()) {
    clear_has_payload();
    ::atc_proto::ClientToServer_QueryTaxiPath* temp = payload_.query_taxi_path_;
    payload_.query_taxi_path_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientToServer::unsafe_arena_set_allocated_query_taxi_path(::atc_proto::ClientToServer_QueryTaxiPath* query_taxi_path) {
  clear_payload();
  if (query_taxi_path) {
    set_has_query_taxi_path();
    payload_.query_taxi_path_ = query_taxi_path;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.ClientToServer.query_taxi_path)
}
inline ::atc_proto::ClientToServer_QueryTaxiPath* ClientToServer::_internal_mutable_query_taxi_path() {
  if (!_internal_has_query_taxi_path()) {
    clear_payload();
    set_has_query_taxi_path();
    payload_.query_taxi_path_ = CreateMaybeMessage< ::atc_proto::ClientToServer_QueryTaxiPath >(GetArena());
  }
  return payload_.query_taxi_path_;
}
inline ::atc_proto::ClientToServer_QueryTaxiPath* ClientToServer::mutable_query_taxi_path() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ClientToServer.query_taxi_path)
  return _internal_mutable_query_taxi_path();
}

// .atc_proto.ClientToServer.QueryTraffic query_traffic = 107;
inline bool ClientToServer::_internal_has_query_traffic() const {
  return payload_case() == kQueryTraffic;
}
inline bool ClientToServer::has_query_traffic() const {
  return _internal_has_query_traffic();
}
inline void ClientToServer::set_has_query_traffic() {
  _oneof_case_[0] = kQueryTraffic;
}
inline void ClientToServer::clear_query_traffic() {
  if (_internal_has_query_traffic()) {
    if (GetArena() == nullptr) {
      delete payload_.query_traffic_;
    }
    clear_has_payload();
  }
}
inline ::atc_proto::ClientToServer_QueryTraffic* ClientToServer::release_query_traffic() {
  // @@protoc_insertion_point(field_release:atc_proto.ClientToServer.query_traffic)
  if (_internal_has_query_traffic()) {
    clear_has_payload();
      ::atc_proto::ClientToServer_QueryTraffic* temp = payload_.query_traffic_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.query_traffic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::atc_proto::ClientToServer_QueryTraffic& ClientToServer::_internal_query_traffic() const {
  return _internal_has_query_traffic()
      ? *payload_.query_traffic_
      : *reinterpret_cast< ::atc_proto::ClientToServer_QueryTraffic*>(&::atc_proto::_ClientToServer_QueryTraffic_default_instance_);
}
inline const ::atc_proto::ClientToServer_QueryTraffic& ClientToServer::query_traffic() const {
  // @@protoc_insertion_point(field_get:atc_proto.ClientToServer.query_traffic)
  return _internal_query_traffic();
}
inline ::atc_proto::ClientToServer_QueryTraffic* ClientToServer::unsafe_arena_release_query_traffic() {
  // @@protoc_insertion_point(field_unsafe_arena_release:atc_proto.ClientToServer.query_traffic)
  if (_internal_has_query_traffic()) {
    clear_has_payload();
    ::atc_proto::ClientToServer_QueryTraffic* temp = payload_.query_traffic_;
    payload_.query_traffic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientToServer::unsafe_arena_set_allocated_query_traffic(::atc_proto::ClientToServer_QueryTraffic* query_traffic) {
  clear_payload();
  if (query_traffic) {
    set_has_query_traffic();
    payload_.query_traffic_ = query_traffic;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.ClientToServer.query_traffic)
}
inline ::atc_proto::ClientToServer_QueryTraffic* ClientToServer::_internal_mutable_query_traffic() {
  if (!_internal_has_query_traffic()) {
    clear_payload();
    set_has_query_traffic();
    payload_.query_traffic_ = CreateMaybeMessage< ::atc_proto::ClientToServer_QueryTraffic >(GetArena());
  }
  return payload_.query_traffic_;
}
inline ::atc_proto::ClientToServer_QueryTraffic* ClientToServer::mutable_query_traffic() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ClientToServer.query_traffic)
  return _internal_mutable_query_traffic();
}

// .atc_proto.ClientToServer.CancelTrafficQuery cancel_traffic_query = 108;
inline bool ClientToServer::_internal_has_cancel_traffic_query() const {
  return payload_case() == kCancelTrafficQuery;
}
inline bool ClientToServer::has_cancel_traffic_query() const {
  return _internal_has_cancel_traffic_query();
}
inline void ClientToServer::set_has_cancel_traffic_query() {
  _oneof_case_[0] = kCancelTrafficQuery;
}
inline void ClientToServer::clear_cancel_traffic_query() {
  if (_internal_has_cancel_traffic_query()) {
    if (GetArena() == nullptr) {
      delete payload_.cancel_traffic_query_;
    }
    clear_has_payload();
  }
}
inline ::atc_proto::ClientToServer_CancelTrafficQuery* ClientToServer::release_cancel_traffic_query() {
  // @@protoc_insertion_point(field_release:atc_proto.ClientToServer.cancel_traffic_query)
  if (_internal_has_cancel_traffic_query()) {
    clear_has_payload();
      ::atc_proto::ClientToServer_CancelTrafficQuery* temp = payload_.cancel_traffic_query_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.cancel_traffic_query_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::atc_proto::ClientToServer_CancelTrafficQuery& ClientToServer::_internal_cancel_traffic_query() const {
  return _internal_has_cancel_traffic_query()
      ? *payload_.cancel_traffic_query_
      : *reinterpret_cast< ::atc_proto::ClientToServer_CancelTrafficQuery*>(&::atc_proto::_ClientToServer_CancelTrafficQuery_default_instance_);
}
inline const ::atc_proto::ClientToServer_CancelTrafficQuery& ClientToServer::cancel_traffic_query() const {
  // @@protoc_insertion_point(field_get:atc_proto.ClientToServer.cancel_traffic_query)
  return _internal_cancel_traffic_query();
}
inline ::atc_proto::ClientToServer_CancelTrafficQuery* ClientToServer::unsafe_arena_release_cancel_traffic_query() {
  // @@protoc_insertion_point(field_unsafe_arena_release:atc_proto.ClientToServer.cancel_traffic_query)
  if (_internal_has_cancel_traffic_query()) {
    clear_has_payload();
    ::atc_proto::ClientToServer_CancelTrafficQuery* temp = payload_.cancel_traffic_query_;
    payload_.cancel_traffic_query_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientToServer::unsafe_arena_set_allocated_cancel_traffic_query(::atc_proto::ClientToServer_CancelTrafficQuery* cancel_traffic_query) {
  clear_payload();
  if (cancel_traffic_query) {
    set_has_cancel_traffic_query();
    payload_.cancel_traffic_query_ = cancel_traffic_query;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.ClientToServer.cancel_traffic_query)
}
inline ::atc_proto::ClientToServer_CancelTrafficQuery* ClientToServer::_internal_mutable_cancel_traffic_query() {
  if (!_internal_has_cancel_traffic_query()) {
    clear_payload();
    set_has_cancel_traffic_query();
    payload_.cancel_traffic_query_ = CreateMaybeMessage< ::atc_proto::ClientToServer_CancelTrafficQuery >(GetArena());
  }
  return payload_.cancel_traffic_query_;
}
inline ::atc_proto::ClientToServer_CancelTrafficQuery* ClientToServer::mutable_cancel_traffic_query() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ClientToServer.cancel_traffic_query)
  return _internal_mutable_cancel_traffic_query();
}

// .atc_proto.ClientToServer.UserAcquireAircraft user_acquire_aircraft = 109;
inline bool ClientToServer::_internal_has_user_acquire_aircraft() const {
  return payload_case() == kUserAcquireAircraft;
}
inline bool ClientToServer::has_user_acquire_aircraft() const {
  return _internal_has_user_acquire_aircraft();
}
inline void ClientToServer::set_has_user_acquire_aircraft() {
  _oneof_case_[0] = kUserAcquireAircraft;
}
inline void ClientToServer::clear_user_acquire_aircraft() {
  if (_internal_has_user_acquire_aircraft()) {
    if (GetArena() == nullptr) {
      delete payload_.user_acquire_aircraft_;
    }
    clear_has_payload();
  }
}
inline ::atc_proto::ClientToServer_UserAcquireAircraft* ClientToServer::release_user_acquire_aircraft() {
  // @@protoc_insertion_point(field_release:atc_proto.ClientToServer.user_acquire_aircraft)
  if (_internal_has_user_acquire_aircraft()) {
    clear_has_payload();
      ::atc_proto::ClientToServer_UserAcquireAircraft* temp = payload_.user_acquire_aircraft_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.user_acquire_aircraft_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::atc_proto::ClientToServer_UserAcquireAircraft& ClientToServer::_internal_user_acquire_aircraft() const {
  return _internal_has_user_acquire_aircraft()
      ? *payload_.user_acquire_aircraft_
      : *reinterpret_cast< ::atc_proto::ClientToServer_UserAcquireAircraft*>(&::atc_proto::_ClientToServer_UserAcquireAircraft_default_instance_);
}
inline const ::atc_proto::ClientToServer_UserAcquireAircraft& ClientToServer::user_acquire_aircraft() const {
  // @@protoc_insertion_point(field_get:atc_proto.ClientToServer.user_acquire_aircraft)
  return _internal_user_acquire_aircraft();
}
inline ::atc_proto::ClientToServer_UserAcquireAircraft* ClientToServer::unsafe_arena_release_user_acquire_aircraft() {
  // @@protoc_insertion_point(field_unsafe_arena_release:atc_proto.ClientToServer.user_acquire_aircraft)
  if (_internal_has_user_acquire_aircraft()) {
    clear_has_payload();
    ::atc_proto::ClientToServer_UserAcquireAircraft* temp = payload_.user_acquire_aircraft_;
    payload_.user_acquire_aircraft_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientToServer::unsafe_arena_set_allocated_user_acquire_aircraft(::atc_proto::ClientToServer_UserAcquireAircraft* user_acquire_aircraft) {
  clear_payload();
  if (user_acquire_aircraft) {
    set_has_user_acquire_aircraft();
    payload_.user_acquire_aircraft_ = user_acquire_aircraft;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.ClientToServer.user_acquire_aircraft)
}
inline ::atc_proto::ClientToServer_UserAcquireAircraft* ClientToServer::_internal_mutable_user_acquire_aircraft() {
  if (!_internal_has_user_acquire_aircraft()) {
    clear_payload();
    set_has_user_acquire_aircraft();
    payload_.user_acquire_aircraft_ = CreateMaybeMessage< ::atc_proto::ClientToServer_UserAcquireAircraft >(GetArena());
  }
  return payload_.user_acquire_aircraft_;
}
inline ::atc_proto::ClientToServer_UserAcquireAircraft* ClientToServer::mutable_user_acquire_aircraft() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ClientToServer.user_acquire_aircraft)
  return _internal_mutable_user_acquire_aircraft();
}

// .atc_proto.ClientToServer.UserUpdateAircraftSituation user_update_aircraft_situation = 110;
inline bool ClientToServer::_internal_has_user_update_aircraft_situation() const {
  return payload_case() == kUserUpdateAircraftSituation;
}
inline bool ClientToServer::has_user_update_aircraft_situation() const {
  return _internal_has_user_update_aircraft_situation();
}
inline void ClientToServer::set_has_user_update_aircraft_situation() {
  _oneof_case_[0] = kUserUpdateAircraftSituation;
}
inline void ClientToServer::clear_user_update_aircraft_situation() {
  if (_internal_has_user_update_aircraft_situation()) {
    if (GetArena() == nullptr) {
      delete payload_.user_update_aircraft_situation_;
    }
    clear_has_payload();
  }
}
inline ::atc_proto::ClientToServer_UserUpdateAircraftSituation* ClientToServer::release_user_update_aircraft_situation() {
  // @@protoc_insertion_point(field_release:atc_proto.ClientToServer.user_update_aircraft_situation)
  if (_internal_has_user_update_aircraft_situation()) {
    clear_has_payload();
      ::atc_proto::ClientToServer_UserUpdateAircraftSituation* temp = payload_.user_update_aircraft_situation_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.user_update_aircraft_situation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::atc_proto::ClientToServer_UserUpdateAircraftSituation& ClientToServer::_internal_user_update_aircraft_situation() const {
  return _internal_has_user_update_aircraft_situation()
      ? *payload_.user_update_aircraft_situation_
      : *reinterpret_cast< ::atc_proto::ClientToServer_UserUpdateAircraftSituation*>(&::atc_proto::_ClientToServer_UserUpdateAircraftSituation_default_instance_);
}
inline const ::atc_proto::ClientToServer_UserUpdateAircraftSituation& ClientToServer::user_update_aircraft_situation() const {
  // @@protoc_insertion_point(field_get:atc_proto.ClientToServer.user_update_aircraft_situation)
  return _internal_user_update_aircraft_situation();
}
inline ::atc_proto::ClientToServer_UserUpdateAircraftSituation* ClientToServer::unsafe_arena_release_user_update_aircraft_situation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:atc_proto.ClientToServer.user_update_aircraft_situation)
  if (_internal_has_user_update_aircraft_situation()) {
    clear_has_payload();
    ::atc_proto::ClientToServer_UserUpdateAircraftSituation* temp = payload_.user_update_aircraft_situation_;
    payload_.user_update_aircraft_situation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientToServer::unsafe_arena_set_allocated_user_update_aircraft_situation(::atc_proto::ClientToServer_UserUpdateAircraftSituation* user_update_aircraft_situation) {
  clear_payload();
  if (user_update_aircraft_situation) {
    set_has_user_update_aircraft_situation();
    payload_.user_update_aircraft_situation_ = user_update_aircraft_situation;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.ClientToServer.user_update_aircraft_situation)
}
inline ::atc_proto::ClientToServer_UserUpdateAircraftSituation* ClientToServer::_internal_mutable_user_update_aircraft_situation() {
  if (!_internal_has_user_update_aircraft_situation()) {
    clear_payload();
    set_has_user_update_aircraft_situation();
    payload_.user_update_aircraft_situation_ = CreateMaybeMessage< ::atc_proto::ClientToServer_UserUpdateAircraftSituation >(GetArena());
  }
  return payload_.user_update_aircraft_situation_;
}
inline ::atc_proto::ClientToServer_UserUpdateAircraftSituation* ClientToServer::mutable_user_update_aircraft_situation() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ClientToServer.user_update_aircraft_situation)
  return _internal_mutable_user_update_aircraft_situation();
}

// .atc_proto.ClientToServer.UserReleaseAircraft user_release_aircraft = 111;
inline bool ClientToServer::_internal_has_user_release_aircraft() const {
  return payload_case() == kUserReleaseAircraft;
}
inline bool ClientToServer::has_user_release_aircraft() const {
  return _internal_has_user_release_aircraft();
}
inline void ClientToServer::set_has_user_release_aircraft() {
  _oneof_case_[0] = kUserReleaseAircraft;
}
inline void ClientToServer::clear_user_release_aircraft() {
  if (_internal_has_user_release_aircraft()) {
    if (GetArena() == nullptr) {
      delete payload_.user_release_aircraft_;
    }
    clear_has_payload();
  }
}
inline ::atc_proto::ClientToServer_UserReleaseAircraft* ClientToServer::release_user_release_aircraft() {
  // @@protoc_insertion_point(field_release:atc_proto.ClientToServer.user_release_aircraft)
  if (_internal_has_user_release_aircraft()) {
    clear_has_payload();
      ::atc_proto::ClientToServer_UserReleaseAircraft* temp = payload_.user_release_aircraft_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.user_release_aircraft_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::atc_proto::ClientToServer_UserReleaseAircraft& ClientToServer::_internal_user_release_aircraft() const {
  return _internal_has_user_release_aircraft()
      ? *payload_.user_release_aircraft_
      : *reinterpret_cast< ::atc_proto::ClientToServer_UserReleaseAircraft*>(&::atc_proto::_ClientToServer_UserReleaseAircraft_default_instance_);
}
inline const ::atc_proto::ClientToServer_UserReleaseAircraft& ClientToServer::user_release_aircraft() const {
  // @@protoc_insertion_point(field_get:atc_proto.ClientToServer.user_release_aircraft)
  return _internal_user_release_aircraft();
}
inline ::atc_proto::ClientToServer_UserReleaseAircraft* ClientToServer::unsafe_arena_release_user_release_aircraft() {
  // @@protoc_insertion_point(field_unsafe_arena_release:atc_proto.ClientToServer.user_release_aircraft)
  if (_internal_has_user_release_aircraft()) {
    clear_has_payload();
    ::atc_proto::ClientToServer_UserReleaseAircraft* temp = payload_.user_release_aircraft_;
    payload_.user_release_aircraft_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientToServer::unsafe_arena_set_allocated_user_release_aircraft(::atc_proto::ClientToServer_UserReleaseAircraft* user_release_aircraft) {
  clear_payload();
  if (user_release_aircraft) {
    set_has_user_release_aircraft();
    payload_.user_release_aircraft_ = user_release_aircraft;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.ClientToServer.user_release_aircraft)
}
inline ::atc_proto::ClientToServer_UserReleaseAircraft* ClientToServer::_internal_mutable_user_release_aircraft() {
  if (!_internal_has_user_release_aircraft()) {
    clear_payload();
    set_has_user_release_aircraft();
    payload_.user_release_aircraft_ = CreateMaybeMessage< ::atc_proto::ClientToServer_UserReleaseAircraft >(GetArena());
  }
  return payload_.user_release_aircraft_;
}
inline ::atc_proto::ClientToServer_UserReleaseAircraft* ClientToServer::mutable_user_release_aircraft() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ClientToServer.user_release_aircraft)
  return _internal_mutable_user_release_aircraft();
}

// .atc_proto.ClientToServer.UserPttPressed user_ptt_pressed = 112;
inline bool ClientToServer::_internal_has_user_ptt_pressed() const {
  return payload_case() == kUserPttPressed;
}
inline bool ClientToServer::has_user_ptt_pressed() const {
  return _internal_has_user_ptt_pressed();
}
inline void ClientToServer::set_has_user_ptt_pressed() {
  _oneof_case_[0] = kUserPttPressed;
}
inline void ClientToServer::clear_user_ptt_pressed() {
  if (_internal_has_user_ptt_pressed()) {
    if (GetArena() == nullptr) {
      delete payload_.user_ptt_pressed_;
    }
    clear_has_payload();
  }
}
inline ::atc_proto::ClientToServer_UserPttPressed* ClientToServer::release_user_ptt_pressed() {
  // @@protoc_insertion_point(field_release:atc_proto.ClientToServer.user_ptt_pressed)
  if (_internal_has_user_ptt_pressed()) {
    clear_has_payload();
      ::atc_proto::ClientToServer_UserPttPressed* temp = payload_.user_ptt_pressed_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.user_ptt_pressed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::atc_proto::ClientToServer_UserPttPressed& ClientToServer::_internal_user_ptt_pressed() const {
  return _internal_has_user_ptt_pressed()
      ? *payload_.user_ptt_pressed_
      : *reinterpret_cast< ::atc_proto::ClientToServer_UserPttPressed*>(&::atc_proto::_ClientToServer_UserPttPressed_default_instance_);
}
inline const ::atc_proto::ClientToServer_UserPttPressed& ClientToServer::user_ptt_pressed() const {
  // @@protoc_insertion_point(field_get:atc_proto.ClientToServer.user_ptt_pressed)
  return _internal_user_ptt_pressed();
}
inline ::atc_proto::ClientToServer_UserPttPressed* ClientToServer::unsafe_arena_release_user_ptt_pressed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:atc_proto.ClientToServer.user_ptt_pressed)
  if (_internal_has_user_ptt_pressed()) {
    clear_has_payload();
    ::atc_proto::ClientToServer_UserPttPressed* temp = payload_.user_ptt_pressed_;
    payload_.user_ptt_pressed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientToServer::unsafe_arena_set_allocated_user_ptt_pressed(::atc_proto::ClientToServer_UserPttPressed* user_ptt_pressed) {
  clear_payload();
  if (user_ptt_pressed) {
    set_has_user_ptt_pressed();
    payload_.user_ptt_pressed_ = user_ptt_pressed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.ClientToServer.user_ptt_pressed)
}
inline ::atc_proto::ClientToServer_UserPttPressed* ClientToServer::_internal_mutable_user_ptt_pressed() {
  if (!_internal_has_user_ptt_pressed()) {
    clear_payload();
    set_has_user_ptt_pressed();
    payload_.user_ptt_pressed_ = CreateMaybeMessage< ::atc_proto::ClientToServer_UserPttPressed >(GetArena());
  }
  return payload_.user_ptt_pressed_;
}
inline ::atc_proto::ClientToServer_UserPttPressed* ClientToServer::mutable_user_ptt_pressed() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ClientToServer.user_ptt_pressed)
  return _internal_mutable_user_ptt_pressed();
}

// .atc_proto.ClientToServer.UserPttReleased user_ptt_released = 113;
inline bool ClientToServer::_internal_has_user_ptt_released() const {
  return payload_case() == kUserPttReleased;
}
inline bool ClientToServer::has_user_ptt_released() const {
  return _internal_has_user_ptt_released();
}
inline void ClientToServer::set_has_user_ptt_released() {
  _oneof_case_[0] = kUserPttReleased;
}
inline void ClientToServer::clear_user_ptt_released() {
  if (_internal_has_user_ptt_released()) {
    if (GetArena() == nullptr) {
      delete payload_.user_ptt_released_;
    }
    clear_has_payload();
  }
}
inline ::atc_proto::ClientToServer_UserPttReleased* ClientToServer::release_user_ptt_released() {
  // @@protoc_insertion_point(field_release:atc_proto.ClientToServer.user_ptt_released)
  if (_internal_has_user_ptt_released()) {
    clear_has_payload();
      ::atc_proto::ClientToServer_UserPttReleased* temp = payload_.user_ptt_released_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.user_ptt_released_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::atc_proto::ClientToServer_UserPttReleased& ClientToServer::_internal_user_ptt_released() const {
  return _internal_has_user_ptt_released()
      ? *payload_.user_ptt_released_
      : *reinterpret_cast< ::atc_proto::ClientToServer_UserPttReleased*>(&::atc_proto::_ClientToServer_UserPttReleased_default_instance_);
}
inline const ::atc_proto::ClientToServer_UserPttReleased& ClientToServer::user_ptt_released() const {
  // @@protoc_insertion_point(field_get:atc_proto.ClientToServer.user_ptt_released)
  return _internal_user_ptt_released();
}
inline ::atc_proto::ClientToServer_UserPttReleased* ClientToServer::unsafe_arena_release_user_ptt_released() {
  // @@protoc_insertion_point(field_unsafe_arena_release:atc_proto.ClientToServer.user_ptt_released)
  if (_internal_has_user_ptt_released()) {
    clear_has_payload();
    ::atc_proto::ClientToServer_UserPttReleased* temp = payload_.user_ptt_released_;
    payload_.user_ptt_released_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientToServer::unsafe_arena_set_allocated_user_ptt_released(::atc_proto::ClientToServer_UserPttReleased* user_ptt_released) {
  clear_payload();
  if (user_ptt_released) {
    set_has_user_ptt_released();
    payload_.user_ptt_released_ = user_ptt_released;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.ClientToServer.user_ptt_released)
}
inline ::atc_proto::ClientToServer_UserPttReleased* ClientToServer::_internal_mutable_user_ptt_released() {
  if (!_internal_has_user_ptt_released()) {
    clear_payload();
    set_has_user_ptt_released();
    payload_.user_ptt_released_ = CreateMaybeMessage< ::atc_proto::ClientToServer_UserPttReleased >(GetArena());
  }
  return payload_.user_ptt_released_;
}
inline ::atc_proto::ClientToServer_UserPttReleased* ClientToServer::mutable_user_ptt_released() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ClientToServer.user_ptt_released)
  return _internal_mutable_user_ptt_released();
}

inline bool ClientToServer::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void ClientToServer::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline ClientToServer::PayloadCase ClientToServer::payload_case() const {
  return ClientToServer::PayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ServerToClient_FaultDeclined

// string message = 1;
inline void ServerToClient_FaultDeclined::clear_message() {
  message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ServerToClient_FaultDeclined::message() const {
  // @@protoc_insertion_point(field_get:atc_proto.ServerToClient.FaultDeclined.message)
  return _internal_message();
}
inline void ServerToClient_FaultDeclined::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:atc_proto.ServerToClient.FaultDeclined.message)
}
inline std::string* ServerToClient_FaultDeclined::mutable_message() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ServerToClient.FaultDeclined.message)
  return _internal_mutable_message();
}
inline const std::string& ServerToClient_FaultDeclined::_internal_message() const {
  return message_.Get();
}
inline void ServerToClient_FaultDeclined::_internal_set_message(const std::string& value) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ServerToClient_FaultDeclined::set_message(std::string&& value) {
  
  message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:atc_proto.ServerToClient.FaultDeclined.message)
}
inline void ServerToClient_FaultDeclined::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:atc_proto.ServerToClient.FaultDeclined.message)
}
inline void ServerToClient_FaultDeclined::set_message(const char* value,
    size_t size) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:atc_proto.ServerToClient.FaultDeclined.message)
}
inline std::string* ServerToClient_FaultDeclined::_internal_mutable_message() {
  
  return message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ServerToClient_FaultDeclined::release_message() {
  // @@protoc_insertion_point(field_release:atc_proto.ServerToClient.FaultDeclined.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ServerToClient_FaultDeclined::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:atc_proto.ServerToClient.FaultDeclined.message)
}

// -------------------------------------------------------------------

// ServerToClient_FaultNotFound

// string message = 1;
inline void ServerToClient_FaultNotFound::clear_message() {
  message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ServerToClient_FaultNotFound::message() const {
  // @@protoc_insertion_point(field_get:atc_proto.ServerToClient.FaultNotFound.message)
  return _internal_message();
}
inline void ServerToClient_FaultNotFound::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:atc_proto.ServerToClient.FaultNotFound.message)
}
inline std::string* ServerToClient_FaultNotFound::mutable_message() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ServerToClient.FaultNotFound.message)
  return _internal_mutable_message();
}
inline const std::string& ServerToClient_FaultNotFound::_internal_message() const {
  return message_.Get();
}
inline void ServerToClient_FaultNotFound::_internal_set_message(const std::string& value) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ServerToClient_FaultNotFound::set_message(std::string&& value) {
  
  message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:atc_proto.ServerToClient.FaultNotFound.message)
}
inline void ServerToClient_FaultNotFound::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:atc_proto.ServerToClient.FaultNotFound.message)
}
inline void ServerToClient_FaultNotFound::set_message(const char* value,
    size_t size) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:atc_proto.ServerToClient.FaultNotFound.message)
}
inline std::string* ServerToClient_FaultNotFound::_internal_mutable_message() {
  
  return message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ServerToClient_FaultNotFound::release_message() {
  // @@protoc_insertion_point(field_release:atc_proto.ServerToClient.FaultNotFound.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ServerToClient_FaultNotFound::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:atc_proto.ServerToClient.FaultNotFound.message)
}

// -------------------------------------------------------------------

// ServerToClient_ReplyConnect

// string server_banner = 2;
inline void ServerToClient_ReplyConnect::clear_server_banner() {
  server_banner_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ServerToClient_ReplyConnect::server_banner() const {
  // @@protoc_insertion_point(field_get:atc_proto.ServerToClient.ReplyConnect.server_banner)
  return _internal_server_banner();
}
inline void ServerToClient_ReplyConnect::set_server_banner(const std::string& value) {
  _internal_set_server_banner(value);
  // @@protoc_insertion_point(field_set:atc_proto.ServerToClient.ReplyConnect.server_banner)
}
inline std::string* ServerToClient_ReplyConnect::mutable_server_banner() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ServerToClient.ReplyConnect.server_banner)
  return _internal_mutable_server_banner();
}
inline const std::string& ServerToClient_ReplyConnect::_internal_server_banner() const {
  return server_banner_.Get();
}
inline void ServerToClient_ReplyConnect::_internal_set_server_banner(const std::string& value) {
  
  server_banner_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ServerToClient_ReplyConnect::set_server_banner(std::string&& value) {
  
  server_banner_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:atc_proto.ServerToClient.ReplyConnect.server_banner)
}
inline void ServerToClient_ReplyConnect::set_server_banner(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  server_banner_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:atc_proto.ServerToClient.ReplyConnect.server_banner)
}
inline void ServerToClient_ReplyConnect::set_server_banner(const char* value,
    size_t size) {
  
  server_banner_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:atc_proto.ServerToClient.ReplyConnect.server_banner)
}
inline std::string* ServerToClient_ReplyConnect::_internal_mutable_server_banner() {
  
  return server_banner_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ServerToClient_ReplyConnect::release_server_banner() {
  // @@protoc_insertion_point(field_release:atc_proto.ServerToClient.ReplyConnect.server_banner)
  return server_banner_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ServerToClient_ReplyConnect::set_allocated_server_banner(std::string* server_banner) {
  if (server_banner != nullptr) {
    
  } else {
    
  }
  server_banner_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), server_banner,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:atc_proto.ServerToClient.ReplyConnect.server_banner)
}

// -------------------------------------------------------------------

// ServerToClient_ReplyCreateAircraft

// uint32 created_aircraft_id = 1;
inline void ServerToClient_ReplyCreateAircraft::clear_created_aircraft_id() {
  created_aircraft_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ServerToClient_ReplyCreateAircraft::_internal_created_aircraft_id() const {
  return created_aircraft_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ServerToClient_ReplyCreateAircraft::created_aircraft_id() const {
  // @@protoc_insertion_point(field_get:atc_proto.ServerToClient.ReplyCreateAircraft.created_aircraft_id)
  return _internal_created_aircraft_id();
}
inline void ServerToClient_ReplyCreateAircraft::_internal_set_created_aircraft_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  created_aircraft_id_ = value;
}
inline void ServerToClient_ReplyCreateAircraft::set_created_aircraft_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_created_aircraft_id(value);
  // @@protoc_insertion_point(field_set:atc_proto.ServerToClient.ReplyCreateAircraft.created_aircraft_id)
}

// -------------------------------------------------------------------

// ServerToClient_ReplyQueryAirport

// .atc_proto.AirportMessage airport = 1;
inline bool ServerToClient_ReplyQueryAirport::_internal_has_airport() const {
  return this != internal_default_instance() && airport_ != nullptr;
}
inline bool ServerToClient_ReplyQueryAirport::has_airport() const {
  return _internal_has_airport();
}
inline void ServerToClient_ReplyQueryAirport::clear_airport() {
  if (GetArena() == nullptr && airport_ != nullptr) {
    delete airport_;
  }
  airport_ = nullptr;
}
inline const ::atc_proto::AirportMessage& ServerToClient_ReplyQueryAirport::_internal_airport() const {
  const ::atc_proto::AirportMessage* p = airport_;
  return p != nullptr ? *p : *reinterpret_cast<const ::atc_proto::AirportMessage*>(
      &::atc_proto::_AirportMessage_default_instance_);
}
inline const ::atc_proto::AirportMessage& ServerToClient_ReplyQueryAirport::airport() const {
  // @@protoc_insertion_point(field_get:atc_proto.ServerToClient.ReplyQueryAirport.airport)
  return _internal_airport();
}
inline void ServerToClient_ReplyQueryAirport::unsafe_arena_set_allocated_airport(
    ::atc_proto::AirportMessage* airport) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(airport_);
  }
  airport_ = airport;
  if (airport) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.ServerToClient.ReplyQueryAirport.airport)
}
inline ::atc_proto::AirportMessage* ServerToClient_ReplyQueryAirport::release_airport() {
  
  ::atc_proto::AirportMessage* temp = airport_;
  airport_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::atc_proto::AirportMessage* ServerToClient_ReplyQueryAirport::unsafe_arena_release_airport() {
  // @@protoc_insertion_point(field_release:atc_proto.ServerToClient.ReplyQueryAirport.airport)
  
  ::atc_proto::AirportMessage* temp = airport_;
  airport_ = nullptr;
  return temp;
}
inline ::atc_proto::AirportMessage* ServerToClient_ReplyQueryAirport::_internal_mutable_airport() {
  
  if (airport_ == nullptr) {
    auto* p = CreateMaybeMessage<::atc_proto::AirportMessage>(GetArena());
    airport_ = p;
  }
  return airport_;
}
inline ::atc_proto::AirportMessage* ServerToClient_ReplyQueryAirport::mutable_airport() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ServerToClient.ReplyQueryAirport.airport)
  return _internal_mutable_airport();
}
inline void ServerToClient_ReplyQueryAirport::set_allocated_airport(::atc_proto::AirportMessage* airport) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete airport_;
  }
  if (airport) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(airport);
    if (message_arena != submessage_arena) {
      airport = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, airport, submessage_arena);
    }
    
  } else {
    
  }
  airport_ = airport;
  // @@protoc_insertion_point(field_set_allocated:atc_proto.ServerToClient.ReplyQueryAirport.airport)
}

// -------------------------------------------------------------------

// ServerToClient_ReplyQueryTaxiPath

// bool success = 1;
inline void ServerToClient_ReplyQueryTaxiPath::clear_success() {
  success_ = false;
}
inline bool ServerToClient_ReplyQueryTaxiPath::_internal_success() const {
  return success_;
}
inline bool ServerToClient_ReplyQueryTaxiPath::success() const {
  // @@protoc_insertion_point(field_get:atc_proto.ServerToClient.ReplyQueryTaxiPath.success)
  return _internal_success();
}
inline void ServerToClient_ReplyQueryTaxiPath::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void ServerToClient_ReplyQueryTaxiPath::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:atc_proto.ServerToClient.ReplyQueryTaxiPath.success)
}

// .atc_proto.TaxiPathMessage taxi_path = 2;
inline bool ServerToClient_ReplyQueryTaxiPath::_internal_has_taxi_path() const {
  return this != internal_default_instance() && taxi_path_ != nullptr;
}
inline bool ServerToClient_ReplyQueryTaxiPath::has_taxi_path() const {
  return _internal_has_taxi_path();
}
inline void ServerToClient_ReplyQueryTaxiPath::clear_taxi_path() {
  if (GetArena() == nullptr && taxi_path_ != nullptr) {
    delete taxi_path_;
  }
  taxi_path_ = nullptr;
}
inline const ::atc_proto::TaxiPathMessage& ServerToClient_ReplyQueryTaxiPath::_internal_taxi_path() const {
  const ::atc_proto::TaxiPathMessage* p = taxi_path_;
  return p != nullptr ? *p : *reinterpret_cast<const ::atc_proto::TaxiPathMessage*>(
      &::atc_proto::_TaxiPathMessage_default_instance_);
}
inline const ::atc_proto::TaxiPathMessage& ServerToClient_ReplyQueryTaxiPath::taxi_path() const {
  // @@protoc_insertion_point(field_get:atc_proto.ServerToClient.ReplyQueryTaxiPath.taxi_path)
  return _internal_taxi_path();
}
inline void ServerToClient_ReplyQueryTaxiPath::unsafe_arena_set_allocated_taxi_path(
    ::atc_proto::TaxiPathMessage* taxi_path) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(taxi_path_);
  }
  taxi_path_ = taxi_path;
  if (taxi_path) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.ServerToClient.ReplyQueryTaxiPath.taxi_path)
}
inline ::atc_proto::TaxiPathMessage* ServerToClient_ReplyQueryTaxiPath::release_taxi_path() {
  
  ::atc_proto::TaxiPathMessage* temp = taxi_path_;
  taxi_path_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::atc_proto::TaxiPathMessage* ServerToClient_ReplyQueryTaxiPath::unsafe_arena_release_taxi_path() {
  // @@protoc_insertion_point(field_release:atc_proto.ServerToClient.ReplyQueryTaxiPath.taxi_path)
  
  ::atc_proto::TaxiPathMessage* temp = taxi_path_;
  taxi_path_ = nullptr;
  return temp;
}
inline ::atc_proto::TaxiPathMessage* ServerToClient_ReplyQueryTaxiPath::_internal_mutable_taxi_path() {
  
  if (taxi_path_ == nullptr) {
    auto* p = CreateMaybeMessage<::atc_proto::TaxiPathMessage>(GetArena());
    taxi_path_ = p;
  }
  return taxi_path_;
}
inline ::atc_proto::TaxiPathMessage* ServerToClient_ReplyQueryTaxiPath::mutable_taxi_path() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ServerToClient.ReplyQueryTaxiPath.taxi_path)
  return _internal_mutable_taxi_path();
}
inline void ServerToClient_ReplyQueryTaxiPath::set_allocated_taxi_path(::atc_proto::TaxiPathMessage* taxi_path) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete taxi_path_;
  }
  if (taxi_path) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(taxi_path);
    if (message_arena != submessage_arena) {
      taxi_path = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, taxi_path, submessage_arena);
    }
    
  } else {
    
  }
  taxi_path_ = taxi_path;
  // @@protoc_insertion_point(field_set_allocated:atc_proto.ServerToClient.ReplyQueryTaxiPath.taxi_path)
}

// -------------------------------------------------------------------

// ServerToClient_ReplyQueryTraffic

// double min_lat = 1;
inline void ServerToClient_ReplyQueryTraffic::clear_min_lat() {
  min_lat_ = 0;
}
inline double ServerToClient_ReplyQueryTraffic::_internal_min_lat() const {
  return min_lat_;
}
inline double ServerToClient_ReplyQueryTraffic::min_lat() const {
  // @@protoc_insertion_point(field_get:atc_proto.ServerToClient.ReplyQueryTraffic.min_lat)
  return _internal_min_lat();
}
inline void ServerToClient_ReplyQueryTraffic::_internal_set_min_lat(double value) {
  
  min_lat_ = value;
}
inline void ServerToClient_ReplyQueryTraffic::set_min_lat(double value) {
  _internal_set_min_lat(value);
  // @@protoc_insertion_point(field_set:atc_proto.ServerToClient.ReplyQueryTraffic.min_lat)
}

// double min_lon = 2;
inline void ServerToClient_ReplyQueryTraffic::clear_min_lon() {
  min_lon_ = 0;
}
inline double ServerToClient_ReplyQueryTraffic::_internal_min_lon() const {
  return min_lon_;
}
inline double ServerToClient_ReplyQueryTraffic::min_lon() const {
  // @@protoc_insertion_point(field_get:atc_proto.ServerToClient.ReplyQueryTraffic.min_lon)
  return _internal_min_lon();
}
inline void ServerToClient_ReplyQueryTraffic::_internal_set_min_lon(double value) {
  
  min_lon_ = value;
}
inline void ServerToClient_ReplyQueryTraffic::set_min_lon(double value) {
  _internal_set_min_lon(value);
  // @@protoc_insertion_point(field_set:atc_proto.ServerToClient.ReplyQueryTraffic.min_lon)
}

// double max_lat = 3;
inline void ServerToClient_ReplyQueryTraffic::clear_max_lat() {
  max_lat_ = 0;
}
inline double ServerToClient_ReplyQueryTraffic::_internal_max_lat() const {
  return max_lat_;
}
inline double ServerToClient_ReplyQueryTraffic::max_lat() const {
  // @@protoc_insertion_point(field_get:atc_proto.ServerToClient.ReplyQueryTraffic.max_lat)
  return _internal_max_lat();
}
inline void ServerToClient_ReplyQueryTraffic::_internal_set_max_lat(double value) {
  
  max_lat_ = value;
}
inline void ServerToClient_ReplyQueryTraffic::set_max_lat(double value) {
  _internal_set_max_lat(value);
  // @@protoc_insertion_point(field_set:atc_proto.ServerToClient.ReplyQueryTraffic.max_lat)
}

// double max_lon = 4;
inline void ServerToClient_ReplyQueryTraffic::clear_max_lon() {
  max_lon_ = 0;
}
inline double ServerToClient_ReplyQueryTraffic::_internal_max_lon() const {
  return max_lon_;
}
inline double ServerToClient_ReplyQueryTraffic::max_lon() const {
  // @@protoc_insertion_point(field_get:atc_proto.ServerToClient.ReplyQueryTraffic.max_lon)
  return _internal_max_lon();
}
inline void ServerToClient_ReplyQueryTraffic::_internal_set_max_lon(double value) {
  
  max_lon_ = value;
}
inline void ServerToClient_ReplyQueryTraffic::set_max_lon(double value) {
  _internal_set_max_lon(value);
  // @@protoc_insertion_point(field_set:atc_proto.ServerToClient.ReplyQueryTraffic.max_lon)
}

// repeated .atc_proto.AircraftMessage traffic_batch = 5;
inline int ServerToClient_ReplyQueryTraffic::_internal_traffic_batch_size() const {
  return traffic_batch_.size();
}
inline int ServerToClient_ReplyQueryTraffic::traffic_batch_size() const {
  return _internal_traffic_batch_size();
}
inline void ServerToClient_ReplyQueryTraffic::clear_traffic_batch() {
  traffic_batch_.Clear();
}
inline ::atc_proto::AircraftMessage* ServerToClient_ReplyQueryTraffic::mutable_traffic_batch(int index) {
  // @@protoc_insertion_point(field_mutable:atc_proto.ServerToClient.ReplyQueryTraffic.traffic_batch)
  return traffic_batch_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::atc_proto::AircraftMessage >*
ServerToClient_ReplyQueryTraffic::mutable_traffic_batch() {
  // @@protoc_insertion_point(field_mutable_list:atc_proto.ServerToClient.ReplyQueryTraffic.traffic_batch)
  return &traffic_batch_;
}
inline const ::atc_proto::AircraftMessage& ServerToClient_ReplyQueryTraffic::_internal_traffic_batch(int index) const {
  return traffic_batch_.Get(index);
}
inline const ::atc_proto::AircraftMessage& ServerToClient_ReplyQueryTraffic::traffic_batch(int index) const {
  // @@protoc_insertion_point(field_get:atc_proto.ServerToClient.ReplyQueryTraffic.traffic_batch)
  return _internal_traffic_batch(index);
}
inline ::atc_proto::AircraftMessage* ServerToClient_ReplyQueryTraffic::_internal_add_traffic_batch() {
  return traffic_batch_.Add();
}
inline ::atc_proto::AircraftMessage* ServerToClient_ReplyQueryTraffic::add_traffic_batch() {
  // @@protoc_insertion_point(field_add:atc_proto.ServerToClient.ReplyQueryTraffic.traffic_batch)
  return _internal_add_traffic_batch();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::atc_proto::AircraftMessage >&
ServerToClient_ReplyQueryTraffic::traffic_batch() const {
  // @@protoc_insertion_point(field_list:atc_proto.ServerToClient.ReplyQueryTraffic.traffic_batch)
  return traffic_batch_;
}

// bool is_last_batch = 6;
inline void ServerToClient_ReplyQueryTraffic::clear_is_last_batch() {
  is_last_batch_ = false;
}
inline bool ServerToClient_ReplyQueryTraffic::_internal_is_last_batch() const {
  return is_last_batch_;
}
inline bool ServerToClient_ReplyQueryTraffic::is_last_batch() const {
  // @@protoc_insertion_point(field_get:atc_proto.ServerToClient.ReplyQueryTraffic.is_last_batch)
  return _internal_is_last_batch();
}
inline void ServerToClient_ReplyQueryTraffic::_internal_set_is_last_batch(bool value) {
  
  is_last_batch_ = value;
}
inline void ServerToClient_ReplyQueryTraffic::set_is_last_batch(bool value) {
  _internal_set_is_last_batch(value);
  // @@protoc_insertion_point(field_set:atc_proto.ServerToClient.ReplyQueryTraffic.is_last_batch)
}

// -------------------------------------------------------------------

// ServerToClient_NotifyAircraftCreated

// .atc_proto.AircraftMessage aircraft = 1;
inline bool ServerToClient_NotifyAircraftCreated::_internal_has_aircraft() const {
  return this != internal_default_instance() && aircraft_ != nullptr;
}
inline bool ServerToClient_NotifyAircraftCreated::has_aircraft() const {
  return _internal_has_aircraft();
}
inline void ServerToClient_NotifyAircraftCreated::clear_aircraft() {
  if (GetArena() == nullptr && aircraft_ != nullptr) {
    delete aircraft_;
  }
  aircraft_ = nullptr;
}
inline const ::atc_proto::AircraftMessage& ServerToClient_NotifyAircraftCreated::_internal_aircraft() const {
  const ::atc_proto::AircraftMessage* p = aircraft_;
  return p != nullptr ? *p : *reinterpret_cast<const ::atc_proto::AircraftMessage*>(
      &::atc_proto::_AircraftMessage_default_instance_);
}
inline const ::atc_proto::AircraftMessage& ServerToClient_NotifyAircraftCreated::aircraft() const {
  // @@protoc_insertion_point(field_get:atc_proto.ServerToClient.NotifyAircraftCreated.aircraft)
  return _internal_aircraft();
}
inline void ServerToClient_NotifyAircraftCreated::unsafe_arena_set_allocated_aircraft(
    ::atc_proto::AircraftMessage* aircraft) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(aircraft_);
  }
  aircraft_ = aircraft;
  if (aircraft) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.ServerToClient.NotifyAircraftCreated.aircraft)
}
inline ::atc_proto::AircraftMessage* ServerToClient_NotifyAircraftCreated::release_aircraft() {
  
  ::atc_proto::AircraftMessage* temp = aircraft_;
  aircraft_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::atc_proto::AircraftMessage* ServerToClient_NotifyAircraftCreated::unsafe_arena_release_aircraft() {
  // @@protoc_insertion_point(field_release:atc_proto.ServerToClient.NotifyAircraftCreated.aircraft)
  
  ::atc_proto::AircraftMessage* temp = aircraft_;
  aircraft_ = nullptr;
  return temp;
}
inline ::atc_proto::AircraftMessage* ServerToClient_NotifyAircraftCreated::_internal_mutable_aircraft() {
  
  if (aircraft_ == nullptr) {
    auto* p = CreateMaybeMessage<::atc_proto::AircraftMessage>(GetArena());
    aircraft_ = p;
  }
  return aircraft_;
}
inline ::atc_proto::AircraftMessage* ServerToClient_NotifyAircraftCreated::mutable_aircraft() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ServerToClient.NotifyAircraftCreated.aircraft)
  return _internal_mutable_aircraft();
}
inline void ServerToClient_NotifyAircraftCreated::set_allocated_aircraft(::atc_proto::AircraftMessage* aircraft) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete aircraft_;
  }
  if (aircraft) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(aircraft);
    if (message_arena != submessage_arena) {
      aircraft = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, aircraft, submessage_arena);
    }
    
  } else {
    
  }
  aircraft_ = aircraft;
  // @@protoc_insertion_point(field_set_allocated:atc_proto.ServerToClient.NotifyAircraftCreated.aircraft)
}

// -------------------------------------------------------------------

// ServerToClient_NotifyAircraftSituationUpdated

// uint32 aircraft_id = 1;
inline void ServerToClient_NotifyAircraftSituationUpdated::clear_aircraft_id() {
  aircraft_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ServerToClient_NotifyAircraftSituationUpdated::_internal_aircraft_id() const {
  return aircraft_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ServerToClient_NotifyAircraftSituationUpdated::aircraft_id() const {
  // @@protoc_insertion_point(field_get:atc_proto.ServerToClient.NotifyAircraftSituationUpdated.aircraft_id)
  return _internal_aircraft_id();
}
inline void ServerToClient_NotifyAircraftSituationUpdated::_internal_set_aircraft_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  aircraft_id_ = value;
}
inline void ServerToClient_NotifyAircraftSituationUpdated::set_aircraft_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_aircraft_id(value);
  // @@protoc_insertion_point(field_set:atc_proto.ServerToClient.NotifyAircraftSituationUpdated.aircraft_id)
}

// .atc_proto.AircraftMessage.Situation situation = 2;
inline bool ServerToClient_NotifyAircraftSituationUpdated::_internal_has_situation() const {
  return this != internal_default_instance() && situation_ != nullptr;
}
inline bool ServerToClient_NotifyAircraftSituationUpdated::has_situation() const {
  return _internal_has_situation();
}
inline void ServerToClient_NotifyAircraftSituationUpdated::clear_situation() {
  if (GetArena() == nullptr && situation_ != nullptr) {
    delete situation_;
  }
  situation_ = nullptr;
}
inline const ::atc_proto::AircraftMessage_Situation& ServerToClient_NotifyAircraftSituationUpdated::_internal_situation() const {
  const ::atc_proto::AircraftMessage_Situation* p = situation_;
  return p != nullptr ? *p : *reinterpret_cast<const ::atc_proto::AircraftMessage_Situation*>(
      &::atc_proto::_AircraftMessage_Situation_default_instance_);
}
inline const ::atc_proto::AircraftMessage_Situation& ServerToClient_NotifyAircraftSituationUpdated::situation() const {
  // @@protoc_insertion_point(field_get:atc_proto.ServerToClient.NotifyAircraftSituationUpdated.situation)
  return _internal_situation();
}
inline void ServerToClient_NotifyAircraftSituationUpdated::unsafe_arena_set_allocated_situation(
    ::atc_proto::AircraftMessage_Situation* situation) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(situation_);
  }
  situation_ = situation;
  if (situation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.ServerToClient.NotifyAircraftSituationUpdated.situation)
}
inline ::atc_proto::AircraftMessage_Situation* ServerToClient_NotifyAircraftSituationUpdated::release_situation() {
  
  ::atc_proto::AircraftMessage_Situation* temp = situation_;
  situation_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::atc_proto::AircraftMessage_Situation* ServerToClient_NotifyAircraftSituationUpdated::unsafe_arena_release_situation() {
  // @@protoc_insertion_point(field_release:atc_proto.ServerToClient.NotifyAircraftSituationUpdated.situation)
  
  ::atc_proto::AircraftMessage_Situation* temp = situation_;
  situation_ = nullptr;
  return temp;
}
inline ::atc_proto::AircraftMessage_Situation* ServerToClient_NotifyAircraftSituationUpdated::_internal_mutable_situation() {
  
  if (situation_ == nullptr) {
    auto* p = CreateMaybeMessage<::atc_proto::AircraftMessage_Situation>(GetArena());
    situation_ = p;
  }
  return situation_;
}
inline ::atc_proto::AircraftMessage_Situation* ServerToClient_NotifyAircraftSituationUpdated::mutable_situation() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ServerToClient.NotifyAircraftSituationUpdated.situation)
  return _internal_mutable_situation();
}
inline void ServerToClient_NotifyAircraftSituationUpdated::set_allocated_situation(::atc_proto::AircraftMessage_Situation* situation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete situation_;
  }
  if (situation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(situation);
    if (message_arena != submessage_arena) {
      situation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, situation, submessage_arena);
    }
    
  } else {
    
  }
  situation_ = situation;
  // @@protoc_insertion_point(field_set_allocated:atc_proto.ServerToClient.NotifyAircraftSituationUpdated.situation)
}

// -------------------------------------------------------------------

// ServerToClient_NotifyAircraftRemoved

// uint32 aircraft_id = 1;
inline void ServerToClient_NotifyAircraftRemoved::clear_aircraft_id() {
  aircraft_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ServerToClient_NotifyAircraftRemoved::_internal_aircraft_id() const {
  return aircraft_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ServerToClient_NotifyAircraftRemoved::aircraft_id() const {
  // @@protoc_insertion_point(field_get:atc_proto.ServerToClient.NotifyAircraftRemoved.aircraft_id)
  return _internal_aircraft_id();
}
inline void ServerToClient_NotifyAircraftRemoved::_internal_set_aircraft_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  aircraft_id_ = value;
}
inline void ServerToClient_NotifyAircraftRemoved::set_aircraft_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_aircraft_id(value);
  // @@protoc_insertion_point(field_set:atc_proto.ServerToClient.NotifyAircraftRemoved.aircraft_id)
}

// -------------------------------------------------------------------

// ServerToClient_ReplyUserAcquireAircraft

// uint32 aircraft_id = 1;
inline void ServerToClient_ReplyUserAcquireAircraft::clear_aircraft_id() {
  aircraft_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ServerToClient_ReplyUserAcquireAircraft::_internal_aircraft_id() const {
  return aircraft_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ServerToClient_ReplyUserAcquireAircraft::aircraft_id() const {
  // @@protoc_insertion_point(field_get:atc_proto.ServerToClient.ReplyUserAcquireAircraft.aircraft_id)
  return _internal_aircraft_id();
}
inline void ServerToClient_ReplyUserAcquireAircraft::_internal_set_aircraft_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  aircraft_id_ = value;
}
inline void ServerToClient_ReplyUserAcquireAircraft::set_aircraft_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_aircraft_id(value);
  // @@protoc_insertion_point(field_set:atc_proto.ServerToClient.ReplyUserAcquireAircraft.aircraft_id)
}

// bool success = 2;
inline void ServerToClient_ReplyUserAcquireAircraft::clear_success() {
  success_ = false;
}
inline bool ServerToClient_ReplyUserAcquireAircraft::_internal_success() const {
  return success_;
}
inline bool ServerToClient_ReplyUserAcquireAircraft::success() const {
  // @@protoc_insertion_point(field_get:atc_proto.ServerToClient.ReplyUserAcquireAircraft.success)
  return _internal_success();
}
inline void ServerToClient_ReplyUserAcquireAircraft::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void ServerToClient_ReplyUserAcquireAircraft::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:atc_proto.ServerToClient.ReplyUserAcquireAircraft.success)
}

// -------------------------------------------------------------------

// ServerToClient

// uint64 id = 2;
inline void ServerToClient::clear_id() {
  id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ServerToClient::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ServerToClient::id() const {
  // @@protoc_insertion_point(field_get:atc_proto.ServerToClient.id)
  return _internal_id();
}
inline void ServerToClient::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  id_ = value;
}
inline void ServerToClient::set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:atc_proto.ServerToClient.id)
}

// uint64 reply_to_request_id = 3;
inline void ServerToClient::clear_reply_to_request_id() {
  reply_to_request_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ServerToClient::_internal_reply_to_request_id() const {
  return reply_to_request_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ServerToClient::reply_to_request_id() const {
  // @@protoc_insertion_point(field_get:atc_proto.ServerToClient.reply_to_request_id)
  return _internal_reply_to_request_id();
}
inline void ServerToClient::_internal_set_reply_to_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  reply_to_request_id_ = value;
}
inline void ServerToClient::set_reply_to_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_reply_to_request_id(value);
  // @@protoc_insertion_point(field_set:atc_proto.ServerToClient.reply_to_request_id)
}

// .google.protobuf.Timestamp sent_at = 4;
inline bool ServerToClient::_internal_has_sent_at() const {
  return this != internal_default_instance() && sent_at_ != nullptr;
}
inline bool ServerToClient::has_sent_at() const {
  return _internal_has_sent_at();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ServerToClient::_internal_sent_at() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = sent_at_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ServerToClient::sent_at() const {
  // @@protoc_insertion_point(field_get:atc_proto.ServerToClient.sent_at)
  return _internal_sent_at();
}
inline void ServerToClient::unsafe_arena_set_allocated_sent_at(
    PROTOBUF_NAMESPACE_ID::Timestamp* sent_at) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sent_at_);
  }
  sent_at_ = sent_at;
  if (sent_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.ServerToClient.sent_at)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ServerToClient::release_sent_at() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = sent_at_;
  sent_at_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ServerToClient::unsafe_arena_release_sent_at() {
  // @@protoc_insertion_point(field_release:atc_proto.ServerToClient.sent_at)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = sent_at_;
  sent_at_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ServerToClient::_internal_mutable_sent_at() {
  
  if (sent_at_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    sent_at_ = p;
  }
  return sent_at_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ServerToClient::mutable_sent_at() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ServerToClient.sent_at)
  return _internal_mutable_sent_at();
}
inline void ServerToClient::set_allocated_sent_at(PROTOBUF_NAMESPACE_ID::Timestamp* sent_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(sent_at_);
  }
  if (sent_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sent_at)->GetArena();
    if (message_arena != submessage_arena) {
      sent_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sent_at, submessage_arena);
    }
    
  } else {
    
  }
  sent_at_ = sent_at;
  // @@protoc_insertion_point(field_set_allocated:atc_proto.ServerToClient.sent_at)
}

// .google.protobuf.Timestamp request_sent_at = 5;
inline bool ServerToClient::_internal_has_request_sent_at() const {
  return this != internal_default_instance() && request_sent_at_ != nullptr;
}
inline bool ServerToClient::has_request_sent_at() const {
  return _internal_has_request_sent_at();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ServerToClient::_internal_request_sent_at() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = request_sent_at_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ServerToClient::request_sent_at() const {
  // @@protoc_insertion_point(field_get:atc_proto.ServerToClient.request_sent_at)
  return _internal_request_sent_at();
}
inline void ServerToClient::unsafe_arena_set_allocated_request_sent_at(
    PROTOBUF_NAMESPACE_ID::Timestamp* request_sent_at) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request_sent_at_);
  }
  request_sent_at_ = request_sent_at;
  if (request_sent_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.ServerToClient.request_sent_at)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ServerToClient::release_request_sent_at() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = request_sent_at_;
  request_sent_at_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ServerToClient::unsafe_arena_release_request_sent_at() {
  // @@protoc_insertion_point(field_release:atc_proto.ServerToClient.request_sent_at)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = request_sent_at_;
  request_sent_at_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ServerToClient::_internal_mutable_request_sent_at() {
  
  if (request_sent_at_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    request_sent_at_ = p;
  }
  return request_sent_at_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ServerToClient::mutable_request_sent_at() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ServerToClient.request_sent_at)
  return _internal_mutable_request_sent_at();
}
inline void ServerToClient::set_allocated_request_sent_at(PROTOBUF_NAMESPACE_ID::Timestamp* request_sent_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(request_sent_at_);
  }
  if (request_sent_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request_sent_at)->GetArena();
    if (message_arena != submessage_arena) {
      request_sent_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request_sent_at, submessage_arena);
    }
    
  } else {
    
  }
  request_sent_at_ = request_sent_at;
  // @@protoc_insertion_point(field_set_allocated:atc_proto.ServerToClient.request_sent_at)
}

// .google.protobuf.Timestamp request_received_at = 6;
inline bool ServerToClient::_internal_has_request_received_at() const {
  return this != internal_default_instance() && request_received_at_ != nullptr;
}
inline bool ServerToClient::has_request_received_at() const {
  return _internal_has_request_received_at();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ServerToClient::_internal_request_received_at() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = request_received_at_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ServerToClient::request_received_at() const {
  // @@protoc_insertion_point(field_get:atc_proto.ServerToClient.request_received_at)
  return _internal_request_received_at();
}
inline void ServerToClient::unsafe_arena_set_allocated_request_received_at(
    PROTOBUF_NAMESPACE_ID::Timestamp* request_received_at) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request_received_at_);
  }
  request_received_at_ = request_received_at;
  if (request_received_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.ServerToClient.request_received_at)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ServerToClient::release_request_received_at() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = request_received_at_;
  request_received_at_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ServerToClient::unsafe_arena_release_request_received_at() {
  // @@protoc_insertion_point(field_release:atc_proto.ServerToClient.request_received_at)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = request_received_at_;
  request_received_at_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ServerToClient::_internal_mutable_request_received_at() {
  
  if (request_received_at_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    request_received_at_ = p;
  }
  return request_received_at_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ServerToClient::mutable_request_received_at() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ServerToClient.request_received_at)
  return _internal_mutable_request_received_at();
}
inline void ServerToClient::set_allocated_request_received_at(PROTOBUF_NAMESPACE_ID::Timestamp* request_received_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(request_received_at_);
  }
  if (request_received_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request_received_at)->GetArena();
    if (message_arena != submessage_arena) {
      request_received_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request_received_at, submessage_arena);
    }
    
  } else {
    
  }
  request_received_at_ = request_received_at;
  // @@protoc_insertion_point(field_set_allocated:atc_proto.ServerToClient.request_received_at)
}

// .atc_proto.ServerToClient.ReplyConnect reply_connect = 1101;
inline bool ServerToClient::_internal_has_reply_connect() const {
  return payload_case() == kReplyConnect;
}
inline bool ServerToClient::has_reply_connect() const {
  return _internal_has_reply_connect();
}
inline void ServerToClient::set_has_reply_connect() {
  _oneof_case_[0] = kReplyConnect;
}
inline void ServerToClient::clear_reply_connect() {
  if (_internal_has_reply_connect()) {
    if (GetArena() == nullptr) {
      delete payload_.reply_connect_;
    }
    clear_has_payload();
  }
}
inline ::atc_proto::ServerToClient_ReplyConnect* ServerToClient::release_reply_connect() {
  // @@protoc_insertion_point(field_release:atc_proto.ServerToClient.reply_connect)
  if (_internal_has_reply_connect()) {
    clear_has_payload();
      ::atc_proto::ServerToClient_ReplyConnect* temp = payload_.reply_connect_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.reply_connect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::atc_proto::ServerToClient_ReplyConnect& ServerToClient::_internal_reply_connect() const {
  return _internal_has_reply_connect()
      ? *payload_.reply_connect_
      : *reinterpret_cast< ::atc_proto::ServerToClient_ReplyConnect*>(&::atc_proto::_ServerToClient_ReplyConnect_default_instance_);
}
inline const ::atc_proto::ServerToClient_ReplyConnect& ServerToClient::reply_connect() const {
  // @@protoc_insertion_point(field_get:atc_proto.ServerToClient.reply_connect)
  return _internal_reply_connect();
}
inline ::atc_proto::ServerToClient_ReplyConnect* ServerToClient::unsafe_arena_release_reply_connect() {
  // @@protoc_insertion_point(field_unsafe_arena_release:atc_proto.ServerToClient.reply_connect)
  if (_internal_has_reply_connect()) {
    clear_has_payload();
    ::atc_proto::ServerToClient_ReplyConnect* temp = payload_.reply_connect_;
    payload_.reply_connect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerToClient::unsafe_arena_set_allocated_reply_connect(::atc_proto::ServerToClient_ReplyConnect* reply_connect) {
  clear_payload();
  if (reply_connect) {
    set_has_reply_connect();
    payload_.reply_connect_ = reply_connect;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.ServerToClient.reply_connect)
}
inline ::atc_proto::ServerToClient_ReplyConnect* ServerToClient::_internal_mutable_reply_connect() {
  if (!_internal_has_reply_connect()) {
    clear_payload();
    set_has_reply_connect();
    payload_.reply_connect_ = CreateMaybeMessage< ::atc_proto::ServerToClient_ReplyConnect >(GetArena());
  }
  return payload_.reply_connect_;
}
inline ::atc_proto::ServerToClient_ReplyConnect* ServerToClient::mutable_reply_connect() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ServerToClient.reply_connect)
  return _internal_mutable_reply_connect();
}

// .atc_proto.ServerToClient.ReplyQueryAirport reply_query_airport = 1102;
inline bool ServerToClient::_internal_has_reply_query_airport() const {
  return payload_case() == kReplyQueryAirport;
}
inline bool ServerToClient::has_reply_query_airport() const {
  return _internal_has_reply_query_airport();
}
inline void ServerToClient::set_has_reply_query_airport() {
  _oneof_case_[0] = kReplyQueryAirport;
}
inline void ServerToClient::clear_reply_query_airport() {
  if (_internal_has_reply_query_airport()) {
    if (GetArena() == nullptr) {
      delete payload_.reply_query_airport_;
    }
    clear_has_payload();
  }
}
inline ::atc_proto::ServerToClient_ReplyQueryAirport* ServerToClient::release_reply_query_airport() {
  // @@protoc_insertion_point(field_release:atc_proto.ServerToClient.reply_query_airport)
  if (_internal_has_reply_query_airport()) {
    clear_has_payload();
      ::atc_proto::ServerToClient_ReplyQueryAirport* temp = payload_.reply_query_airport_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.reply_query_airport_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::atc_proto::ServerToClient_ReplyQueryAirport& ServerToClient::_internal_reply_query_airport() const {
  return _internal_has_reply_query_airport()
      ? *payload_.reply_query_airport_
      : *reinterpret_cast< ::atc_proto::ServerToClient_ReplyQueryAirport*>(&::atc_proto::_ServerToClient_ReplyQueryAirport_default_instance_);
}
inline const ::atc_proto::ServerToClient_ReplyQueryAirport& ServerToClient::reply_query_airport() const {
  // @@protoc_insertion_point(field_get:atc_proto.ServerToClient.reply_query_airport)
  return _internal_reply_query_airport();
}
inline ::atc_proto::ServerToClient_ReplyQueryAirport* ServerToClient::unsafe_arena_release_reply_query_airport() {
  // @@protoc_insertion_point(field_unsafe_arena_release:atc_proto.ServerToClient.reply_query_airport)
  if (_internal_has_reply_query_airport()) {
    clear_has_payload();
    ::atc_proto::ServerToClient_ReplyQueryAirport* temp = payload_.reply_query_airport_;
    payload_.reply_query_airport_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerToClient::unsafe_arena_set_allocated_reply_query_airport(::atc_proto::ServerToClient_ReplyQueryAirport* reply_query_airport) {
  clear_payload();
  if (reply_query_airport) {
    set_has_reply_query_airport();
    payload_.reply_query_airport_ = reply_query_airport;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.ServerToClient.reply_query_airport)
}
inline ::atc_proto::ServerToClient_ReplyQueryAirport* ServerToClient::_internal_mutable_reply_query_airport() {
  if (!_internal_has_reply_query_airport()) {
    clear_payload();
    set_has_reply_query_airport();
    payload_.reply_query_airport_ = CreateMaybeMessage< ::atc_proto::ServerToClient_ReplyQueryAirport >(GetArena());
  }
  return payload_.reply_query_airport_;
}
inline ::atc_proto::ServerToClient_ReplyQueryAirport* ServerToClient::mutable_reply_query_airport() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ServerToClient.reply_query_airport)
  return _internal_mutable_reply_query_airport();
}

// .atc_proto.ServerToClient.ReplyCreateAircraft reply_create_aircraft = 1103;
inline bool ServerToClient::_internal_has_reply_create_aircraft() const {
  return payload_case() == kReplyCreateAircraft;
}
inline bool ServerToClient::has_reply_create_aircraft() const {
  return _internal_has_reply_create_aircraft();
}
inline void ServerToClient::set_has_reply_create_aircraft() {
  _oneof_case_[0] = kReplyCreateAircraft;
}
inline void ServerToClient::clear_reply_create_aircraft() {
  if (_internal_has_reply_create_aircraft()) {
    if (GetArena() == nullptr) {
      delete payload_.reply_create_aircraft_;
    }
    clear_has_payload();
  }
}
inline ::atc_proto::ServerToClient_ReplyCreateAircraft* ServerToClient::release_reply_create_aircraft() {
  // @@protoc_insertion_point(field_release:atc_proto.ServerToClient.reply_create_aircraft)
  if (_internal_has_reply_create_aircraft()) {
    clear_has_payload();
      ::atc_proto::ServerToClient_ReplyCreateAircraft* temp = payload_.reply_create_aircraft_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.reply_create_aircraft_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::atc_proto::ServerToClient_ReplyCreateAircraft& ServerToClient::_internal_reply_create_aircraft() const {
  return _internal_has_reply_create_aircraft()
      ? *payload_.reply_create_aircraft_
      : *reinterpret_cast< ::atc_proto::ServerToClient_ReplyCreateAircraft*>(&::atc_proto::_ServerToClient_ReplyCreateAircraft_default_instance_);
}
inline const ::atc_proto::ServerToClient_ReplyCreateAircraft& ServerToClient::reply_create_aircraft() const {
  // @@protoc_insertion_point(field_get:atc_proto.ServerToClient.reply_create_aircraft)
  return _internal_reply_create_aircraft();
}
inline ::atc_proto::ServerToClient_ReplyCreateAircraft* ServerToClient::unsafe_arena_release_reply_create_aircraft() {
  // @@protoc_insertion_point(field_unsafe_arena_release:atc_proto.ServerToClient.reply_create_aircraft)
  if (_internal_has_reply_create_aircraft()) {
    clear_has_payload();
    ::atc_proto::ServerToClient_ReplyCreateAircraft* temp = payload_.reply_create_aircraft_;
    payload_.reply_create_aircraft_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerToClient::unsafe_arena_set_allocated_reply_create_aircraft(::atc_proto::ServerToClient_ReplyCreateAircraft* reply_create_aircraft) {
  clear_payload();
  if (reply_create_aircraft) {
    set_has_reply_create_aircraft();
    payload_.reply_create_aircraft_ = reply_create_aircraft;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.ServerToClient.reply_create_aircraft)
}
inline ::atc_proto::ServerToClient_ReplyCreateAircraft* ServerToClient::_internal_mutable_reply_create_aircraft() {
  if (!_internal_has_reply_create_aircraft()) {
    clear_payload();
    set_has_reply_create_aircraft();
    payload_.reply_create_aircraft_ = CreateMaybeMessage< ::atc_proto::ServerToClient_ReplyCreateAircraft >(GetArena());
  }
  return payload_.reply_create_aircraft_;
}
inline ::atc_proto::ServerToClient_ReplyCreateAircraft* ServerToClient::mutable_reply_create_aircraft() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ServerToClient.reply_create_aircraft)
  return _internal_mutable_reply_create_aircraft();
}

// .atc_proto.ServerToClient.ReplyQueryTaxiPath reply_query_taxi_path = 1106;
inline bool ServerToClient::_internal_has_reply_query_taxi_path() const {
  return payload_case() == kReplyQueryTaxiPath;
}
inline bool ServerToClient::has_reply_query_taxi_path() const {
  return _internal_has_reply_query_taxi_path();
}
inline void ServerToClient::set_has_reply_query_taxi_path() {
  _oneof_case_[0] = kReplyQueryTaxiPath;
}
inline void ServerToClient::clear_reply_query_taxi_path() {
  if (_internal_has_reply_query_taxi_path()) {
    if (GetArena() == nullptr) {
      delete payload_.reply_query_taxi_path_;
    }
    clear_has_payload();
  }
}
inline ::atc_proto::ServerToClient_ReplyQueryTaxiPath* ServerToClient::release_reply_query_taxi_path() {
  // @@protoc_insertion_point(field_release:atc_proto.ServerToClient.reply_query_taxi_path)
  if (_internal_has_reply_query_taxi_path()) {
    clear_has_payload();
      ::atc_proto::ServerToClient_ReplyQueryTaxiPath* temp = payload_.reply_query_taxi_path_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.reply_query_taxi_path_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::atc_proto::ServerToClient_ReplyQueryTaxiPath& ServerToClient::_internal_reply_query_taxi_path() const {
  return _internal_has_reply_query_taxi_path()
      ? *payload_.reply_query_taxi_path_
      : *reinterpret_cast< ::atc_proto::ServerToClient_ReplyQueryTaxiPath*>(&::atc_proto::_ServerToClient_ReplyQueryTaxiPath_default_instance_);
}
inline const ::atc_proto::ServerToClient_ReplyQueryTaxiPath& ServerToClient::reply_query_taxi_path() const {
  // @@protoc_insertion_point(field_get:atc_proto.ServerToClient.reply_query_taxi_path)
  return _internal_reply_query_taxi_path();
}
inline ::atc_proto::ServerToClient_ReplyQueryTaxiPath* ServerToClient::unsafe_arena_release_reply_query_taxi_path() {
  // @@protoc_insertion_point(field_unsafe_arena_release:atc_proto.ServerToClient.reply_query_taxi_path)
  if (_internal_has_reply_query_taxi_path()) {
    clear_has_payload();
    ::atc_proto::ServerToClient_ReplyQueryTaxiPath* temp = payload_.reply_query_taxi_path_;
    payload_.reply_query_taxi_path_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerToClient::unsafe_arena_set_allocated_reply_query_taxi_path(::atc_proto::ServerToClient_ReplyQueryTaxiPath* reply_query_taxi_path) {
  clear_payload();
  if (reply_query_taxi_path) {
    set_has_reply_query_taxi_path();
    payload_.reply_query_taxi_path_ = reply_query_taxi_path;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.ServerToClient.reply_query_taxi_path)
}
inline ::atc_proto::ServerToClient_ReplyQueryTaxiPath* ServerToClient::_internal_mutable_reply_query_taxi_path() {
  if (!_internal_has_reply_query_taxi_path()) {
    clear_payload();
    set_has_reply_query_taxi_path();
    payload_.reply_query_taxi_path_ = CreateMaybeMessage< ::atc_proto::ServerToClient_ReplyQueryTaxiPath >(GetArena());
  }
  return payload_.reply_query_taxi_path_;
}
inline ::atc_proto::ServerToClient_ReplyQueryTaxiPath* ServerToClient::mutable_reply_query_taxi_path() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ServerToClient.reply_query_taxi_path)
  return _internal_mutable_reply_query_taxi_path();
}

// .atc_proto.ServerToClient.ReplyQueryTraffic reply_query_traffic = 1107;
inline bool ServerToClient::_internal_has_reply_query_traffic() const {
  return payload_case() == kReplyQueryTraffic;
}
inline bool ServerToClient::has_reply_query_traffic() const {
  return _internal_has_reply_query_traffic();
}
inline void ServerToClient::set_has_reply_query_traffic() {
  _oneof_case_[0] = kReplyQueryTraffic;
}
inline void ServerToClient::clear_reply_query_traffic() {
  if (_internal_has_reply_query_traffic()) {
    if (GetArena() == nullptr) {
      delete payload_.reply_query_traffic_;
    }
    clear_has_payload();
  }
}
inline ::atc_proto::ServerToClient_ReplyQueryTraffic* ServerToClient::release_reply_query_traffic() {
  // @@protoc_insertion_point(field_release:atc_proto.ServerToClient.reply_query_traffic)
  if (_internal_has_reply_query_traffic()) {
    clear_has_payload();
      ::atc_proto::ServerToClient_ReplyQueryTraffic* temp = payload_.reply_query_traffic_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.reply_query_traffic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::atc_proto::ServerToClient_ReplyQueryTraffic& ServerToClient::_internal_reply_query_traffic() const {
  return _internal_has_reply_query_traffic()
      ? *payload_.reply_query_traffic_
      : *reinterpret_cast< ::atc_proto::ServerToClient_ReplyQueryTraffic*>(&::atc_proto::_ServerToClient_ReplyQueryTraffic_default_instance_);
}
inline const ::atc_proto::ServerToClient_ReplyQueryTraffic& ServerToClient::reply_query_traffic() const {
  // @@protoc_insertion_point(field_get:atc_proto.ServerToClient.reply_query_traffic)
  return _internal_reply_query_traffic();
}
inline ::atc_proto::ServerToClient_ReplyQueryTraffic* ServerToClient::unsafe_arena_release_reply_query_traffic() {
  // @@protoc_insertion_point(field_unsafe_arena_release:atc_proto.ServerToClient.reply_query_traffic)
  if (_internal_has_reply_query_traffic()) {
    clear_has_payload();
    ::atc_proto::ServerToClient_ReplyQueryTraffic* temp = payload_.reply_query_traffic_;
    payload_.reply_query_traffic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerToClient::unsafe_arena_set_allocated_reply_query_traffic(::atc_proto::ServerToClient_ReplyQueryTraffic* reply_query_traffic) {
  clear_payload();
  if (reply_query_traffic) {
    set_has_reply_query_traffic();
    payload_.reply_query_traffic_ = reply_query_traffic;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.ServerToClient.reply_query_traffic)
}
inline ::atc_proto::ServerToClient_ReplyQueryTraffic* ServerToClient::_internal_mutable_reply_query_traffic() {
  if (!_internal_has_reply_query_traffic()) {
    clear_payload();
    set_has_reply_query_traffic();
    payload_.reply_query_traffic_ = CreateMaybeMessage< ::atc_proto::ServerToClient_ReplyQueryTraffic >(GetArena());
  }
  return payload_.reply_query_traffic_;
}
inline ::atc_proto::ServerToClient_ReplyQueryTraffic* ServerToClient::mutable_reply_query_traffic() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ServerToClient.reply_query_traffic)
  return _internal_mutable_reply_query_traffic();
}

// .atc_proto.ServerToClient.NotifyAircraftCreated notify_aircraft_created = 201;
inline bool ServerToClient::_internal_has_notify_aircraft_created() const {
  return payload_case() == kNotifyAircraftCreated;
}
inline bool ServerToClient::has_notify_aircraft_created() const {
  return _internal_has_notify_aircraft_created();
}
inline void ServerToClient::set_has_notify_aircraft_created() {
  _oneof_case_[0] = kNotifyAircraftCreated;
}
inline void ServerToClient::clear_notify_aircraft_created() {
  if (_internal_has_notify_aircraft_created()) {
    if (GetArena() == nullptr) {
      delete payload_.notify_aircraft_created_;
    }
    clear_has_payload();
  }
}
inline ::atc_proto::ServerToClient_NotifyAircraftCreated* ServerToClient::release_notify_aircraft_created() {
  // @@protoc_insertion_point(field_release:atc_proto.ServerToClient.notify_aircraft_created)
  if (_internal_has_notify_aircraft_created()) {
    clear_has_payload();
      ::atc_proto::ServerToClient_NotifyAircraftCreated* temp = payload_.notify_aircraft_created_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.notify_aircraft_created_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::atc_proto::ServerToClient_NotifyAircraftCreated& ServerToClient::_internal_notify_aircraft_created() const {
  return _internal_has_notify_aircraft_created()
      ? *payload_.notify_aircraft_created_
      : *reinterpret_cast< ::atc_proto::ServerToClient_NotifyAircraftCreated*>(&::atc_proto::_ServerToClient_NotifyAircraftCreated_default_instance_);
}
inline const ::atc_proto::ServerToClient_NotifyAircraftCreated& ServerToClient::notify_aircraft_created() const {
  // @@protoc_insertion_point(field_get:atc_proto.ServerToClient.notify_aircraft_created)
  return _internal_notify_aircraft_created();
}
inline ::atc_proto::ServerToClient_NotifyAircraftCreated* ServerToClient::unsafe_arena_release_notify_aircraft_created() {
  // @@protoc_insertion_point(field_unsafe_arena_release:atc_proto.ServerToClient.notify_aircraft_created)
  if (_internal_has_notify_aircraft_created()) {
    clear_has_payload();
    ::atc_proto::ServerToClient_NotifyAircraftCreated* temp = payload_.notify_aircraft_created_;
    payload_.notify_aircraft_created_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerToClient::unsafe_arena_set_allocated_notify_aircraft_created(::atc_proto::ServerToClient_NotifyAircraftCreated* notify_aircraft_created) {
  clear_payload();
  if (notify_aircraft_created) {
    set_has_notify_aircraft_created();
    payload_.notify_aircraft_created_ = notify_aircraft_created;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.ServerToClient.notify_aircraft_created)
}
inline ::atc_proto::ServerToClient_NotifyAircraftCreated* ServerToClient::_internal_mutable_notify_aircraft_created() {
  if (!_internal_has_notify_aircraft_created()) {
    clear_payload();
    set_has_notify_aircraft_created();
    payload_.notify_aircraft_created_ = CreateMaybeMessage< ::atc_proto::ServerToClient_NotifyAircraftCreated >(GetArena());
  }
  return payload_.notify_aircraft_created_;
}
inline ::atc_proto::ServerToClient_NotifyAircraftCreated* ServerToClient::mutable_notify_aircraft_created() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ServerToClient.notify_aircraft_created)
  return _internal_mutable_notify_aircraft_created();
}

// .atc_proto.ServerToClient.NotifyAircraftSituationUpdated notify_aircraft_situation_updated = 202;
inline bool ServerToClient::_internal_has_notify_aircraft_situation_updated() const {
  return payload_case() == kNotifyAircraftSituationUpdated;
}
inline bool ServerToClient::has_notify_aircraft_situation_updated() const {
  return _internal_has_notify_aircraft_situation_updated();
}
inline void ServerToClient::set_has_notify_aircraft_situation_updated() {
  _oneof_case_[0] = kNotifyAircraftSituationUpdated;
}
inline void ServerToClient::clear_notify_aircraft_situation_updated() {
  if (_internal_has_notify_aircraft_situation_updated()) {
    if (GetArena() == nullptr) {
      delete payload_.notify_aircraft_situation_updated_;
    }
    clear_has_payload();
  }
}
inline ::atc_proto::ServerToClient_NotifyAircraftSituationUpdated* ServerToClient::release_notify_aircraft_situation_updated() {
  // @@protoc_insertion_point(field_release:atc_proto.ServerToClient.notify_aircraft_situation_updated)
  if (_internal_has_notify_aircraft_situation_updated()) {
    clear_has_payload();
      ::atc_proto::ServerToClient_NotifyAircraftSituationUpdated* temp = payload_.notify_aircraft_situation_updated_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.notify_aircraft_situation_updated_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::atc_proto::ServerToClient_NotifyAircraftSituationUpdated& ServerToClient::_internal_notify_aircraft_situation_updated() const {
  return _internal_has_notify_aircraft_situation_updated()
      ? *payload_.notify_aircraft_situation_updated_
      : *reinterpret_cast< ::atc_proto::ServerToClient_NotifyAircraftSituationUpdated*>(&::atc_proto::_ServerToClient_NotifyAircraftSituationUpdated_default_instance_);
}
inline const ::atc_proto::ServerToClient_NotifyAircraftSituationUpdated& ServerToClient::notify_aircraft_situation_updated() const {
  // @@protoc_insertion_point(field_get:atc_proto.ServerToClient.notify_aircraft_situation_updated)
  return _internal_notify_aircraft_situation_updated();
}
inline ::atc_proto::ServerToClient_NotifyAircraftSituationUpdated* ServerToClient::unsafe_arena_release_notify_aircraft_situation_updated() {
  // @@protoc_insertion_point(field_unsafe_arena_release:atc_proto.ServerToClient.notify_aircraft_situation_updated)
  if (_internal_has_notify_aircraft_situation_updated()) {
    clear_has_payload();
    ::atc_proto::ServerToClient_NotifyAircraftSituationUpdated* temp = payload_.notify_aircraft_situation_updated_;
    payload_.notify_aircraft_situation_updated_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerToClient::unsafe_arena_set_allocated_notify_aircraft_situation_updated(::atc_proto::ServerToClient_NotifyAircraftSituationUpdated* notify_aircraft_situation_updated) {
  clear_payload();
  if (notify_aircraft_situation_updated) {
    set_has_notify_aircraft_situation_updated();
    payload_.notify_aircraft_situation_updated_ = notify_aircraft_situation_updated;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.ServerToClient.notify_aircraft_situation_updated)
}
inline ::atc_proto::ServerToClient_NotifyAircraftSituationUpdated* ServerToClient::_internal_mutable_notify_aircraft_situation_updated() {
  if (!_internal_has_notify_aircraft_situation_updated()) {
    clear_payload();
    set_has_notify_aircraft_situation_updated();
    payload_.notify_aircraft_situation_updated_ = CreateMaybeMessage< ::atc_proto::ServerToClient_NotifyAircraftSituationUpdated >(GetArena());
  }
  return payload_.notify_aircraft_situation_updated_;
}
inline ::atc_proto::ServerToClient_NotifyAircraftSituationUpdated* ServerToClient::mutable_notify_aircraft_situation_updated() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ServerToClient.notify_aircraft_situation_updated)
  return _internal_mutable_notify_aircraft_situation_updated();
}

// .atc_proto.ServerToClient.NotifyAircraftRemoved notify_aircraft_removed = 203;
inline bool ServerToClient::_internal_has_notify_aircraft_removed() const {
  return payload_case() == kNotifyAircraftRemoved;
}
inline bool ServerToClient::has_notify_aircraft_removed() const {
  return _internal_has_notify_aircraft_removed();
}
inline void ServerToClient::set_has_notify_aircraft_removed() {
  _oneof_case_[0] = kNotifyAircraftRemoved;
}
inline void ServerToClient::clear_notify_aircraft_removed() {
  if (_internal_has_notify_aircraft_removed()) {
    if (GetArena() == nullptr) {
      delete payload_.notify_aircraft_removed_;
    }
    clear_has_payload();
  }
}
inline ::atc_proto::ServerToClient_NotifyAircraftRemoved* ServerToClient::release_notify_aircraft_removed() {
  // @@protoc_insertion_point(field_release:atc_proto.ServerToClient.notify_aircraft_removed)
  if (_internal_has_notify_aircraft_removed()) {
    clear_has_payload();
      ::atc_proto::ServerToClient_NotifyAircraftRemoved* temp = payload_.notify_aircraft_removed_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.notify_aircraft_removed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::atc_proto::ServerToClient_NotifyAircraftRemoved& ServerToClient::_internal_notify_aircraft_removed() const {
  return _internal_has_notify_aircraft_removed()
      ? *payload_.notify_aircraft_removed_
      : *reinterpret_cast< ::atc_proto::ServerToClient_NotifyAircraftRemoved*>(&::atc_proto::_ServerToClient_NotifyAircraftRemoved_default_instance_);
}
inline const ::atc_proto::ServerToClient_NotifyAircraftRemoved& ServerToClient::notify_aircraft_removed() const {
  // @@protoc_insertion_point(field_get:atc_proto.ServerToClient.notify_aircraft_removed)
  return _internal_notify_aircraft_removed();
}
inline ::atc_proto::ServerToClient_NotifyAircraftRemoved* ServerToClient::unsafe_arena_release_notify_aircraft_removed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:atc_proto.ServerToClient.notify_aircraft_removed)
  if (_internal_has_notify_aircraft_removed()) {
    clear_has_payload();
    ::atc_proto::ServerToClient_NotifyAircraftRemoved* temp = payload_.notify_aircraft_removed_;
    payload_.notify_aircraft_removed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerToClient::unsafe_arena_set_allocated_notify_aircraft_removed(::atc_proto::ServerToClient_NotifyAircraftRemoved* notify_aircraft_removed) {
  clear_payload();
  if (notify_aircraft_removed) {
    set_has_notify_aircraft_removed();
    payload_.notify_aircraft_removed_ = notify_aircraft_removed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.ServerToClient.notify_aircraft_removed)
}
inline ::atc_proto::ServerToClient_NotifyAircraftRemoved* ServerToClient::_internal_mutable_notify_aircraft_removed() {
  if (!_internal_has_notify_aircraft_removed()) {
    clear_payload();
    set_has_notify_aircraft_removed();
    payload_.notify_aircraft_removed_ = CreateMaybeMessage< ::atc_proto::ServerToClient_NotifyAircraftRemoved >(GetArena());
  }
  return payload_.notify_aircraft_removed_;
}
inline ::atc_proto::ServerToClient_NotifyAircraftRemoved* ServerToClient::mutable_notify_aircraft_removed() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ServerToClient.notify_aircraft_removed)
  return _internal_mutable_notify_aircraft_removed();
}

// .atc_proto.ServerToClient.ReplyUserAcquireAircraft reply_user_acquire_aircraft = 204;
inline bool ServerToClient::_internal_has_reply_user_acquire_aircraft() const {
  return payload_case() == kReplyUserAcquireAircraft;
}
inline bool ServerToClient::has_reply_user_acquire_aircraft() const {
  return _internal_has_reply_user_acquire_aircraft();
}
inline void ServerToClient::set_has_reply_user_acquire_aircraft() {
  _oneof_case_[0] = kReplyUserAcquireAircraft;
}
inline void ServerToClient::clear_reply_user_acquire_aircraft() {
  if (_internal_has_reply_user_acquire_aircraft()) {
    if (GetArena() == nullptr) {
      delete payload_.reply_user_acquire_aircraft_;
    }
    clear_has_payload();
  }
}
inline ::atc_proto::ServerToClient_ReplyUserAcquireAircraft* ServerToClient::release_reply_user_acquire_aircraft() {
  // @@protoc_insertion_point(field_release:atc_proto.ServerToClient.reply_user_acquire_aircraft)
  if (_internal_has_reply_user_acquire_aircraft()) {
    clear_has_payload();
      ::atc_proto::ServerToClient_ReplyUserAcquireAircraft* temp = payload_.reply_user_acquire_aircraft_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.reply_user_acquire_aircraft_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::atc_proto::ServerToClient_ReplyUserAcquireAircraft& ServerToClient::_internal_reply_user_acquire_aircraft() const {
  return _internal_has_reply_user_acquire_aircraft()
      ? *payload_.reply_user_acquire_aircraft_
      : *reinterpret_cast< ::atc_proto::ServerToClient_ReplyUserAcquireAircraft*>(&::atc_proto::_ServerToClient_ReplyUserAcquireAircraft_default_instance_);
}
inline const ::atc_proto::ServerToClient_ReplyUserAcquireAircraft& ServerToClient::reply_user_acquire_aircraft() const {
  // @@protoc_insertion_point(field_get:atc_proto.ServerToClient.reply_user_acquire_aircraft)
  return _internal_reply_user_acquire_aircraft();
}
inline ::atc_proto::ServerToClient_ReplyUserAcquireAircraft* ServerToClient::unsafe_arena_release_reply_user_acquire_aircraft() {
  // @@protoc_insertion_point(field_unsafe_arena_release:atc_proto.ServerToClient.reply_user_acquire_aircraft)
  if (_internal_has_reply_user_acquire_aircraft()) {
    clear_has_payload();
    ::atc_proto::ServerToClient_ReplyUserAcquireAircraft* temp = payload_.reply_user_acquire_aircraft_;
    payload_.reply_user_acquire_aircraft_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerToClient::unsafe_arena_set_allocated_reply_user_acquire_aircraft(::atc_proto::ServerToClient_ReplyUserAcquireAircraft* reply_user_acquire_aircraft) {
  clear_payload();
  if (reply_user_acquire_aircraft) {
    set_has_reply_user_acquire_aircraft();
    payload_.reply_user_acquire_aircraft_ = reply_user_acquire_aircraft;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.ServerToClient.reply_user_acquire_aircraft)
}
inline ::atc_proto::ServerToClient_ReplyUserAcquireAircraft* ServerToClient::_internal_mutable_reply_user_acquire_aircraft() {
  if (!_internal_has_reply_user_acquire_aircraft()) {
    clear_payload();
    set_has_reply_user_acquire_aircraft();
    payload_.reply_user_acquire_aircraft_ = CreateMaybeMessage< ::atc_proto::ServerToClient_ReplyUserAcquireAircraft >(GetArena());
  }
  return payload_.reply_user_acquire_aircraft_;
}
inline ::atc_proto::ServerToClient_ReplyUserAcquireAircraft* ServerToClient::mutable_reply_user_acquire_aircraft() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ServerToClient.reply_user_acquire_aircraft)
  return _internal_mutable_reply_user_acquire_aircraft();
}

// .atc_proto.ServerToClient.FaultDeclined fault_declined = 3001;
inline bool ServerToClient::_internal_has_fault_declined() const {
  return payload_case() == kFaultDeclined;
}
inline bool ServerToClient::has_fault_declined() const {
  return _internal_has_fault_declined();
}
inline void ServerToClient::set_has_fault_declined() {
  _oneof_case_[0] = kFaultDeclined;
}
inline void ServerToClient::clear_fault_declined() {
  if (_internal_has_fault_declined()) {
    if (GetArena() == nullptr) {
      delete payload_.fault_declined_;
    }
    clear_has_payload();
  }
}
inline ::atc_proto::ServerToClient_FaultDeclined* ServerToClient::release_fault_declined() {
  // @@protoc_insertion_point(field_release:atc_proto.ServerToClient.fault_declined)
  if (_internal_has_fault_declined()) {
    clear_has_payload();
      ::atc_proto::ServerToClient_FaultDeclined* temp = payload_.fault_declined_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.fault_declined_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::atc_proto::ServerToClient_FaultDeclined& ServerToClient::_internal_fault_declined() const {
  return _internal_has_fault_declined()
      ? *payload_.fault_declined_
      : *reinterpret_cast< ::atc_proto::ServerToClient_FaultDeclined*>(&::atc_proto::_ServerToClient_FaultDeclined_default_instance_);
}
inline const ::atc_proto::ServerToClient_FaultDeclined& ServerToClient::fault_declined() const {
  // @@protoc_insertion_point(field_get:atc_proto.ServerToClient.fault_declined)
  return _internal_fault_declined();
}
inline ::atc_proto::ServerToClient_FaultDeclined* ServerToClient::unsafe_arena_release_fault_declined() {
  // @@protoc_insertion_point(field_unsafe_arena_release:atc_proto.ServerToClient.fault_declined)
  if (_internal_has_fault_declined()) {
    clear_has_payload();
    ::atc_proto::ServerToClient_FaultDeclined* temp = payload_.fault_declined_;
    payload_.fault_declined_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerToClient::unsafe_arena_set_allocated_fault_declined(::atc_proto::ServerToClient_FaultDeclined* fault_declined) {
  clear_payload();
  if (fault_declined) {
    set_has_fault_declined();
    payload_.fault_declined_ = fault_declined;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.ServerToClient.fault_declined)
}
inline ::atc_proto::ServerToClient_FaultDeclined* ServerToClient::_internal_mutable_fault_declined() {
  if (!_internal_has_fault_declined()) {
    clear_payload();
    set_has_fault_declined();
    payload_.fault_declined_ = CreateMaybeMessage< ::atc_proto::ServerToClient_FaultDeclined >(GetArena());
  }
  return payload_.fault_declined_;
}
inline ::atc_proto::ServerToClient_FaultDeclined* ServerToClient::mutable_fault_declined() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ServerToClient.fault_declined)
  return _internal_mutable_fault_declined();
}

// .atc_proto.ServerToClient.FaultNotFound fault_not_found = 3002;
inline bool ServerToClient::_internal_has_fault_not_found() const {
  return payload_case() == kFaultNotFound;
}
inline bool ServerToClient::has_fault_not_found() const {
  return _internal_has_fault_not_found();
}
inline void ServerToClient::set_has_fault_not_found() {
  _oneof_case_[0] = kFaultNotFound;
}
inline void ServerToClient::clear_fault_not_found() {
  if (_internal_has_fault_not_found()) {
    if (GetArena() == nullptr) {
      delete payload_.fault_not_found_;
    }
    clear_has_payload();
  }
}
inline ::atc_proto::ServerToClient_FaultNotFound* ServerToClient::release_fault_not_found() {
  // @@protoc_insertion_point(field_release:atc_proto.ServerToClient.fault_not_found)
  if (_internal_has_fault_not_found()) {
    clear_has_payload();
      ::atc_proto::ServerToClient_FaultNotFound* temp = payload_.fault_not_found_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.fault_not_found_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::atc_proto::ServerToClient_FaultNotFound& ServerToClient::_internal_fault_not_found() const {
  return _internal_has_fault_not_found()
      ? *payload_.fault_not_found_
      : *reinterpret_cast< ::atc_proto::ServerToClient_FaultNotFound*>(&::atc_proto::_ServerToClient_FaultNotFound_default_instance_);
}
inline const ::atc_proto::ServerToClient_FaultNotFound& ServerToClient::fault_not_found() const {
  // @@protoc_insertion_point(field_get:atc_proto.ServerToClient.fault_not_found)
  return _internal_fault_not_found();
}
inline ::atc_proto::ServerToClient_FaultNotFound* ServerToClient::unsafe_arena_release_fault_not_found() {
  // @@protoc_insertion_point(field_unsafe_arena_release:atc_proto.ServerToClient.fault_not_found)
  if (_internal_has_fault_not_found()) {
    clear_has_payload();
    ::atc_proto::ServerToClient_FaultNotFound* temp = payload_.fault_not_found_;
    payload_.fault_not_found_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerToClient::unsafe_arena_set_allocated_fault_not_found(::atc_proto::ServerToClient_FaultNotFound* fault_not_found) {
  clear_payload();
  if (fault_not_found) {
    set_has_fault_not_found();
    payload_.fault_not_found_ = fault_not_found;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.ServerToClient.fault_not_found)
}
inline ::atc_proto::ServerToClient_FaultNotFound* ServerToClient::_internal_mutable_fault_not_found() {
  if (!_internal_has_fault_not_found()) {
    clear_payload();
    set_has_fault_not_found();
    payload_.fault_not_found_ = CreateMaybeMessage< ::atc_proto::ServerToClient_FaultNotFound >(GetArena());
  }
  return payload_.fault_not_found_;
}
inline ::atc_proto::ServerToClient_FaultNotFound* ServerToClient::mutable_fault_not_found() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ServerToClient.fault_not_found)
  return _internal_mutable_fault_not_found();
}

inline bool ServerToClient::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void ServerToClient::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline ServerToClient::PayloadCase ServerToClient::payload_case() const {
  return ServerToClient::PayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// GeoPoint

// double lat = 1;
inline void GeoPoint::clear_lat() {
  lat_ = 0;
}
inline double GeoPoint::_internal_lat() const {
  return lat_;
}
inline double GeoPoint::lat() const {
  // @@protoc_insertion_point(field_get:atc_proto.GeoPoint.lat)
  return _internal_lat();
}
inline void GeoPoint::_internal_set_lat(double value) {
  
  lat_ = value;
}
inline void GeoPoint::set_lat(double value) {
  _internal_set_lat(value);
  // @@protoc_insertion_point(field_set:atc_proto.GeoPoint.lat)
}

// double lon = 2;
inline void GeoPoint::clear_lon() {
  lon_ = 0;
}
inline double GeoPoint::_internal_lon() const {
  return lon_;
}
inline double GeoPoint::lon() const {
  // @@protoc_insertion_point(field_get:atc_proto.GeoPoint.lon)
  return _internal_lon();
}
inline void GeoPoint::_internal_set_lon(double value) {
  
  lon_ = value;
}
inline void GeoPoint::set_lon(double value) {
  _internal_set_lon(value);
  // @@protoc_insertion_point(field_set:atc_proto.GeoPoint.lon)
}

// -------------------------------------------------------------------

// GeoPolygon_GeoEdge

// .atc_proto.GeoEdgeType type = 1;
inline void GeoPolygon_GeoEdge::clear_type() {
  type_ = 0;
}
inline ::atc_proto::GeoEdgeType GeoPolygon_GeoEdge::_internal_type() const {
  return static_cast< ::atc_proto::GeoEdgeType >(type_);
}
inline ::atc_proto::GeoEdgeType GeoPolygon_GeoEdge::type() const {
  // @@protoc_insertion_point(field_get:atc_proto.GeoPolygon.GeoEdge.type)
  return _internal_type();
}
inline void GeoPolygon_GeoEdge::_internal_set_type(::atc_proto::GeoEdgeType value) {
  
  type_ = value;
}
inline void GeoPolygon_GeoEdge::set_type(::atc_proto::GeoEdgeType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:atc_proto.GeoPolygon.GeoEdge.type)
}

// .atc_proto.GeoPoint from_point = 2;
inline bool GeoPolygon_GeoEdge::_internal_has_from_point() const {
  return this != internal_default_instance() && from_point_ != nullptr;
}
inline bool GeoPolygon_GeoEdge::has_from_point() const {
  return _internal_has_from_point();
}
inline void GeoPolygon_GeoEdge::clear_from_point() {
  if (GetArena() == nullptr && from_point_ != nullptr) {
    delete from_point_;
  }
  from_point_ = nullptr;
}
inline const ::atc_proto::GeoPoint& GeoPolygon_GeoEdge::_internal_from_point() const {
  const ::atc_proto::GeoPoint* p = from_point_;
  return p != nullptr ? *p : *reinterpret_cast<const ::atc_proto::GeoPoint*>(
      &::atc_proto::_GeoPoint_default_instance_);
}
inline const ::atc_proto::GeoPoint& GeoPolygon_GeoEdge::from_point() const {
  // @@protoc_insertion_point(field_get:atc_proto.GeoPolygon.GeoEdge.from_point)
  return _internal_from_point();
}
inline void GeoPolygon_GeoEdge::unsafe_arena_set_allocated_from_point(
    ::atc_proto::GeoPoint* from_point) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(from_point_);
  }
  from_point_ = from_point;
  if (from_point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.GeoPolygon.GeoEdge.from_point)
}
inline ::atc_proto::GeoPoint* GeoPolygon_GeoEdge::release_from_point() {
  
  ::atc_proto::GeoPoint* temp = from_point_;
  from_point_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::atc_proto::GeoPoint* GeoPolygon_GeoEdge::unsafe_arena_release_from_point() {
  // @@protoc_insertion_point(field_release:atc_proto.GeoPolygon.GeoEdge.from_point)
  
  ::atc_proto::GeoPoint* temp = from_point_;
  from_point_ = nullptr;
  return temp;
}
inline ::atc_proto::GeoPoint* GeoPolygon_GeoEdge::_internal_mutable_from_point() {
  
  if (from_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::atc_proto::GeoPoint>(GetArena());
    from_point_ = p;
  }
  return from_point_;
}
inline ::atc_proto::GeoPoint* GeoPolygon_GeoEdge::mutable_from_point() {
  // @@protoc_insertion_point(field_mutable:atc_proto.GeoPolygon.GeoEdge.from_point)
  return _internal_mutable_from_point();
}
inline void GeoPolygon_GeoEdge::set_allocated_from_point(::atc_proto::GeoPoint* from_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete from_point_;
  }
  if (from_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(from_point);
    if (message_arena != submessage_arena) {
      from_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, from_point, submessage_arena);
    }
    
  } else {
    
  }
  from_point_ = from_point;
  // @@protoc_insertion_point(field_set_allocated:atc_proto.GeoPolygon.GeoEdge.from_point)
}

// -------------------------------------------------------------------

// GeoPolygon

// repeated .atc_proto.GeoPolygon.GeoEdge edges = 1;
inline int GeoPolygon::_internal_edges_size() const {
  return edges_.size();
}
inline int GeoPolygon::edges_size() const {
  return _internal_edges_size();
}
inline void GeoPolygon::clear_edges() {
  edges_.Clear();
}
inline ::atc_proto::GeoPolygon_GeoEdge* GeoPolygon::mutable_edges(int index) {
  // @@protoc_insertion_point(field_mutable:atc_proto.GeoPolygon.edges)
  return edges_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::atc_proto::GeoPolygon_GeoEdge >*
GeoPolygon::mutable_edges() {
  // @@protoc_insertion_point(field_mutable_list:atc_proto.GeoPolygon.edges)
  return &edges_;
}
inline const ::atc_proto::GeoPolygon_GeoEdge& GeoPolygon::_internal_edges(int index) const {
  return edges_.Get(index);
}
inline const ::atc_proto::GeoPolygon_GeoEdge& GeoPolygon::edges(int index) const {
  // @@protoc_insertion_point(field_get:atc_proto.GeoPolygon.edges)
  return _internal_edges(index);
}
inline ::atc_proto::GeoPolygon_GeoEdge* GeoPolygon::_internal_add_edges() {
  return edges_.Add();
}
inline ::atc_proto::GeoPolygon_GeoEdge* GeoPolygon::add_edges() {
  // @@protoc_insertion_point(field_add:atc_proto.GeoPolygon.edges)
  return _internal_add_edges();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::atc_proto::GeoPolygon_GeoEdge >&
GeoPolygon::edges() const {
  // @@protoc_insertion_point(field_list:atc_proto.GeoPolygon.edges)
  return edges_;
}

// -------------------------------------------------------------------

// Vector3dMessage

// double lat = 1;
inline void Vector3dMessage::clear_lat() {
  lat_ = 0;
}
inline double Vector3dMessage::_internal_lat() const {
  return lat_;
}
inline double Vector3dMessage::lat() const {
  // @@protoc_insertion_point(field_get:atc_proto.Vector3dMessage.lat)
  return _internal_lat();
}
inline void Vector3dMessage::_internal_set_lat(double value) {
  
  lat_ = value;
}
inline void Vector3dMessage::set_lat(double value) {
  _internal_set_lat(value);
  // @@protoc_insertion_point(field_set:atc_proto.Vector3dMessage.lat)
}

// double lon = 2;
inline void Vector3dMessage::clear_lon() {
  lon_ = 0;
}
inline double Vector3dMessage::_internal_lon() const {
  return lon_;
}
inline double Vector3dMessage::lon() const {
  // @@protoc_insertion_point(field_get:atc_proto.Vector3dMessage.lon)
  return _internal_lon();
}
inline void Vector3dMessage::_internal_set_lon(double value) {
  
  lon_ = value;
}
inline void Vector3dMessage::set_lon(double value) {
  _internal_set_lon(value);
  // @@protoc_insertion_point(field_set:atc_proto.Vector3dMessage.lon)
}

// double alt = 3;
inline void Vector3dMessage::clear_alt() {
  alt_ = 0;
}
inline double Vector3dMessage::_internal_alt() const {
  return alt_;
}
inline double Vector3dMessage::alt() const {
  // @@protoc_insertion_point(field_get:atc_proto.Vector3dMessage.alt)
  return _internal_alt();
}
inline void Vector3dMessage::_internal_set_alt(double value) {
  
  alt_ = value;
}
inline void Vector3dMessage::set_alt(double value) {
  _internal_set_alt(value);
  // @@protoc_insertion_point(field_set:atc_proto.Vector3dMessage.alt)
}

// -------------------------------------------------------------------

// AttitudeMessage

// float heading = 1;
inline void AttitudeMessage::clear_heading() {
  heading_ = 0;
}
inline float AttitudeMessage::_internal_heading() const {
  return heading_;
}
inline float AttitudeMessage::heading() const {
  // @@protoc_insertion_point(field_get:atc_proto.AttitudeMessage.heading)
  return _internal_heading();
}
inline void AttitudeMessage::_internal_set_heading(float value) {
  
  heading_ = value;
}
inline void AttitudeMessage::set_heading(float value) {
  _internal_set_heading(value);
  // @@protoc_insertion_point(field_set:atc_proto.AttitudeMessage.heading)
}

// float pitch = 2;
inline void AttitudeMessage::clear_pitch() {
  pitch_ = 0;
}
inline float AttitudeMessage::_internal_pitch() const {
  return pitch_;
}
inline float AttitudeMessage::pitch() const {
  // @@protoc_insertion_point(field_get:atc_proto.AttitudeMessage.pitch)
  return _internal_pitch();
}
inline void AttitudeMessage::_internal_set_pitch(float value) {
  
  pitch_ = value;
}
inline void AttitudeMessage::set_pitch(float value) {
  _internal_set_pitch(value);
  // @@protoc_insertion_point(field_set:atc_proto.AttitudeMessage.pitch)
}

// float roll = 3;
inline void AttitudeMessage::clear_roll() {
  roll_ = 0;
}
inline float AttitudeMessage::_internal_roll() const {
  return roll_;
}
inline float AttitudeMessage::roll() const {
  // @@protoc_insertion_point(field_get:atc_proto.AttitudeMessage.roll)
  return _internal_roll();
}
inline void AttitudeMessage::_internal_set_roll(float value) {
  
  roll_ = value;
}
inline void AttitudeMessage::set_roll(float value) {
  _internal_set_roll(value);
  // @@protoc_insertion_point(field_set:atc_proto.AttitudeMessage.roll)
}

// -------------------------------------------------------------------

// AirportMessage

// string icao = 1;
inline void AirportMessage::clear_icao() {
  icao_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& AirportMessage::icao() const {
  // @@protoc_insertion_point(field_get:atc_proto.AirportMessage.icao)
  return _internal_icao();
}
inline void AirportMessage::set_icao(const std::string& value) {
  _internal_set_icao(value);
  // @@protoc_insertion_point(field_set:atc_proto.AirportMessage.icao)
}
inline std::string* AirportMessage::mutable_icao() {
  // @@protoc_insertion_point(field_mutable:atc_proto.AirportMessage.icao)
  return _internal_mutable_icao();
}
inline const std::string& AirportMessage::_internal_icao() const {
  return icao_.Get();
}
inline void AirportMessage::_internal_set_icao(const std::string& value) {
  
  icao_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AirportMessage::set_icao(std::string&& value) {
  
  icao_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:atc_proto.AirportMessage.icao)
}
inline void AirportMessage::set_icao(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  icao_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:atc_proto.AirportMessage.icao)
}
inline void AirportMessage::set_icao(const char* value,
    size_t size) {
  
  icao_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:atc_proto.AirportMessage.icao)
}
inline std::string* AirportMessage::_internal_mutable_icao() {
  
  return icao_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AirportMessage::release_icao() {
  // @@protoc_insertion_point(field_release:atc_proto.AirportMessage.icao)
  return icao_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AirportMessage::set_allocated_icao(std::string* icao) {
  if (icao != nullptr) {
    
  } else {
    
  }
  icao_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), icao,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:atc_proto.AirportMessage.icao)
}

// .atc_proto.GeoPoint location = 2;
inline bool AirportMessage::_internal_has_location() const {
  return this != internal_default_instance() && location_ != nullptr;
}
inline bool AirportMessage::has_location() const {
  return _internal_has_location();
}
inline void AirportMessage::clear_location() {
  if (GetArena() == nullptr && location_ != nullptr) {
    delete location_;
  }
  location_ = nullptr;
}
inline const ::atc_proto::GeoPoint& AirportMessage::_internal_location() const {
  const ::atc_proto::GeoPoint* p = location_;
  return p != nullptr ? *p : *reinterpret_cast<const ::atc_proto::GeoPoint*>(
      &::atc_proto::_GeoPoint_default_instance_);
}
inline const ::atc_proto::GeoPoint& AirportMessage::location() const {
  // @@protoc_insertion_point(field_get:atc_proto.AirportMessage.location)
  return _internal_location();
}
inline void AirportMessage::unsafe_arena_set_allocated_location(
    ::atc_proto::GeoPoint* location) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(location_);
  }
  location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.AirportMessage.location)
}
inline ::atc_proto::GeoPoint* AirportMessage::release_location() {
  
  ::atc_proto::GeoPoint* temp = location_;
  location_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::atc_proto::GeoPoint* AirportMessage::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_release:atc_proto.AirportMessage.location)
  
  ::atc_proto::GeoPoint* temp = location_;
  location_ = nullptr;
  return temp;
}
inline ::atc_proto::GeoPoint* AirportMessage::_internal_mutable_location() {
  
  if (location_ == nullptr) {
    auto* p = CreateMaybeMessage<::atc_proto::GeoPoint>(GetArena());
    location_ = p;
  }
  return location_;
}
inline ::atc_proto::GeoPoint* AirportMessage::mutable_location() {
  // @@protoc_insertion_point(field_mutable:atc_proto.AirportMessage.location)
  return _internal_mutable_location();
}
inline void AirportMessage::set_allocated_location(::atc_proto::GeoPoint* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete location_;
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(location);
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:atc_proto.AirportMessage.location)
}

// repeated .atc_proto.RunwayMessage runways = 3;
inline int AirportMessage::_internal_runways_size() const {
  return runways_.size();
}
inline int AirportMessage::runways_size() const {
  return _internal_runways_size();
}
inline void AirportMessage::clear_runways() {
  runways_.Clear();
}
inline ::atc_proto::RunwayMessage* AirportMessage::mutable_runways(int index) {
  // @@protoc_insertion_point(field_mutable:atc_proto.AirportMessage.runways)
  return runways_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::atc_proto::RunwayMessage >*
AirportMessage::mutable_runways() {
  // @@protoc_insertion_point(field_mutable_list:atc_proto.AirportMessage.runways)
  return &runways_;
}
inline const ::atc_proto::RunwayMessage& AirportMessage::_internal_runways(int index) const {
  return runways_.Get(index);
}
inline const ::atc_proto::RunwayMessage& AirportMessage::runways(int index) const {
  // @@protoc_insertion_point(field_get:atc_proto.AirportMessage.runways)
  return _internal_runways(index);
}
inline ::atc_proto::RunwayMessage* AirportMessage::_internal_add_runways() {
  return runways_.Add();
}
inline ::atc_proto::RunwayMessage* AirportMessage::add_runways() {
  // @@protoc_insertion_point(field_add:atc_proto.AirportMessage.runways)
  return _internal_add_runways();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::atc_proto::RunwayMessage >&
AirportMessage::runways() const {
  // @@protoc_insertion_point(field_list:atc_proto.AirportMessage.runways)
  return runways_;
}

// repeated .atc_proto.ParkingStandMessage parking_stands = 4;
inline int AirportMessage::_internal_parking_stands_size() const {
  return parking_stands_.size();
}
inline int AirportMessage::parking_stands_size() const {
  return _internal_parking_stands_size();
}
inline void AirportMessage::clear_parking_stands() {
  parking_stands_.Clear();
}
inline ::atc_proto::ParkingStandMessage* AirportMessage::mutable_parking_stands(int index) {
  // @@protoc_insertion_point(field_mutable:atc_proto.AirportMessage.parking_stands)
  return parking_stands_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::atc_proto::ParkingStandMessage >*
AirportMessage::mutable_parking_stands() {
  // @@protoc_insertion_point(field_mutable_list:atc_proto.AirportMessage.parking_stands)
  return &parking_stands_;
}
inline const ::atc_proto::ParkingStandMessage& AirportMessage::_internal_parking_stands(int index) const {
  return parking_stands_.Get(index);
}
inline const ::atc_proto::ParkingStandMessage& AirportMessage::parking_stands(int index) const {
  // @@protoc_insertion_point(field_get:atc_proto.AirportMessage.parking_stands)
  return _internal_parking_stands(index);
}
inline ::atc_proto::ParkingStandMessage* AirportMessage::_internal_add_parking_stands() {
  return parking_stands_.Add();
}
inline ::atc_proto::ParkingStandMessage* AirportMessage::add_parking_stands() {
  // @@protoc_insertion_point(field_add:atc_proto.AirportMessage.parking_stands)
  return _internal_add_parking_stands();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::atc_proto::ParkingStandMessage >&
AirportMessage::parking_stands() const {
  // @@protoc_insertion_point(field_list:atc_proto.AirportMessage.parking_stands)
  return parking_stands_;
}

// repeated .atc_proto.TaxiNodeMessage taxi_nodes = 5;
inline int AirportMessage::_internal_taxi_nodes_size() const {
  return taxi_nodes_.size();
}
inline int AirportMessage::taxi_nodes_size() const {
  return _internal_taxi_nodes_size();
}
inline void AirportMessage::clear_taxi_nodes() {
  taxi_nodes_.Clear();
}
inline ::atc_proto::TaxiNodeMessage* AirportMessage::mutable_taxi_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:atc_proto.AirportMessage.taxi_nodes)
  return taxi_nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::atc_proto::TaxiNodeMessage >*
AirportMessage::mutable_taxi_nodes() {
  // @@protoc_insertion_point(field_mutable_list:atc_proto.AirportMessage.taxi_nodes)
  return &taxi_nodes_;
}
inline const ::atc_proto::TaxiNodeMessage& AirportMessage::_internal_taxi_nodes(int index) const {
  return taxi_nodes_.Get(index);
}
inline const ::atc_proto::TaxiNodeMessage& AirportMessage::taxi_nodes(int index) const {
  // @@protoc_insertion_point(field_get:atc_proto.AirportMessage.taxi_nodes)
  return _internal_taxi_nodes(index);
}
inline ::atc_proto::TaxiNodeMessage* AirportMessage::_internal_add_taxi_nodes() {
  return taxi_nodes_.Add();
}
inline ::atc_proto::TaxiNodeMessage* AirportMessage::add_taxi_nodes() {
  // @@protoc_insertion_point(field_add:atc_proto.AirportMessage.taxi_nodes)
  return _internal_add_taxi_nodes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::atc_proto::TaxiNodeMessage >&
AirportMessage::taxi_nodes() const {
  // @@protoc_insertion_point(field_list:atc_proto.AirportMessage.taxi_nodes)
  return taxi_nodes_;
}

// repeated .atc_proto.TaxiEdgeMessage taxi_edges = 6;
inline int AirportMessage::_internal_taxi_edges_size() const {
  return taxi_edges_.size();
}
inline int AirportMessage::taxi_edges_size() const {
  return _internal_taxi_edges_size();
}
inline void AirportMessage::clear_taxi_edges() {
  taxi_edges_.Clear();
}
inline ::atc_proto::TaxiEdgeMessage* AirportMessage::mutable_taxi_edges(int index) {
  // @@protoc_insertion_point(field_mutable:atc_proto.AirportMessage.taxi_edges)
  return taxi_edges_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::atc_proto::TaxiEdgeMessage >*
AirportMessage::mutable_taxi_edges() {
  // @@protoc_insertion_point(field_mutable_list:atc_proto.AirportMessage.taxi_edges)
  return &taxi_edges_;
}
inline const ::atc_proto::TaxiEdgeMessage& AirportMessage::_internal_taxi_edges(int index) const {
  return taxi_edges_.Get(index);
}
inline const ::atc_proto::TaxiEdgeMessage& AirportMessage::taxi_edges(int index) const {
  // @@protoc_insertion_point(field_get:atc_proto.AirportMessage.taxi_edges)
  return _internal_taxi_edges(index);
}
inline ::atc_proto::TaxiEdgeMessage* AirportMessage::_internal_add_taxi_edges() {
  return taxi_edges_.Add();
}
inline ::atc_proto::TaxiEdgeMessage* AirportMessage::add_taxi_edges() {
  // @@protoc_insertion_point(field_add:atc_proto.AirportMessage.taxi_edges)
  return _internal_add_taxi_edges();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::atc_proto::TaxiEdgeMessage >&
AirportMessage::taxi_edges() const {
  // @@protoc_insertion_point(field_list:atc_proto.AirportMessage.taxi_edges)
  return taxi_edges_;
}

// -------------------------------------------------------------------

// RunwayMessage_End

// string name = 1;
inline void RunwayMessage_End::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& RunwayMessage_End::name() const {
  // @@protoc_insertion_point(field_get:atc_proto.RunwayMessage.End.name)
  return _internal_name();
}
inline void RunwayMessage_End::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:atc_proto.RunwayMessage.End.name)
}
inline std::string* RunwayMessage_End::mutable_name() {
  // @@protoc_insertion_point(field_mutable:atc_proto.RunwayMessage.End.name)
  return _internal_mutable_name();
}
inline const std::string& RunwayMessage_End::_internal_name() const {
  return name_.Get();
}
inline void RunwayMessage_End::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RunwayMessage_End::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:atc_proto.RunwayMessage.End.name)
}
inline void RunwayMessage_End::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:atc_proto.RunwayMessage.End.name)
}
inline void RunwayMessage_End::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:atc_proto.RunwayMessage.End.name)
}
inline std::string* RunwayMessage_End::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RunwayMessage_End::release_name() {
  // @@protoc_insertion_point(field_release:atc_proto.RunwayMessage.End.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RunwayMessage_End::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:atc_proto.RunwayMessage.End.name)
}

// float heading = 2;
inline void RunwayMessage_End::clear_heading() {
  heading_ = 0;
}
inline float RunwayMessage_End::_internal_heading() const {
  return heading_;
}
inline float RunwayMessage_End::heading() const {
  // @@protoc_insertion_point(field_get:atc_proto.RunwayMessage.End.heading)
  return _internal_heading();
}
inline void RunwayMessage_End::_internal_set_heading(float value) {
  
  heading_ = value;
}
inline void RunwayMessage_End::set_heading(float value) {
  _internal_set_heading(value);
  // @@protoc_insertion_point(field_set:atc_proto.RunwayMessage.End.heading)
}

// .atc_proto.GeoPoint centerline_point = 3;
inline bool RunwayMessage_End::_internal_has_centerline_point() const {
  return this != internal_default_instance() && centerline_point_ != nullptr;
}
inline bool RunwayMessage_End::has_centerline_point() const {
  return _internal_has_centerline_point();
}
inline void RunwayMessage_End::clear_centerline_point() {
  if (GetArena() == nullptr && centerline_point_ != nullptr) {
    delete centerline_point_;
  }
  centerline_point_ = nullptr;
}
inline const ::atc_proto::GeoPoint& RunwayMessage_End::_internal_centerline_point() const {
  const ::atc_proto::GeoPoint* p = centerline_point_;
  return p != nullptr ? *p : *reinterpret_cast<const ::atc_proto::GeoPoint*>(
      &::atc_proto::_GeoPoint_default_instance_);
}
inline const ::atc_proto::GeoPoint& RunwayMessage_End::centerline_point() const {
  // @@protoc_insertion_point(field_get:atc_proto.RunwayMessage.End.centerline_point)
  return _internal_centerline_point();
}
inline void RunwayMessage_End::unsafe_arena_set_allocated_centerline_point(
    ::atc_proto::GeoPoint* centerline_point) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(centerline_point_);
  }
  centerline_point_ = centerline_point;
  if (centerline_point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.RunwayMessage.End.centerline_point)
}
inline ::atc_proto::GeoPoint* RunwayMessage_End::release_centerline_point() {
  
  ::atc_proto::GeoPoint* temp = centerline_point_;
  centerline_point_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::atc_proto::GeoPoint* RunwayMessage_End::unsafe_arena_release_centerline_point() {
  // @@protoc_insertion_point(field_release:atc_proto.RunwayMessage.End.centerline_point)
  
  ::atc_proto::GeoPoint* temp = centerline_point_;
  centerline_point_ = nullptr;
  return temp;
}
inline ::atc_proto::GeoPoint* RunwayMessage_End::_internal_mutable_centerline_point() {
  
  if (centerline_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::atc_proto::GeoPoint>(GetArena());
    centerline_point_ = p;
  }
  return centerline_point_;
}
inline ::atc_proto::GeoPoint* RunwayMessage_End::mutable_centerline_point() {
  // @@protoc_insertion_point(field_mutable:atc_proto.RunwayMessage.End.centerline_point)
  return _internal_mutable_centerline_point();
}
inline void RunwayMessage_End::set_allocated_centerline_point(::atc_proto::GeoPoint* centerline_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete centerline_point_;
  }
  if (centerline_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(centerline_point);
    if (message_arena != submessage_arena) {
      centerline_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, centerline_point, submessage_arena);
    }
    
  } else {
    
  }
  centerline_point_ = centerline_point;
  // @@protoc_insertion_point(field_set_allocated:atc_proto.RunwayMessage.End.centerline_point)
}

// float displaced_threshold_meters = 4;
inline void RunwayMessage_End::clear_displaced_threshold_meters() {
  displaced_threshold_meters_ = 0;
}
inline float RunwayMessage_End::_internal_displaced_threshold_meters() const {
  return displaced_threshold_meters_;
}
inline float RunwayMessage_End::displaced_threshold_meters() const {
  // @@protoc_insertion_point(field_get:atc_proto.RunwayMessage.End.displaced_threshold_meters)
  return _internal_displaced_threshold_meters();
}
inline void RunwayMessage_End::_internal_set_displaced_threshold_meters(float value) {
  
  displaced_threshold_meters_ = value;
}
inline void RunwayMessage_End::set_displaced_threshold_meters(float value) {
  _internal_set_displaced_threshold_meters(value);
  // @@protoc_insertion_point(field_set:atc_proto.RunwayMessage.End.displaced_threshold_meters)
}

// float overrun_area_meters = 5;
inline void RunwayMessage_End::clear_overrun_area_meters() {
  overrun_area_meters_ = 0;
}
inline float RunwayMessage_End::_internal_overrun_area_meters() const {
  return overrun_area_meters_;
}
inline float RunwayMessage_End::overrun_area_meters() const {
  // @@protoc_insertion_point(field_get:atc_proto.RunwayMessage.End.overrun_area_meters)
  return _internal_overrun_area_meters();
}
inline void RunwayMessage_End::_internal_set_overrun_area_meters(float value) {
  
  overrun_area_meters_ = value;
}
inline void RunwayMessage_End::set_overrun_area_meters(float value) {
  _internal_set_overrun_area_meters(value);
  // @@protoc_insertion_point(field_set:atc_proto.RunwayMessage.End.overrun_area_meters)
}

// -------------------------------------------------------------------

// RunwayMessage

// float width_meters = 1;
inline void RunwayMessage::clear_width_meters() {
  width_meters_ = 0;
}
inline float RunwayMessage::_internal_width_meters() const {
  return width_meters_;
}
inline float RunwayMessage::width_meters() const {
  // @@protoc_insertion_point(field_get:atc_proto.RunwayMessage.width_meters)
  return _internal_width_meters();
}
inline void RunwayMessage::_internal_set_width_meters(float value) {
  
  width_meters_ = value;
}
inline void RunwayMessage::set_width_meters(float value) {
  _internal_set_width_meters(value);
  // @@protoc_insertion_point(field_set:atc_proto.RunwayMessage.width_meters)
}

// float length_meters = 2;
inline void RunwayMessage::clear_length_meters() {
  length_meters_ = 0;
}
inline float RunwayMessage::_internal_length_meters() const {
  return length_meters_;
}
inline float RunwayMessage::length_meters() const {
  // @@protoc_insertion_point(field_get:atc_proto.RunwayMessage.length_meters)
  return _internal_length_meters();
}
inline void RunwayMessage::_internal_set_length_meters(float value) {
  
  length_meters_ = value;
}
inline void RunwayMessage::set_length_meters(float value) {
  _internal_set_length_meters(value);
  // @@protoc_insertion_point(field_set:atc_proto.RunwayMessage.length_meters)
}

// uint32 mask_bit = 3;
inline void RunwayMessage::clear_mask_bit() {
  mask_bit_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RunwayMessage::_internal_mask_bit() const {
  return mask_bit_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RunwayMessage::mask_bit() const {
  // @@protoc_insertion_point(field_get:atc_proto.RunwayMessage.mask_bit)
  return _internal_mask_bit();
}
inline void RunwayMessage::_internal_set_mask_bit(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  mask_bit_ = value;
}
inline void RunwayMessage::set_mask_bit(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_mask_bit(value);
  // @@protoc_insertion_point(field_set:atc_proto.RunwayMessage.mask_bit)
}

// .atc_proto.RunwayMessage.End end_1 = 4;
inline bool RunwayMessage::_internal_has_end_1() const {
  return this != internal_default_instance() && end_1_ != nullptr;
}
inline bool RunwayMessage::has_end_1() const {
  return _internal_has_end_1();
}
inline void RunwayMessage::clear_end_1() {
  if (GetArena() == nullptr && end_1_ != nullptr) {
    delete end_1_;
  }
  end_1_ = nullptr;
}
inline const ::atc_proto::RunwayMessage_End& RunwayMessage::_internal_end_1() const {
  const ::atc_proto::RunwayMessage_End* p = end_1_;
  return p != nullptr ? *p : *reinterpret_cast<const ::atc_proto::RunwayMessage_End*>(
      &::atc_proto::_RunwayMessage_End_default_instance_);
}
inline const ::atc_proto::RunwayMessage_End& RunwayMessage::end_1() const {
  // @@protoc_insertion_point(field_get:atc_proto.RunwayMessage.end_1)
  return _internal_end_1();
}
inline void RunwayMessage::unsafe_arena_set_allocated_end_1(
    ::atc_proto::RunwayMessage_End* end_1) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_1_);
  }
  end_1_ = end_1;
  if (end_1) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.RunwayMessage.end_1)
}
inline ::atc_proto::RunwayMessage_End* RunwayMessage::release_end_1() {
  
  ::atc_proto::RunwayMessage_End* temp = end_1_;
  end_1_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::atc_proto::RunwayMessage_End* RunwayMessage::unsafe_arena_release_end_1() {
  // @@protoc_insertion_point(field_release:atc_proto.RunwayMessage.end_1)
  
  ::atc_proto::RunwayMessage_End* temp = end_1_;
  end_1_ = nullptr;
  return temp;
}
inline ::atc_proto::RunwayMessage_End* RunwayMessage::_internal_mutable_end_1() {
  
  if (end_1_ == nullptr) {
    auto* p = CreateMaybeMessage<::atc_proto::RunwayMessage_End>(GetArena());
    end_1_ = p;
  }
  return end_1_;
}
inline ::atc_proto::RunwayMessage_End* RunwayMessage::mutable_end_1() {
  // @@protoc_insertion_point(field_mutable:atc_proto.RunwayMessage.end_1)
  return _internal_mutable_end_1();
}
inline void RunwayMessage::set_allocated_end_1(::atc_proto::RunwayMessage_End* end_1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete end_1_;
  }
  if (end_1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(end_1);
    if (message_arena != submessage_arena) {
      end_1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_1, submessage_arena);
    }
    
  } else {
    
  }
  end_1_ = end_1;
  // @@protoc_insertion_point(field_set_allocated:atc_proto.RunwayMessage.end_1)
}

// .atc_proto.RunwayMessage.End end_2 = 5;
inline bool RunwayMessage::_internal_has_end_2() const {
  return this != internal_default_instance() && end_2_ != nullptr;
}
inline bool RunwayMessage::has_end_2() const {
  return _internal_has_end_2();
}
inline void RunwayMessage::clear_end_2() {
  if (GetArena() == nullptr && end_2_ != nullptr) {
    delete end_2_;
  }
  end_2_ = nullptr;
}
inline const ::atc_proto::RunwayMessage_End& RunwayMessage::_internal_end_2() const {
  const ::atc_proto::RunwayMessage_End* p = end_2_;
  return p != nullptr ? *p : *reinterpret_cast<const ::atc_proto::RunwayMessage_End*>(
      &::atc_proto::_RunwayMessage_End_default_instance_);
}
inline const ::atc_proto::RunwayMessage_End& RunwayMessage::end_2() const {
  // @@protoc_insertion_point(field_get:atc_proto.RunwayMessage.end_2)
  return _internal_end_2();
}
inline void RunwayMessage::unsafe_arena_set_allocated_end_2(
    ::atc_proto::RunwayMessage_End* end_2) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_2_);
  }
  end_2_ = end_2;
  if (end_2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.RunwayMessage.end_2)
}
inline ::atc_proto::RunwayMessage_End* RunwayMessage::release_end_2() {
  
  ::atc_proto::RunwayMessage_End* temp = end_2_;
  end_2_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::atc_proto::RunwayMessage_End* RunwayMessage::unsafe_arena_release_end_2() {
  // @@protoc_insertion_point(field_release:atc_proto.RunwayMessage.end_2)
  
  ::atc_proto::RunwayMessage_End* temp = end_2_;
  end_2_ = nullptr;
  return temp;
}
inline ::atc_proto::RunwayMessage_End* RunwayMessage::_internal_mutable_end_2() {
  
  if (end_2_ == nullptr) {
    auto* p = CreateMaybeMessage<::atc_proto::RunwayMessage_End>(GetArena());
    end_2_ = p;
  }
  return end_2_;
}
inline ::atc_proto::RunwayMessage_End* RunwayMessage::mutable_end_2() {
  // @@protoc_insertion_point(field_mutable:atc_proto.RunwayMessage.end_2)
  return _internal_mutable_end_2();
}
inline void RunwayMessage::set_allocated_end_2(::atc_proto::RunwayMessage_End* end_2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete end_2_;
  }
  if (end_2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(end_2);
    if (message_arena != submessage_arena) {
      end_2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_2, submessage_arena);
    }
    
  } else {
    
  }
  end_2_ = end_2;
  // @@protoc_insertion_point(field_set_allocated:atc_proto.RunwayMessage.end_2)
}

// -------------------------------------------------------------------

// TaxiNodeMessage

// int32 id = 1;
inline void TaxiNodeMessage::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaxiNodeMessage::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaxiNodeMessage::id() const {
  // @@protoc_insertion_point(field_get:atc_proto.TaxiNodeMessage.id)
  return _internal_id();
}
inline void TaxiNodeMessage::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
}
inline void TaxiNodeMessage::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:atc_proto.TaxiNodeMessage.id)
}

// .atc_proto.GeoPoint location = 2;
inline bool TaxiNodeMessage::_internal_has_location() const {
  return this != internal_default_instance() && location_ != nullptr;
}
inline bool TaxiNodeMessage::has_location() const {
  return _internal_has_location();
}
inline void TaxiNodeMessage::clear_location() {
  if (GetArena() == nullptr && location_ != nullptr) {
    delete location_;
  }
  location_ = nullptr;
}
inline const ::atc_proto::GeoPoint& TaxiNodeMessage::_internal_location() const {
  const ::atc_proto::GeoPoint* p = location_;
  return p != nullptr ? *p : *reinterpret_cast<const ::atc_proto::GeoPoint*>(
      &::atc_proto::_GeoPoint_default_instance_);
}
inline const ::atc_proto::GeoPoint& TaxiNodeMessage::location() const {
  // @@protoc_insertion_point(field_get:atc_proto.TaxiNodeMessage.location)
  return _internal_location();
}
inline void TaxiNodeMessage::unsafe_arena_set_allocated_location(
    ::atc_proto::GeoPoint* location) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(location_);
  }
  location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.TaxiNodeMessage.location)
}
inline ::atc_proto::GeoPoint* TaxiNodeMessage::release_location() {
  
  ::atc_proto::GeoPoint* temp = location_;
  location_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::atc_proto::GeoPoint* TaxiNodeMessage::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_release:atc_proto.TaxiNodeMessage.location)
  
  ::atc_proto::GeoPoint* temp = location_;
  location_ = nullptr;
  return temp;
}
inline ::atc_proto::GeoPoint* TaxiNodeMessage::_internal_mutable_location() {
  
  if (location_ == nullptr) {
    auto* p = CreateMaybeMessage<::atc_proto::GeoPoint>(GetArena());
    location_ = p;
  }
  return location_;
}
inline ::atc_proto::GeoPoint* TaxiNodeMessage::mutable_location() {
  // @@protoc_insertion_point(field_mutable:atc_proto.TaxiNodeMessage.location)
  return _internal_mutable_location();
}
inline void TaxiNodeMessage::set_allocated_location(::atc_proto::GeoPoint* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete location_;
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(location);
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:atc_proto.TaxiNodeMessage.location)
}

// bool is_junction = 3;
inline void TaxiNodeMessage::clear_is_junction() {
  is_junction_ = false;
}
inline bool TaxiNodeMessage::_internal_is_junction() const {
  return is_junction_;
}
inline bool TaxiNodeMessage::is_junction() const {
  // @@protoc_insertion_point(field_get:atc_proto.TaxiNodeMessage.is_junction)
  return _internal_is_junction();
}
inline void TaxiNodeMessage::_internal_set_is_junction(bool value) {
  
  is_junction_ = value;
}
inline void TaxiNodeMessage::set_is_junction(bool value) {
  _internal_set_is_junction(value);
  // @@protoc_insertion_point(field_set:atc_proto.TaxiNodeMessage.is_junction)
}

// -------------------------------------------------------------------

// TaxiEdgeMessage_ActiveZoneMatrix

// uint64 departure = 1;
inline void TaxiEdgeMessage_ActiveZoneMatrix::clear_departure() {
  departure_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TaxiEdgeMessage_ActiveZoneMatrix::_internal_departure() const {
  return departure_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TaxiEdgeMessage_ActiveZoneMatrix::departure() const {
  // @@protoc_insertion_point(field_get:atc_proto.TaxiEdgeMessage.ActiveZoneMatrix.departure)
  return _internal_departure();
}
inline void TaxiEdgeMessage_ActiveZoneMatrix::_internal_set_departure(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  departure_ = value;
}
inline void TaxiEdgeMessage_ActiveZoneMatrix::set_departure(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_departure(value);
  // @@protoc_insertion_point(field_set:atc_proto.TaxiEdgeMessage.ActiveZoneMatrix.departure)
}

// uint64 arrival = 2;
inline void TaxiEdgeMessage_ActiveZoneMatrix::clear_arrival() {
  arrival_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TaxiEdgeMessage_ActiveZoneMatrix::_internal_arrival() const {
  return arrival_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TaxiEdgeMessage_ActiveZoneMatrix::arrival() const {
  // @@protoc_insertion_point(field_get:atc_proto.TaxiEdgeMessage.ActiveZoneMatrix.arrival)
  return _internal_arrival();
}
inline void TaxiEdgeMessage_ActiveZoneMatrix::_internal_set_arrival(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  arrival_ = value;
}
inline void TaxiEdgeMessage_ActiveZoneMatrix::set_arrival(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_arrival(value);
  // @@protoc_insertion_point(field_set:atc_proto.TaxiEdgeMessage.ActiveZoneMatrix.arrival)
}

// uint64 ils = 3;
inline void TaxiEdgeMessage_ActiveZoneMatrix::clear_ils() {
  ils_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TaxiEdgeMessage_ActiveZoneMatrix::_internal_ils() const {
  return ils_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TaxiEdgeMessage_ActiveZoneMatrix::ils() const {
  // @@protoc_insertion_point(field_get:atc_proto.TaxiEdgeMessage.ActiveZoneMatrix.ils)
  return _internal_ils();
}
inline void TaxiEdgeMessage_ActiveZoneMatrix::_internal_set_ils(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  ils_ = value;
}
inline void TaxiEdgeMessage_ActiveZoneMatrix::set_ils(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_ils(value);
  // @@protoc_insertion_point(field_set:atc_proto.TaxiEdgeMessage.ActiveZoneMatrix.ils)
}

// -------------------------------------------------------------------

// TaxiEdgeMessage

// int32 id = 1;
inline void TaxiEdgeMessage::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaxiEdgeMessage::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaxiEdgeMessage::id() const {
  // @@protoc_insertion_point(field_get:atc_proto.TaxiEdgeMessage.id)
  return _internal_id();
}
inline void TaxiEdgeMessage::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
}
inline void TaxiEdgeMessage::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:atc_proto.TaxiEdgeMessage.id)
}

// string name = 2;
inline void TaxiEdgeMessage::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& TaxiEdgeMessage::name() const {
  // @@protoc_insertion_point(field_get:atc_proto.TaxiEdgeMessage.name)
  return _internal_name();
}
inline void TaxiEdgeMessage::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:atc_proto.TaxiEdgeMessage.name)
}
inline std::string* TaxiEdgeMessage::mutable_name() {
  // @@protoc_insertion_point(field_mutable:atc_proto.TaxiEdgeMessage.name)
  return _internal_mutable_name();
}
inline const std::string& TaxiEdgeMessage::_internal_name() const {
  return name_.Get();
}
inline void TaxiEdgeMessage::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TaxiEdgeMessage::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:atc_proto.TaxiEdgeMessage.name)
}
inline void TaxiEdgeMessage::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:atc_proto.TaxiEdgeMessage.name)
}
inline void TaxiEdgeMessage::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:atc_proto.TaxiEdgeMessage.name)
}
inline std::string* TaxiEdgeMessage::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TaxiEdgeMessage::release_name() {
  // @@protoc_insertion_point(field_release:atc_proto.TaxiEdgeMessage.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TaxiEdgeMessage::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:atc_proto.TaxiEdgeMessage.name)
}

// int32 node_id_1 = 3;
inline void TaxiEdgeMessage::clear_node_id_1() {
  node_id_1_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaxiEdgeMessage::_internal_node_id_1() const {
  return node_id_1_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaxiEdgeMessage::node_id_1() const {
  // @@protoc_insertion_point(field_get:atc_proto.TaxiEdgeMessage.node_id_1)
  return _internal_node_id_1();
}
inline void TaxiEdgeMessage::_internal_set_node_id_1(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  node_id_1_ = value;
}
inline void TaxiEdgeMessage::set_node_id_1(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_node_id_1(value);
  // @@protoc_insertion_point(field_set:atc_proto.TaxiEdgeMessage.node_id_1)
}

// int32 node_id_2 = 4;
inline void TaxiEdgeMessage::clear_node_id_2() {
  node_id_2_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaxiEdgeMessage::_internal_node_id_2() const {
  return node_id_2_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaxiEdgeMessage::node_id_2() const {
  // @@protoc_insertion_point(field_get:atc_proto.TaxiEdgeMessage.node_id_2)
  return _internal_node_id_2();
}
inline void TaxiEdgeMessage::_internal_set_node_id_2(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  node_id_2_ = value;
}
inline void TaxiEdgeMessage::set_node_id_2(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_node_id_2(value);
  // @@protoc_insertion_point(field_set:atc_proto.TaxiEdgeMessage.node_id_2)
}

// .atc_proto.TaxiEdgeType type = 5;
inline void TaxiEdgeMessage::clear_type() {
  type_ = 0;
}
inline ::atc_proto::TaxiEdgeType TaxiEdgeMessage::_internal_type() const {
  return static_cast< ::atc_proto::TaxiEdgeType >(type_);
}
inline ::atc_proto::TaxiEdgeType TaxiEdgeMessage::type() const {
  // @@protoc_insertion_point(field_get:atc_proto.TaxiEdgeMessage.type)
  return _internal_type();
}
inline void TaxiEdgeMessage::_internal_set_type(::atc_proto::TaxiEdgeType value) {
  
  type_ = value;
}
inline void TaxiEdgeMessage::set_type(::atc_proto::TaxiEdgeType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:atc_proto.TaxiEdgeMessage.type)
}

// bool is_one_way = 6;
inline void TaxiEdgeMessage::clear_is_one_way() {
  is_one_way_ = false;
}
inline bool TaxiEdgeMessage::_internal_is_one_way() const {
  return is_one_way_;
}
inline bool TaxiEdgeMessage::is_one_way() const {
  // @@protoc_insertion_point(field_get:atc_proto.TaxiEdgeMessage.is_one_way)
  return _internal_is_one_way();
}
inline void TaxiEdgeMessage::_internal_set_is_one_way(bool value) {
  
  is_one_way_ = value;
}
inline void TaxiEdgeMessage::set_is_one_way(bool value) {
  _internal_set_is_one_way(value);
  // @@protoc_insertion_point(field_set:atc_proto.TaxiEdgeMessage.is_one_way)
}

// bool is_high_speed_exit = 7;
inline void TaxiEdgeMessage::clear_is_high_speed_exit() {
  is_high_speed_exit_ = false;
}
inline bool TaxiEdgeMessage::_internal_is_high_speed_exit() const {
  return is_high_speed_exit_;
}
inline bool TaxiEdgeMessage::is_high_speed_exit() const {
  // @@protoc_insertion_point(field_get:atc_proto.TaxiEdgeMessage.is_high_speed_exit)
  return _internal_is_high_speed_exit();
}
inline void TaxiEdgeMessage::_internal_set_is_high_speed_exit(bool value) {
  
  is_high_speed_exit_ = value;
}
inline void TaxiEdgeMessage::set_is_high_speed_exit(bool value) {
  _internal_set_is_high_speed_exit(value);
  // @@protoc_insertion_point(field_set:atc_proto.TaxiEdgeMessage.is_high_speed_exit)
}

// float length_meters = 8;
inline void TaxiEdgeMessage::clear_length_meters() {
  length_meters_ = 0;
}
inline float TaxiEdgeMessage::_internal_length_meters() const {
  return length_meters_;
}
inline float TaxiEdgeMessage::length_meters() const {
  // @@protoc_insertion_point(field_get:atc_proto.TaxiEdgeMessage.length_meters)
  return _internal_length_meters();
}
inline void TaxiEdgeMessage::_internal_set_length_meters(float value) {
  
  length_meters_ = value;
}
inline void TaxiEdgeMessage::set_length_meters(float value) {
  _internal_set_length_meters(value);
  // @@protoc_insertion_point(field_set:atc_proto.TaxiEdgeMessage.length_meters)
}

// float heading = 9;
inline void TaxiEdgeMessage::clear_heading() {
  heading_ = 0;
}
inline float TaxiEdgeMessage::_internal_heading() const {
  return heading_;
}
inline float TaxiEdgeMessage::heading() const {
  // @@protoc_insertion_point(field_get:atc_proto.TaxiEdgeMessage.heading)
  return _internal_heading();
}
inline void TaxiEdgeMessage::_internal_set_heading(float value) {
  
  heading_ = value;
}
inline void TaxiEdgeMessage::set_heading(float value) {
  _internal_set_heading(value);
  // @@protoc_insertion_point(field_set:atc_proto.TaxiEdgeMessage.heading)
}

// .atc_proto.TaxiEdgeMessage.ActiveZoneMatrix active_zones = 10;
inline bool TaxiEdgeMessage::_internal_has_active_zones() const {
  return this != internal_default_instance() && active_zones_ != nullptr;
}
inline bool TaxiEdgeMessage::has_active_zones() const {
  return _internal_has_active_zones();
}
inline void TaxiEdgeMessage::clear_active_zones() {
  if (GetArena() == nullptr && active_zones_ != nullptr) {
    delete active_zones_;
  }
  active_zones_ = nullptr;
}
inline const ::atc_proto::TaxiEdgeMessage_ActiveZoneMatrix& TaxiEdgeMessage::_internal_active_zones() const {
  const ::atc_proto::TaxiEdgeMessage_ActiveZoneMatrix* p = active_zones_;
  return p != nullptr ? *p : *reinterpret_cast<const ::atc_proto::TaxiEdgeMessage_ActiveZoneMatrix*>(
      &::atc_proto::_TaxiEdgeMessage_ActiveZoneMatrix_default_instance_);
}
inline const ::atc_proto::TaxiEdgeMessage_ActiveZoneMatrix& TaxiEdgeMessage::active_zones() const {
  // @@protoc_insertion_point(field_get:atc_proto.TaxiEdgeMessage.active_zones)
  return _internal_active_zones();
}
inline void TaxiEdgeMessage::unsafe_arena_set_allocated_active_zones(
    ::atc_proto::TaxiEdgeMessage_ActiveZoneMatrix* active_zones) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(active_zones_);
  }
  active_zones_ = active_zones;
  if (active_zones) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.TaxiEdgeMessage.active_zones)
}
inline ::atc_proto::TaxiEdgeMessage_ActiveZoneMatrix* TaxiEdgeMessage::release_active_zones() {
  
  ::atc_proto::TaxiEdgeMessage_ActiveZoneMatrix* temp = active_zones_;
  active_zones_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::atc_proto::TaxiEdgeMessage_ActiveZoneMatrix* TaxiEdgeMessage::unsafe_arena_release_active_zones() {
  // @@protoc_insertion_point(field_release:atc_proto.TaxiEdgeMessage.active_zones)
  
  ::atc_proto::TaxiEdgeMessage_ActiveZoneMatrix* temp = active_zones_;
  active_zones_ = nullptr;
  return temp;
}
inline ::atc_proto::TaxiEdgeMessage_ActiveZoneMatrix* TaxiEdgeMessage::_internal_mutable_active_zones() {
  
  if (active_zones_ == nullptr) {
    auto* p = CreateMaybeMessage<::atc_proto::TaxiEdgeMessage_ActiveZoneMatrix>(GetArena());
    active_zones_ = p;
  }
  return active_zones_;
}
inline ::atc_proto::TaxiEdgeMessage_ActiveZoneMatrix* TaxiEdgeMessage::mutable_active_zones() {
  // @@protoc_insertion_point(field_mutable:atc_proto.TaxiEdgeMessage.active_zones)
  return _internal_mutable_active_zones();
}
inline void TaxiEdgeMessage::set_allocated_active_zones(::atc_proto::TaxiEdgeMessage_ActiveZoneMatrix* active_zones) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete active_zones_;
  }
  if (active_zones) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(active_zones);
    if (message_arena != submessage_arena) {
      active_zones = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, active_zones, submessage_arena);
    }
    
  } else {
    
  }
  active_zones_ = active_zones;
  // @@protoc_insertion_point(field_set_allocated:atc_proto.TaxiEdgeMessage.active_zones)
}

// -------------------------------------------------------------------

// ParkingStandMessage

// int32 id = 1;
inline void ParkingStandMessage::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ParkingStandMessage::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ParkingStandMessage::id() const {
  // @@protoc_insertion_point(field_get:atc_proto.ParkingStandMessage.id)
  return _internal_id();
}
inline void ParkingStandMessage::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
}
inline void ParkingStandMessage::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:atc_proto.ParkingStandMessage.id)
}

// string name = 2;
inline void ParkingStandMessage::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ParkingStandMessage::name() const {
  // @@protoc_insertion_point(field_get:atc_proto.ParkingStandMessage.name)
  return _internal_name();
}
inline void ParkingStandMessage::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:atc_proto.ParkingStandMessage.name)
}
inline std::string* ParkingStandMessage::mutable_name() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ParkingStandMessage.name)
  return _internal_mutable_name();
}
inline const std::string& ParkingStandMessage::_internal_name() const {
  return name_.Get();
}
inline void ParkingStandMessage::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ParkingStandMessage::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:atc_proto.ParkingStandMessage.name)
}
inline void ParkingStandMessage::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:atc_proto.ParkingStandMessage.name)
}
inline void ParkingStandMessage::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:atc_proto.ParkingStandMessage.name)
}
inline std::string* ParkingStandMessage::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ParkingStandMessage::release_name() {
  // @@protoc_insertion_point(field_release:atc_proto.ParkingStandMessage.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ParkingStandMessage::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:atc_proto.ParkingStandMessage.name)
}

// .atc_proto.ParkingStandType type = 3;
inline void ParkingStandMessage::clear_type() {
  type_ = 0;
}
inline ::atc_proto::ParkingStandType ParkingStandMessage::_internal_type() const {
  return static_cast< ::atc_proto::ParkingStandType >(type_);
}
inline ::atc_proto::ParkingStandType ParkingStandMessage::type() const {
  // @@protoc_insertion_point(field_get:atc_proto.ParkingStandMessage.type)
  return _internal_type();
}
inline void ParkingStandMessage::_internal_set_type(::atc_proto::ParkingStandType value) {
  
  type_ = value;
}
inline void ParkingStandMessage::set_type(::atc_proto::ParkingStandType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:atc_proto.ParkingStandMessage.type)
}

// .atc_proto.GeoPoint location = 4;
inline bool ParkingStandMessage::_internal_has_location() const {
  return this != internal_default_instance() && location_ != nullptr;
}
inline bool ParkingStandMessage::has_location() const {
  return _internal_has_location();
}
inline void ParkingStandMessage::clear_location() {
  if (GetArena() == nullptr && location_ != nullptr) {
    delete location_;
  }
  location_ = nullptr;
}
inline const ::atc_proto::GeoPoint& ParkingStandMessage::_internal_location() const {
  const ::atc_proto::GeoPoint* p = location_;
  return p != nullptr ? *p : *reinterpret_cast<const ::atc_proto::GeoPoint*>(
      &::atc_proto::_GeoPoint_default_instance_);
}
inline const ::atc_proto::GeoPoint& ParkingStandMessage::location() const {
  // @@protoc_insertion_point(field_get:atc_proto.ParkingStandMessage.location)
  return _internal_location();
}
inline void ParkingStandMessage::unsafe_arena_set_allocated_location(
    ::atc_proto::GeoPoint* location) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(location_);
  }
  location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.ParkingStandMessage.location)
}
inline ::atc_proto::GeoPoint* ParkingStandMessage::release_location() {
  
  ::atc_proto::GeoPoint* temp = location_;
  location_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::atc_proto::GeoPoint* ParkingStandMessage::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_release:atc_proto.ParkingStandMessage.location)
  
  ::atc_proto::GeoPoint* temp = location_;
  location_ = nullptr;
  return temp;
}
inline ::atc_proto::GeoPoint* ParkingStandMessage::_internal_mutable_location() {
  
  if (location_ == nullptr) {
    auto* p = CreateMaybeMessage<::atc_proto::GeoPoint>(GetArena());
    location_ = p;
  }
  return location_;
}
inline ::atc_proto::GeoPoint* ParkingStandMessage::mutable_location() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ParkingStandMessage.location)
  return _internal_mutable_location();
}
inline void ParkingStandMessage::set_allocated_location(::atc_proto::GeoPoint* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete location_;
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(location);
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:atc_proto.ParkingStandMessage.location)
}

// float heading = 5;
inline void ParkingStandMessage::clear_heading() {
  heading_ = 0;
}
inline float ParkingStandMessage::_internal_heading() const {
  return heading_;
}
inline float ParkingStandMessage::heading() const {
  // @@protoc_insertion_point(field_get:atc_proto.ParkingStandMessage.heading)
  return _internal_heading();
}
inline void ParkingStandMessage::_internal_set_heading(float value) {
  
  heading_ = value;
}
inline void ParkingStandMessage::set_heading(float value) {
  _internal_set_heading(value);
  // @@protoc_insertion_point(field_set:atc_proto.ParkingStandMessage.heading)
}

// string width_code = 6;
inline void ParkingStandMessage::clear_width_code() {
  width_code_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ParkingStandMessage::width_code() const {
  // @@protoc_insertion_point(field_get:atc_proto.ParkingStandMessage.width_code)
  return _internal_width_code();
}
inline void ParkingStandMessage::set_width_code(const std::string& value) {
  _internal_set_width_code(value);
  // @@protoc_insertion_point(field_set:atc_proto.ParkingStandMessage.width_code)
}
inline std::string* ParkingStandMessage::mutable_width_code() {
  // @@protoc_insertion_point(field_mutable:atc_proto.ParkingStandMessage.width_code)
  return _internal_mutable_width_code();
}
inline const std::string& ParkingStandMessage::_internal_width_code() const {
  return width_code_.Get();
}
inline void ParkingStandMessage::_internal_set_width_code(const std::string& value) {
  
  width_code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ParkingStandMessage::set_width_code(std::string&& value) {
  
  width_code_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:atc_proto.ParkingStandMessage.width_code)
}
inline void ParkingStandMessage::set_width_code(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  width_code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:atc_proto.ParkingStandMessage.width_code)
}
inline void ParkingStandMessage::set_width_code(const char* value,
    size_t size) {
  
  width_code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:atc_proto.ParkingStandMessage.width_code)
}
inline std::string* ParkingStandMessage::_internal_mutable_width_code() {
  
  return width_code_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ParkingStandMessage::release_width_code() {
  // @@protoc_insertion_point(field_release:atc_proto.ParkingStandMessage.width_code)
  return width_code_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ParkingStandMessage::set_allocated_width_code(std::string* width_code) {
  if (width_code != nullptr) {
    
  } else {
    
  }
  width_code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), width_code,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:atc_proto.ParkingStandMessage.width_code)
}

// repeated .atc_proto.AircraftCategory categories = 7;
inline int ParkingStandMessage::_internal_categories_size() const {
  return categories_.size();
}
inline int ParkingStandMessage::categories_size() const {
  return _internal_categories_size();
}
inline void ParkingStandMessage::clear_categories() {
  categories_.Clear();
}
inline ::atc_proto::AircraftCategory ParkingStandMessage::_internal_categories(int index) const {
  return static_cast< ::atc_proto::AircraftCategory >(categories_.Get(index));
}
inline ::atc_proto::AircraftCategory ParkingStandMessage::categories(int index) const {
  // @@protoc_insertion_point(field_get:atc_proto.ParkingStandMessage.categories)
  return _internal_categories(index);
}
inline void ParkingStandMessage::set_categories(int index, ::atc_proto::AircraftCategory value) {
  categories_.Set(index, value);
  // @@protoc_insertion_point(field_set:atc_proto.ParkingStandMessage.categories)
}
inline void ParkingStandMessage::_internal_add_categories(::atc_proto::AircraftCategory value) {
  categories_.Add(value);
}
inline void ParkingStandMessage::add_categories(::atc_proto::AircraftCategory value) {
  // @@protoc_insertion_point(field_add:atc_proto.ParkingStandMessage.categories)
  _internal_add_categories(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
ParkingStandMessage::categories() const {
  // @@protoc_insertion_point(field_list:atc_proto.ParkingStandMessage.categories)
  return categories_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ParkingStandMessage::_internal_mutable_categories() {
  return &categories_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ParkingStandMessage::mutable_categories() {
  // @@protoc_insertion_point(field_mutable_list:atc_proto.ParkingStandMessage.categories)
  return _internal_mutable_categories();
}

// repeated .atc_proto.OperationType operation_types = 8;
inline int ParkingStandMessage::_internal_operation_types_size() const {
  return operation_types_.size();
}
inline int ParkingStandMessage::operation_types_size() const {
  return _internal_operation_types_size();
}
inline void ParkingStandMessage::clear_operation_types() {
  operation_types_.Clear();
}
inline ::atc_proto::OperationType ParkingStandMessage::_internal_operation_types(int index) const {
  return static_cast< ::atc_proto::OperationType >(operation_types_.Get(index));
}
inline ::atc_proto::OperationType ParkingStandMessage::operation_types(int index) const {
  // @@protoc_insertion_point(field_get:atc_proto.ParkingStandMessage.operation_types)
  return _internal_operation_types(index);
}
inline void ParkingStandMessage::set_operation_types(int index, ::atc_proto::OperationType value) {
  operation_types_.Set(index, value);
  // @@protoc_insertion_point(field_set:atc_proto.ParkingStandMessage.operation_types)
}
inline void ParkingStandMessage::_internal_add_operation_types(::atc_proto::OperationType value) {
  operation_types_.Add(value);
}
inline void ParkingStandMessage::add_operation_types(::atc_proto::OperationType value) {
  // @@protoc_insertion_point(field_add:atc_proto.ParkingStandMessage.operation_types)
  _internal_add_operation_types(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
ParkingStandMessage::operation_types() const {
  // @@protoc_insertion_point(field_list:atc_proto.ParkingStandMessage.operation_types)
  return operation_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ParkingStandMessage::_internal_mutable_operation_types() {
  return &operation_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ParkingStandMessage::mutable_operation_types() {
  // @@protoc_insertion_point(field_mutable_list:atc_proto.ParkingStandMessage.operation_types)
  return _internal_mutable_operation_types();
}

// repeated string airline_icaos = 9;
inline int ParkingStandMessage::_internal_airline_icaos_size() const {
  return airline_icaos_.size();
}
inline int ParkingStandMessage::airline_icaos_size() const {
  return _internal_airline_icaos_size();
}
inline void ParkingStandMessage::clear_airline_icaos() {
  airline_icaos_.Clear();
}
inline std::string* ParkingStandMessage::add_airline_icaos() {
  // @@protoc_insertion_point(field_add_mutable:atc_proto.ParkingStandMessage.airline_icaos)
  return _internal_add_airline_icaos();
}
inline const std::string& ParkingStandMessage::_internal_airline_icaos(int index) const {
  return airline_icaos_.Get(index);
}
inline const std::string& ParkingStandMessage::airline_icaos(int index) const {
  // @@protoc_insertion_point(field_get:atc_proto.ParkingStandMessage.airline_icaos)
  return _internal_airline_icaos(index);
}
inline std::string* ParkingStandMessage::mutable_airline_icaos(int index) {
  // @@protoc_insertion_point(field_mutable:atc_proto.ParkingStandMessage.airline_icaos)
  return airline_icaos_.Mutable(index);
}
inline void ParkingStandMessage::set_airline_icaos(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:atc_proto.ParkingStandMessage.airline_icaos)
  airline_icaos_.Mutable(index)->assign(value);
}
inline void ParkingStandMessage::set_airline_icaos(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:atc_proto.ParkingStandMessage.airline_icaos)
  airline_icaos_.Mutable(index)->assign(std::move(value));
}
inline void ParkingStandMessage::set_airline_icaos(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  airline_icaos_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:atc_proto.ParkingStandMessage.airline_icaos)
}
inline void ParkingStandMessage::set_airline_icaos(int index, const char* value, size_t size) {
  airline_icaos_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:atc_proto.ParkingStandMessage.airline_icaos)
}
inline std::string* ParkingStandMessage::_internal_add_airline_icaos() {
  return airline_icaos_.Add();
}
inline void ParkingStandMessage::add_airline_icaos(const std::string& value) {
  airline_icaos_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:atc_proto.ParkingStandMessage.airline_icaos)
}
inline void ParkingStandMessage::add_airline_icaos(std::string&& value) {
  airline_icaos_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:atc_proto.ParkingStandMessage.airline_icaos)
}
inline void ParkingStandMessage::add_airline_icaos(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  airline_icaos_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:atc_proto.ParkingStandMessage.airline_icaos)
}
inline void ParkingStandMessage::add_airline_icaos(const char* value, size_t size) {
  airline_icaos_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:atc_proto.ParkingStandMessage.airline_icaos)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ParkingStandMessage::airline_icaos() const {
  // @@protoc_insertion_point(field_list:atc_proto.ParkingStandMessage.airline_icaos)
  return airline_icaos_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ParkingStandMessage::mutable_airline_icaos() {
  // @@protoc_insertion_point(field_mutable_list:atc_proto.ParkingStandMessage.airline_icaos)
  return &airline_icaos_;
}

// -------------------------------------------------------------------

// AirspaceGeometryMessage

// .atc_proto.GeoPolygon lateral_bounds = 1;
inline bool AirspaceGeometryMessage::_internal_has_lateral_bounds() const {
  return this != internal_default_instance() && lateral_bounds_ != nullptr;
}
inline bool AirspaceGeometryMessage::has_lateral_bounds() const {
  return _internal_has_lateral_bounds();
}
inline void AirspaceGeometryMessage::clear_lateral_bounds() {
  if (GetArena() == nullptr && lateral_bounds_ != nullptr) {
    delete lateral_bounds_;
  }
  lateral_bounds_ = nullptr;
}
inline const ::atc_proto::GeoPolygon& AirspaceGeometryMessage::_internal_lateral_bounds() const {
  const ::atc_proto::GeoPolygon* p = lateral_bounds_;
  return p != nullptr ? *p : *reinterpret_cast<const ::atc_proto::GeoPolygon*>(
      &::atc_proto::_GeoPolygon_default_instance_);
}
inline const ::atc_proto::GeoPolygon& AirspaceGeometryMessage::lateral_bounds() const {
  // @@protoc_insertion_point(field_get:atc_proto.AirspaceGeometryMessage.lateral_bounds)
  return _internal_lateral_bounds();
}
inline void AirspaceGeometryMessage::unsafe_arena_set_allocated_lateral_bounds(
    ::atc_proto::GeoPolygon* lateral_bounds) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lateral_bounds_);
  }
  lateral_bounds_ = lateral_bounds;
  if (lateral_bounds) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.AirspaceGeometryMessage.lateral_bounds)
}
inline ::atc_proto::GeoPolygon* AirspaceGeometryMessage::release_lateral_bounds() {
  
  ::atc_proto::GeoPolygon* temp = lateral_bounds_;
  lateral_bounds_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::atc_proto::GeoPolygon* AirspaceGeometryMessage::unsafe_arena_release_lateral_bounds() {
  // @@protoc_insertion_point(field_release:atc_proto.AirspaceGeometryMessage.lateral_bounds)
  
  ::atc_proto::GeoPolygon* temp = lateral_bounds_;
  lateral_bounds_ = nullptr;
  return temp;
}
inline ::atc_proto::GeoPolygon* AirspaceGeometryMessage::_internal_mutable_lateral_bounds() {
  
  if (lateral_bounds_ == nullptr) {
    auto* p = CreateMaybeMessage<::atc_proto::GeoPolygon>(GetArena());
    lateral_bounds_ = p;
  }
  return lateral_bounds_;
}
inline ::atc_proto::GeoPolygon* AirspaceGeometryMessage::mutable_lateral_bounds() {
  // @@protoc_insertion_point(field_mutable:atc_proto.AirspaceGeometryMessage.lateral_bounds)
  return _internal_mutable_lateral_bounds();
}
inline void AirspaceGeometryMessage::set_allocated_lateral_bounds(::atc_proto::GeoPolygon* lateral_bounds) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete lateral_bounds_;
  }
  if (lateral_bounds) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(lateral_bounds);
    if (message_arena != submessage_arena) {
      lateral_bounds = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lateral_bounds, submessage_arena);
    }
    
  } else {
    
  }
  lateral_bounds_ = lateral_bounds;
  // @@protoc_insertion_point(field_set_allocated:atc_proto.AirspaceGeometryMessage.lateral_bounds)
}

// float lower_bound_feet = 2;
inline void AirspaceGeometryMessage::clear_lower_bound_feet() {
  lower_bound_feet_ = 0;
}
inline float AirspaceGeometryMessage::_internal_lower_bound_feet() const {
  return lower_bound_feet_;
}
inline float AirspaceGeometryMessage::lower_bound_feet() const {
  // @@protoc_insertion_point(field_get:atc_proto.AirspaceGeometryMessage.lower_bound_feet)
  return _internal_lower_bound_feet();
}
inline void AirspaceGeometryMessage::_internal_set_lower_bound_feet(float value) {
  
  lower_bound_feet_ = value;
}
inline void AirspaceGeometryMessage::set_lower_bound_feet(float value) {
  _internal_set_lower_bound_feet(value);
  // @@protoc_insertion_point(field_set:atc_proto.AirspaceGeometryMessage.lower_bound_feet)
}

// float upper_bound_feet = 3;
inline void AirspaceGeometryMessage::clear_upper_bound_feet() {
  upper_bound_feet_ = 0;
}
inline float AirspaceGeometryMessage::_internal_upper_bound_feet() const {
  return upper_bound_feet_;
}
inline float AirspaceGeometryMessage::upper_bound_feet() const {
  // @@protoc_insertion_point(field_get:atc_proto.AirspaceGeometryMessage.upper_bound_feet)
  return _internal_upper_bound_feet();
}
inline void AirspaceGeometryMessage::_internal_set_upper_bound_feet(float value) {
  
  upper_bound_feet_ = value;
}
inline void AirspaceGeometryMessage::set_upper_bound_feet(float value) {
  _internal_set_upper_bound_feet(value);
  // @@protoc_insertion_point(field_set:atc_proto.AirspaceGeometryMessage.upper_bound_feet)
}

// -------------------------------------------------------------------

// AircraftMessage_Situation

// .atc_proto.GeoPoint location = 1;
inline bool AircraftMessage_Situation::_internal_has_location() const {
  return this != internal_default_instance() && location_ != nullptr;
}
inline bool AircraftMessage_Situation::has_location() const {
  return _internal_has_location();
}
inline void AircraftMessage_Situation::clear_location() {
  if (GetArena() == nullptr && location_ != nullptr) {
    delete location_;
  }
  location_ = nullptr;
}
inline const ::atc_proto::GeoPoint& AircraftMessage_Situation::_internal_location() const {
  const ::atc_proto::GeoPoint* p = location_;
  return p != nullptr ? *p : *reinterpret_cast<const ::atc_proto::GeoPoint*>(
      &::atc_proto::_GeoPoint_default_instance_);
}
inline const ::atc_proto::GeoPoint& AircraftMessage_Situation::location() const {
  // @@protoc_insertion_point(field_get:atc_proto.AircraftMessage.Situation.location)
  return _internal_location();
}
inline void AircraftMessage_Situation::unsafe_arena_set_allocated_location(
    ::atc_proto::GeoPoint* location) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(location_);
  }
  location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.AircraftMessage.Situation.location)
}
inline ::atc_proto::GeoPoint* AircraftMessage_Situation::release_location() {
  
  ::atc_proto::GeoPoint* temp = location_;
  location_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::atc_proto::GeoPoint* AircraftMessage_Situation::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_release:atc_proto.AircraftMessage.Situation.location)
  
  ::atc_proto::GeoPoint* temp = location_;
  location_ = nullptr;
  return temp;
}
inline ::atc_proto::GeoPoint* AircraftMessage_Situation::_internal_mutable_location() {
  
  if (location_ == nullptr) {
    auto* p = CreateMaybeMessage<::atc_proto::GeoPoint>(GetArena());
    location_ = p;
  }
  return location_;
}
inline ::atc_proto::GeoPoint* AircraftMessage_Situation::mutable_location() {
  // @@protoc_insertion_point(field_mutable:atc_proto.AircraftMessage.Situation.location)
  return _internal_mutable_location();
}
inline void AircraftMessage_Situation::set_allocated_location(::atc_proto::GeoPoint* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete location_;
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(location);
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:atc_proto.AircraftMessage.Situation.location)
}

// float altitude_feet_msl = 2;
inline void AircraftMessage_Situation::clear_altitude_feet_msl() {
  altitude_feet_msl_ = 0;
}
inline float AircraftMessage_Situation::_internal_altitude_feet_msl() const {
  return altitude_feet_msl_;
}
inline float AircraftMessage_Situation::altitude_feet_msl() const {
  // @@protoc_insertion_point(field_get:atc_proto.AircraftMessage.Situation.altitude_feet_msl)
  return _internal_altitude_feet_msl();
}
inline void AircraftMessage_Situation::_internal_set_altitude_feet_msl(float value) {
  
  altitude_feet_msl_ = value;
}
inline void AircraftMessage_Situation::set_altitude_feet_msl(float value) {
  _internal_set_altitude_feet_msl(value);
  // @@protoc_insertion_point(field_set:atc_proto.AircraftMessage.Situation.altitude_feet_msl)
}

// bool is_on_ground = 3;
inline void AircraftMessage_Situation::clear_is_on_ground() {
  is_on_ground_ = false;
}
inline bool AircraftMessage_Situation::_internal_is_on_ground() const {
  return is_on_ground_;
}
inline bool AircraftMessage_Situation::is_on_ground() const {
  // @@protoc_insertion_point(field_get:atc_proto.AircraftMessage.Situation.is_on_ground)
  return _internal_is_on_ground();
}
inline void AircraftMessage_Situation::_internal_set_is_on_ground(bool value) {
  
  is_on_ground_ = value;
}
inline void AircraftMessage_Situation::set_is_on_ground(bool value) {
  _internal_set_is_on_ground(value);
  // @@protoc_insertion_point(field_set:atc_proto.AircraftMessage.Situation.is_on_ground)
}

// float heading = 4;
inline void AircraftMessage_Situation::clear_heading() {
  heading_ = 0;
}
inline float AircraftMessage_Situation::_internal_heading() const {
  return heading_;
}
inline float AircraftMessage_Situation::heading() const {
  // @@protoc_insertion_point(field_get:atc_proto.AircraftMessage.Situation.heading)
  return _internal_heading();
}
inline void AircraftMessage_Situation::_internal_set_heading(float value) {
  
  heading_ = value;
}
inline void AircraftMessage_Situation::set_heading(float value) {
  _internal_set_heading(value);
  // @@protoc_insertion_point(field_set:atc_proto.AircraftMessage.Situation.heading)
}

// float pitch = 5;
inline void AircraftMessage_Situation::clear_pitch() {
  pitch_ = 0;
}
inline float AircraftMessage_Situation::_internal_pitch() const {
  return pitch_;
}
inline float AircraftMessage_Situation::pitch() const {
  // @@protoc_insertion_point(field_get:atc_proto.AircraftMessage.Situation.pitch)
  return _internal_pitch();
}
inline void AircraftMessage_Situation::_internal_set_pitch(float value) {
  
  pitch_ = value;
}
inline void AircraftMessage_Situation::set_pitch(float value) {
  _internal_set_pitch(value);
  // @@protoc_insertion_point(field_set:atc_proto.AircraftMessage.Situation.pitch)
}

// float roll = 6;
inline void AircraftMessage_Situation::clear_roll() {
  roll_ = 0;
}
inline float AircraftMessage_Situation::_internal_roll() const {
  return roll_;
}
inline float AircraftMessage_Situation::roll() const {
  // @@protoc_insertion_point(field_get:atc_proto.AircraftMessage.Situation.roll)
  return _internal_roll();
}
inline void AircraftMessage_Situation::_internal_set_roll(float value) {
  
  roll_ = value;
}
inline void AircraftMessage_Situation::set_roll(float value) {
  _internal_set_roll(value);
  // @@protoc_insertion_point(field_set:atc_proto.AircraftMessage.Situation.roll)
}

// float flap_ratio = 7;
inline void AircraftMessage_Situation::clear_flap_ratio() {
  flap_ratio_ = 0;
}
inline float AircraftMessage_Situation::_internal_flap_ratio() const {
  return flap_ratio_;
}
inline float AircraftMessage_Situation::flap_ratio() const {
  // @@protoc_insertion_point(field_get:atc_proto.AircraftMessage.Situation.flap_ratio)
  return _internal_flap_ratio();
}
inline void AircraftMessage_Situation::_internal_set_flap_ratio(float value) {
  
  flap_ratio_ = value;
}
inline void AircraftMessage_Situation::set_flap_ratio(float value) {
  _internal_set_flap_ratio(value);
  // @@protoc_insertion_point(field_set:atc_proto.AircraftMessage.Situation.flap_ratio)
}

// float spoiler_ratio = 8;
inline void AircraftMessage_Situation::clear_spoiler_ratio() {
  spoiler_ratio_ = 0;
}
inline float AircraftMessage_Situation::_internal_spoiler_ratio() const {
  return spoiler_ratio_;
}
inline float AircraftMessage_Situation::spoiler_ratio() const {
  // @@protoc_insertion_point(field_get:atc_proto.AircraftMessage.Situation.spoiler_ratio)
  return _internal_spoiler_ratio();
}
inline void AircraftMessage_Situation::_internal_set_spoiler_ratio(float value) {
  
  spoiler_ratio_ = value;
}
inline void AircraftMessage_Situation::set_spoiler_ratio(float value) {
  _internal_set_spoiler_ratio(value);
  // @@protoc_insertion_point(field_set:atc_proto.AircraftMessage.Situation.spoiler_ratio)
}

// float gear_ratio = 9;
inline void AircraftMessage_Situation::clear_gear_ratio() {
  gear_ratio_ = 0;
}
inline float AircraftMessage_Situation::_internal_gear_ratio() const {
  return gear_ratio_;
}
inline float AircraftMessage_Situation::gear_ratio() const {
  // @@protoc_insertion_point(field_get:atc_proto.AircraftMessage.Situation.gear_ratio)
  return _internal_gear_ratio();
}
inline void AircraftMessage_Situation::_internal_set_gear_ratio(float value) {
  
  gear_ratio_ = value;
}
inline void AircraftMessage_Situation::set_gear_ratio(float value) {
  _internal_set_gear_ratio(value);
  // @@protoc_insertion_point(field_set:atc_proto.AircraftMessage.Situation.gear_ratio)
}

// float nose_wheel_angle = 10;
inline void AircraftMessage_Situation::clear_nose_wheel_angle() {
  nose_wheel_angle_ = 0;
}
inline float AircraftMessage_Situation::_internal_nose_wheel_angle() const {
  return nose_wheel_angle_;
}
inline float AircraftMessage_Situation::nose_wheel_angle() const {
  // @@protoc_insertion_point(field_get:atc_proto.AircraftMessage.Situation.nose_wheel_angle)
  return _internal_nose_wheel_angle();
}
inline void AircraftMessage_Situation::_internal_set_nose_wheel_angle(float value) {
  
  nose_wheel_angle_ = value;
}
inline void AircraftMessage_Situation::set_nose_wheel_angle(float value) {
  _internal_set_nose_wheel_angle(value);
  // @@protoc_insertion_point(field_set:atc_proto.AircraftMessage.Situation.nose_wheel_angle)
}

// bool landing_lights = 11;
inline void AircraftMessage_Situation::clear_landing_lights() {
  landing_lights_ = false;
}
inline bool AircraftMessage_Situation::_internal_landing_lights() const {
  return landing_lights_;
}
inline bool AircraftMessage_Situation::landing_lights() const {
  // @@protoc_insertion_point(field_get:atc_proto.AircraftMessage.Situation.landing_lights)
  return _internal_landing_lights();
}
inline void AircraftMessage_Situation::_internal_set_landing_lights(bool value) {
  
  landing_lights_ = value;
}
inline void AircraftMessage_Situation::set_landing_lights(bool value) {
  _internal_set_landing_lights(value);
  // @@protoc_insertion_point(field_set:atc_proto.AircraftMessage.Situation.landing_lights)
}

// bool taxi_lights = 12;
inline void AircraftMessage_Situation::clear_taxi_lights() {
  taxi_lights_ = false;
}
inline bool AircraftMessage_Situation::_internal_taxi_lights() const {
  return taxi_lights_;
}
inline bool AircraftMessage_Situation::taxi_lights() const {
  // @@protoc_insertion_point(field_get:atc_proto.AircraftMessage.Situation.taxi_lights)
  return _internal_taxi_lights();
}
inline void AircraftMessage_Situation::_internal_set_taxi_lights(bool value) {
  
  taxi_lights_ = value;
}
inline void AircraftMessage_Situation::set_taxi_lights(bool value) {
  _internal_set_taxi_lights(value);
  // @@protoc_insertion_point(field_set:atc_proto.AircraftMessage.Situation.taxi_lights)
}

// bool strobe_lights = 13;
inline void AircraftMessage_Situation::clear_strobe_lights() {
  strobe_lights_ = false;
}
inline bool AircraftMessage_Situation::_internal_strobe_lights() const {
  return strobe_lights_;
}
inline bool AircraftMessage_Situation::strobe_lights() const {
  // @@protoc_insertion_point(field_get:atc_proto.AircraftMessage.Situation.strobe_lights)
  return _internal_strobe_lights();
}
inline void AircraftMessage_Situation::_internal_set_strobe_lights(bool value) {
  
  strobe_lights_ = value;
}
inline void AircraftMessage_Situation::set_strobe_lights(bool value) {
  _internal_set_strobe_lights(value);
  // @@protoc_insertion_point(field_set:atc_proto.AircraftMessage.Situation.strobe_lights)
}

// repeated int32 monitoring_frequency_khz = 14;
inline int AircraftMessage_Situation::_internal_monitoring_frequency_khz_size() const {
  return monitoring_frequency_khz_.size();
}
inline int AircraftMessage_Situation::monitoring_frequency_khz_size() const {
  return _internal_monitoring_frequency_khz_size();
}
inline void AircraftMessage_Situation::clear_monitoring_frequency_khz() {
  monitoring_frequency_khz_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AircraftMessage_Situation::_internal_monitoring_frequency_khz(int index) const {
  return monitoring_frequency_khz_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AircraftMessage_Situation::monitoring_frequency_khz(int index) const {
  // @@protoc_insertion_point(field_get:atc_proto.AircraftMessage.Situation.monitoring_frequency_khz)
  return _internal_monitoring_frequency_khz(index);
}
inline void AircraftMessage_Situation::set_monitoring_frequency_khz(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  monitoring_frequency_khz_.Set(index, value);
  // @@protoc_insertion_point(field_set:atc_proto.AircraftMessage.Situation.monitoring_frequency_khz)
}
inline void AircraftMessage_Situation::_internal_add_monitoring_frequency_khz(::PROTOBUF_NAMESPACE_ID::int32 value) {
  monitoring_frequency_khz_.Add(value);
}
inline void AircraftMessage_Situation::add_monitoring_frequency_khz(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_monitoring_frequency_khz(value);
  // @@protoc_insertion_point(field_add:atc_proto.AircraftMessage.Situation.monitoring_frequency_khz)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
AircraftMessage_Situation::_internal_monitoring_frequency_khz() const {
  return monitoring_frequency_khz_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
AircraftMessage_Situation::monitoring_frequency_khz() const {
  // @@protoc_insertion_point(field_list:atc_proto.AircraftMessage.Situation.monitoring_frequency_khz)
  return _internal_monitoring_frequency_khz();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
AircraftMessage_Situation::_internal_mutable_monitoring_frequency_khz() {
  return &monitoring_frequency_khz_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
AircraftMessage_Situation::mutable_monitoring_frequency_khz() {
  // @@protoc_insertion_point(field_mutable_list:atc_proto.AircraftMessage.Situation.monitoring_frequency_khz)
  return _internal_mutable_monitoring_frequency_khz();
}

// int32 transmitting_frequency_khz = 15;
inline void AircraftMessage_Situation::clear_transmitting_frequency_khz() {
  transmitting_frequency_khz_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AircraftMessage_Situation::_internal_transmitting_frequency_khz() const {
  return transmitting_frequency_khz_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AircraftMessage_Situation::transmitting_frequency_khz() const {
  // @@protoc_insertion_point(field_get:atc_proto.AircraftMessage.Situation.transmitting_frequency_khz)
  return _internal_transmitting_frequency_khz();
}
inline void AircraftMessage_Situation::_internal_set_transmitting_frequency_khz(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  transmitting_frequency_khz_ = value;
}
inline void AircraftMessage_Situation::set_transmitting_frequency_khz(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_transmitting_frequency_khz(value);
  // @@protoc_insertion_point(field_set:atc_proto.AircraftMessage.Situation.transmitting_frequency_khz)
}

// string squawk = 16;
inline void AircraftMessage_Situation::clear_squawk() {
  squawk_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& AircraftMessage_Situation::squawk() const {
  // @@protoc_insertion_point(field_get:atc_proto.AircraftMessage.Situation.squawk)
  return _internal_squawk();
}
inline void AircraftMessage_Situation::set_squawk(const std::string& value) {
  _internal_set_squawk(value);
  // @@protoc_insertion_point(field_set:atc_proto.AircraftMessage.Situation.squawk)
}
inline std::string* AircraftMessage_Situation::mutable_squawk() {
  // @@protoc_insertion_point(field_mutable:atc_proto.AircraftMessage.Situation.squawk)
  return _internal_mutable_squawk();
}
inline const std::string& AircraftMessage_Situation::_internal_squawk() const {
  return squawk_.Get();
}
inline void AircraftMessage_Situation::_internal_set_squawk(const std::string& value) {
  
  squawk_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AircraftMessage_Situation::set_squawk(std::string&& value) {
  
  squawk_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:atc_proto.AircraftMessage.Situation.squawk)
}
inline void AircraftMessage_Situation::set_squawk(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  squawk_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:atc_proto.AircraftMessage.Situation.squawk)
}
inline void AircraftMessage_Situation::set_squawk(const char* value,
    size_t size) {
  
  squawk_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:atc_proto.AircraftMessage.Situation.squawk)
}
inline std::string* AircraftMessage_Situation::_internal_mutable_squawk() {
  
  return squawk_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AircraftMessage_Situation::release_squawk() {
  // @@protoc_insertion_point(field_release:atc_proto.AircraftMessage.Situation.squawk)
  return squawk_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AircraftMessage_Situation::set_allocated_squawk(std::string* squawk) {
  if (squawk != nullptr) {
    
  } else {
    
  }
  squawk_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), squawk,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:atc_proto.AircraftMessage.Situation.squawk)
}

// bool mode_c = 17;
inline void AircraftMessage_Situation::clear_mode_c() {
  mode_c_ = false;
}
inline bool AircraftMessage_Situation::_internal_mode_c() const {
  return mode_c_;
}
inline bool AircraftMessage_Situation::mode_c() const {
  // @@protoc_insertion_point(field_get:atc_proto.AircraftMessage.Situation.mode_c)
  return _internal_mode_c();
}
inline void AircraftMessage_Situation::_internal_set_mode_c(bool value) {
  
  mode_c_ = value;
}
inline void AircraftMessage_Situation::set_mode_c(bool value) {
  _internal_set_mode_c(value);
  // @@protoc_insertion_point(field_set:atc_proto.AircraftMessage.Situation.mode_c)
}

// bool mode_s = 18;
inline void AircraftMessage_Situation::clear_mode_s() {
  mode_s_ = false;
}
inline bool AircraftMessage_Situation::_internal_mode_s() const {
  return mode_s_;
}
inline bool AircraftMessage_Situation::mode_s() const {
  // @@protoc_insertion_point(field_get:atc_proto.AircraftMessage.Situation.mode_s)
  return _internal_mode_s();
}
inline void AircraftMessage_Situation::_internal_set_mode_s(bool value) {
  
  mode_s_ = value;
}
inline void AircraftMessage_Situation::set_mode_s(bool value) {
  _internal_set_mode_s(value);
  // @@protoc_insertion_point(field_set:atc_proto.AircraftMessage.Situation.mode_s)
}

// -------------------------------------------------------------------

// AircraftMessage

// uint32 id = 1;
inline void AircraftMessage::clear_id() {
  id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AircraftMessage::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AircraftMessage::id() const {
  // @@protoc_insertion_point(field_get:atc_proto.AircraftMessage.id)
  return _internal_id();
}
inline void AircraftMessage::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  id_ = value;
}
inline void AircraftMessage::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:atc_proto.AircraftMessage.id)
}

// string model_icao = 2;
inline void AircraftMessage::clear_model_icao() {
  model_icao_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& AircraftMessage::model_icao() const {
  // @@protoc_insertion_point(field_get:atc_proto.AircraftMessage.model_icao)
  return _internal_model_icao();
}
inline void AircraftMessage::set_model_icao(const std::string& value) {
  _internal_set_model_icao(value);
  // @@protoc_insertion_point(field_set:atc_proto.AircraftMessage.model_icao)
}
inline std::string* AircraftMessage::mutable_model_icao() {
  // @@protoc_insertion_point(field_mutable:atc_proto.AircraftMessage.model_icao)
  return _internal_mutable_model_icao();
}
inline const std::string& AircraftMessage::_internal_model_icao() const {
  return model_icao_.Get();
}
inline void AircraftMessage::_internal_set_model_icao(const std::string& value) {
  
  model_icao_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AircraftMessage::set_model_icao(std::string&& value) {
  
  model_icao_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:atc_proto.AircraftMessage.model_icao)
}
inline void AircraftMessage::set_model_icao(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  model_icao_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:atc_proto.AircraftMessage.model_icao)
}
inline void AircraftMessage::set_model_icao(const char* value,
    size_t size) {
  
  model_icao_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:atc_proto.AircraftMessage.model_icao)
}
inline std::string* AircraftMessage::_internal_mutable_model_icao() {
  
  return model_icao_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AircraftMessage::release_model_icao() {
  // @@protoc_insertion_point(field_release:atc_proto.AircraftMessage.model_icao)
  return model_icao_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AircraftMessage::set_allocated_model_icao(std::string* model_icao) {
  if (model_icao != nullptr) {
    
  } else {
    
  }
  model_icao_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model_icao,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:atc_proto.AircraftMessage.model_icao)
}

// string airline_icao = 3;
inline void AircraftMessage::clear_airline_icao() {
  airline_icao_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& AircraftMessage::airline_icao() const {
  // @@protoc_insertion_point(field_get:atc_proto.AircraftMessage.airline_icao)
  return _internal_airline_icao();
}
inline void AircraftMessage::set_airline_icao(const std::string& value) {
  _internal_set_airline_icao(value);
  // @@protoc_insertion_point(field_set:atc_proto.AircraftMessage.airline_icao)
}
inline std::string* AircraftMessage::mutable_airline_icao() {
  // @@protoc_insertion_point(field_mutable:atc_proto.AircraftMessage.airline_icao)
  return _internal_mutable_airline_icao();
}
inline const std::string& AircraftMessage::_internal_airline_icao() const {
  return airline_icao_.Get();
}
inline void AircraftMessage::_internal_set_airline_icao(const std::string& value) {
  
  airline_icao_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AircraftMessage::set_airline_icao(std::string&& value) {
  
  airline_icao_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:atc_proto.AircraftMessage.airline_icao)
}
inline void AircraftMessage::set_airline_icao(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  airline_icao_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:atc_proto.AircraftMessage.airline_icao)
}
inline void AircraftMessage::set_airline_icao(const char* value,
    size_t size) {
  
  airline_icao_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:atc_proto.AircraftMessage.airline_icao)
}
inline std::string* AircraftMessage::_internal_mutable_airline_icao() {
  
  return airline_icao_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AircraftMessage::release_airline_icao() {
  // @@protoc_insertion_point(field_release:atc_proto.AircraftMessage.airline_icao)
  return airline_icao_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AircraftMessage::set_allocated_airline_icao(std::string* airline_icao) {
  if (airline_icao != nullptr) {
    
  } else {
    
  }
  airline_icao_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), airline_icao,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:atc_proto.AircraftMessage.airline_icao)
}

// string tail_no = 4;
inline void AircraftMessage::clear_tail_no() {
  tail_no_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& AircraftMessage::tail_no() const {
  // @@protoc_insertion_point(field_get:atc_proto.AircraftMessage.tail_no)
  return _internal_tail_no();
}
inline void AircraftMessage::set_tail_no(const std::string& value) {
  _internal_set_tail_no(value);
  // @@protoc_insertion_point(field_set:atc_proto.AircraftMessage.tail_no)
}
inline std::string* AircraftMessage::mutable_tail_no() {
  // @@protoc_insertion_point(field_mutable:atc_proto.AircraftMessage.tail_no)
  return _internal_mutable_tail_no();
}
inline const std::string& AircraftMessage::_internal_tail_no() const {
  return tail_no_.Get();
}
inline void AircraftMessage::_internal_set_tail_no(const std::string& value) {
  
  tail_no_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AircraftMessage::set_tail_no(std::string&& value) {
  
  tail_no_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:atc_proto.AircraftMessage.tail_no)
}
inline void AircraftMessage::set_tail_no(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  tail_no_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:atc_proto.AircraftMessage.tail_no)
}
inline void AircraftMessage::set_tail_no(const char* value,
    size_t size) {
  
  tail_no_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:atc_proto.AircraftMessage.tail_no)
}
inline std::string* AircraftMessage::_internal_mutable_tail_no() {
  
  return tail_no_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AircraftMessage::release_tail_no() {
  // @@protoc_insertion_point(field_release:atc_proto.AircraftMessage.tail_no)
  return tail_no_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AircraftMessage::set_allocated_tail_no(std::string* tail_no) {
  if (tail_no != nullptr) {
    
  } else {
    
  }
  tail_no_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tail_no,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:atc_proto.AircraftMessage.tail_no)
}

// string call_sign = 5;
inline void AircraftMessage::clear_call_sign() {
  call_sign_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& AircraftMessage::call_sign() const {
  // @@protoc_insertion_point(field_get:atc_proto.AircraftMessage.call_sign)
  return _internal_call_sign();
}
inline void AircraftMessage::set_call_sign(const std::string& value) {
  _internal_set_call_sign(value);
  // @@protoc_insertion_point(field_set:atc_proto.AircraftMessage.call_sign)
}
inline std::string* AircraftMessage::mutable_call_sign() {
  // @@protoc_insertion_point(field_mutable:atc_proto.AircraftMessage.call_sign)
  return _internal_mutable_call_sign();
}
inline const std::string& AircraftMessage::_internal_call_sign() const {
  return call_sign_.Get();
}
inline void AircraftMessage::_internal_set_call_sign(const std::string& value) {
  
  call_sign_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AircraftMessage::set_call_sign(std::string&& value) {
  
  call_sign_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:atc_proto.AircraftMessage.call_sign)
}
inline void AircraftMessage::set_call_sign(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  call_sign_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:atc_proto.AircraftMessage.call_sign)
}
inline void AircraftMessage::set_call_sign(const char* value,
    size_t size) {
  
  call_sign_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:atc_proto.AircraftMessage.call_sign)
}
inline std::string* AircraftMessage::_internal_mutable_call_sign() {
  
  return call_sign_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AircraftMessage::release_call_sign() {
  // @@protoc_insertion_point(field_release:atc_proto.AircraftMessage.call_sign)
  return call_sign_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AircraftMessage::set_allocated_call_sign(std::string* call_sign) {
  if (call_sign != nullptr) {
    
  } else {
    
  }
  call_sign_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), call_sign,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:atc_proto.AircraftMessage.call_sign)
}

// .atc_proto.AircraftMessage.Situation situation = 6;
inline bool AircraftMessage::_internal_has_situation() const {
  return this != internal_default_instance() && situation_ != nullptr;
}
inline bool AircraftMessage::has_situation() const {
  return _internal_has_situation();
}
inline void AircraftMessage::clear_situation() {
  if (GetArena() == nullptr && situation_ != nullptr) {
    delete situation_;
  }
  situation_ = nullptr;
}
inline const ::atc_proto::AircraftMessage_Situation& AircraftMessage::_internal_situation() const {
  const ::atc_proto::AircraftMessage_Situation* p = situation_;
  return p != nullptr ? *p : *reinterpret_cast<const ::atc_proto::AircraftMessage_Situation*>(
      &::atc_proto::_AircraftMessage_Situation_default_instance_);
}
inline const ::atc_proto::AircraftMessage_Situation& AircraftMessage::situation() const {
  // @@protoc_insertion_point(field_get:atc_proto.AircraftMessage.situation)
  return _internal_situation();
}
inline void AircraftMessage::unsafe_arena_set_allocated_situation(
    ::atc_proto::AircraftMessage_Situation* situation) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(situation_);
  }
  situation_ = situation;
  if (situation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:atc_proto.AircraftMessage.situation)
}
inline ::atc_proto::AircraftMessage_Situation* AircraftMessage::release_situation() {
  
  ::atc_proto::AircraftMessage_Situation* temp = situation_;
  situation_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::atc_proto::AircraftMessage_Situation* AircraftMessage::unsafe_arena_release_situation() {
  // @@protoc_insertion_point(field_release:atc_proto.AircraftMessage.situation)
  
  ::atc_proto::AircraftMessage_Situation* temp = situation_;
  situation_ = nullptr;
  return temp;
}
inline ::atc_proto::AircraftMessage_Situation* AircraftMessage::_internal_mutable_situation() {
  
  if (situation_ == nullptr) {
    auto* p = CreateMaybeMessage<::atc_proto::AircraftMessage_Situation>(GetArena());
    situation_ = p;
  }
  return situation_;
}
inline ::atc_proto::AircraftMessage_Situation* AircraftMessage::mutable_situation() {
  // @@protoc_insertion_point(field_mutable:atc_proto.AircraftMessage.situation)
  return _internal_mutable_situation();
}
inline void AircraftMessage::set_allocated_situation(::atc_proto::AircraftMessage_Situation* situation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete situation_;
  }
  if (situation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(situation);
    if (message_arena != submessage_arena) {
      situation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, situation, submessage_arena);
    }
    
  } else {
    
  }
  situation_ = situation;
  // @@protoc_insertion_point(field_set_allocated:atc_proto.AircraftMessage.situation)
}

// -------------------------------------------------------------------

// TaxiPathMessage

// int32 from_node_id = 1;
inline void TaxiPathMessage::clear_from_node_id() {
  from_node_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaxiPathMessage::_internal_from_node_id() const {
  return from_node_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaxiPathMessage::from_node_id() const {
  // @@protoc_insertion_point(field_get:atc_proto.TaxiPathMessage.from_node_id)
  return _internal_from_node_id();
}
inline void TaxiPathMessage::_internal_set_from_node_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  from_node_id_ = value;
}
inline void TaxiPathMessage::set_from_node_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_from_node_id(value);
  // @@protoc_insertion_point(field_set:atc_proto.TaxiPathMessage.from_node_id)
}

// int32 to_node_id = 2;
inline void TaxiPathMessage::clear_to_node_id() {
  to_node_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaxiPathMessage::_internal_to_node_id() const {
  return to_node_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaxiPathMessage::to_node_id() const {
  // @@protoc_insertion_point(field_get:atc_proto.TaxiPathMessage.to_node_id)
  return _internal_to_node_id();
}
inline void TaxiPathMessage::_internal_set_to_node_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  to_node_id_ = value;
}
inline void TaxiPathMessage::set_to_node_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_to_node_id(value);
  // @@protoc_insertion_point(field_set:atc_proto.TaxiPathMessage.to_node_id)
}

// repeated int32 edge_ids = 3;
inline int TaxiPathMessage::_internal_edge_ids_size() const {
  return edge_ids_.size();
}
inline int TaxiPathMessage::edge_ids_size() const {
  return _internal_edge_ids_size();
}
inline void TaxiPathMessage::clear_edge_ids() {
  edge_ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaxiPathMessage::_internal_edge_ids(int index) const {
  return edge_ids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaxiPathMessage::edge_ids(int index) const {
  // @@protoc_insertion_point(field_get:atc_proto.TaxiPathMessage.edge_ids)
  return _internal_edge_ids(index);
}
inline void TaxiPathMessage::set_edge_ids(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  edge_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:atc_proto.TaxiPathMessage.edge_ids)
}
inline void TaxiPathMessage::_internal_add_edge_ids(::PROTOBUF_NAMESPACE_ID::int32 value) {
  edge_ids_.Add(value);
}
inline void TaxiPathMessage::add_edge_ids(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_edge_ids(value);
  // @@protoc_insertion_point(field_add:atc_proto.TaxiPathMessage.edge_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
TaxiPathMessage::_internal_edge_ids() const {
  return edge_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
TaxiPathMessage::edge_ids() const {
  // @@protoc_insertion_point(field_list:atc_proto.TaxiPathMessage.edge_ids)
  return _internal_edge_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
TaxiPathMessage::_internal_mutable_edge_ids() {
  return &edge_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
TaxiPathMessage::mutable_edge_ids() {
  // @@protoc_insertion_point(field_mutable_list:atc_proto.TaxiPathMessage.edge_ids)
  return _internal_mutable_edge_ids();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace atc_proto

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::atc_proto::GeoEdgeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::atc_proto::GeoEdgeType>() {
  return ::atc_proto::GeoEdgeType_descriptor();
}
template <> struct is_proto_enum< ::atc_proto::AircraftCategory> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::atc_proto::AircraftCategory>() {
  return ::atc_proto::AircraftCategory_descriptor();
}
template <> struct is_proto_enum< ::atc_proto::OperationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::atc_proto::OperationType>() {
  return ::atc_proto::OperationType_descriptor();
}
template <> struct is_proto_enum< ::atc_proto::ParkingStandType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::atc_proto::ParkingStandType>() {
  return ::atc_proto::ParkingStandType_descriptor();
}
template <> struct is_proto_enum< ::atc_proto::TaxiEdgeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::atc_proto::TaxiEdgeType>() {
  return ::atc_proto::TaxiEdgeType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_atc_2eproto
